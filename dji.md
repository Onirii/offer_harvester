# 1. debug与release的区别，未初始化的变量？
## 1.1 Qt中debug与release的区别
1. debug可以调试程序了，而release就不可以。在程序出现错误的时候，在debug模式下通过设置断点来调试程序。当程序所有错误都解决了以后，在release模式下生成程序，就可以对外发布了。debug生成的程序因为包含了调试信息，编译器也未做优化，所以比release模式生成的程序要大很多。
2. debug和release模式下对于变量的初始化采取不同的态度。debug模式下不对成员变量进行初始化，而在release模式下会初始化为0。

## 1.2 VS中debug与release的区别
1. Debug和Release只是两个编译的选项而已，是编译器所要进行工作的一系列指令，它们只是编译指令的集合的名称。
2. Debug：Debug通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不做任何优化，以为开发人员提供强大的应用程序调试能力。
3. Release：Release通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。

# 2. 32位与64位的区别？X86框架？
1. 32位与64位可以用来形容CPU或者操作系统。
2. CPU的位数指的是数据总线位数，而决定最大支持内存(CPU能够访问的存储单元的范围)的则是地址总线位数。
3. 32位与64位指的是计算机CPU地址线的位数，32位CPU含有32根地址线，寻址能力为2的32次方个字节，相当于4G内存。而64位CPU理论上寻址能力为2的64次方个字节，但目前硬件还达不到这个水准。
4. 地址总线的宽度决定了CPU的寻址能力；数据总线的宽度决定了CPU对其他器件进行数据传输时的一次数据传输量；控制总线的宽度决定了CPU对系统中其他器件的控制能力。
5. 在Windows环境中，32位和64位软件主要是其编译环境不同，32位的编译器和64位的编译器主要区别在一些常见变量类型的大小不同。

# 3. CPU占用过高如何处理？
## 3.1 Qt中CPU占用过高
1. Qt开发中会造成程序CPU占用过高的原因：
	1. 在paintEvent中调用update函数，造成无限循环 
	2. 频繁刷新数据 
	3. 复杂的浮点运算 
	4. 死循环 
	5. paintEvent里操作太多 

# 4. 内存泄漏如何排查？
1. 在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

## 4.1 Qt中内存泄漏的排查

## 4.2 Windows + VS中内存泄漏的排查

## 4.3 Linux中内存泄漏的排查


# 5. 普通函数的调度过程？
1. 函数参数代入  从右往左
2. 函数栈帧开辟
3. 函数返回值
4. 函数栈帧回退

5. 避免函数调用： 使用内联函数

# 6. 进程A能否通过地址访问进程B？
1. 不同进程的地址空间是独立的


# 7. 指针间转换需要注意的问题？
## 7.1 普通指针、智能指针
## 7.2 C++的强制类型转换运算符

# 8. 多线程需要注意的问题？
## 8.1 为什么要是使用多线程
## 8.2 公共资源的线程安全性
## 8.3 防止死锁
### 8.3.1 可抢占性资源与不可抢占性资源
1. **可抢占性资源** 可抢占性资源是指进程在获得这类资源后，该资源可以再被其他进程或者系统抢占，对于这类资源是不会引起死锁的。
2. **不可抢占性资源** 一旦系统把不可抢占资源分配给进程后，就不能将它强行收回，只能在进程用完后自行释放。

### 8.3.2 死锁发生的条件
如果一组进程中的每一个进程**都在**等待仅由该组进程中的其他进程才能引发的时间，那么该组进程就是死锁的。<br>
死锁是指两个或者两个以上的进程在执行过程中，因争夺资源而造成的相互等待的现象。死锁发生的四个必要条件如下:<br>
1. **互斥条件**： 进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；
2. **请求和保持条件**： 进程获得一定资源后，又对其他资源发出请求，但是该资源可能被其他进程占有。此时请求阻塞，但是该进程不会释放掉自己已经占有的资源；
3. **不可抢占条件**： 进程已经获得的资源，在未使用完成前，不可被抢占，只能在使用后自己释放；
4. **环路等待条件**： 进程发生死锁后，必然存在一个进程-资源之间的环形链。

### 8.3.3 该如何解决死锁？
1. 死锁预防：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申请所需要的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会降低系统的效率。
2. 死锁避免：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免算法的执行会增加系统的开销。
3. 死锁检测：死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则执行死锁解除策略。
4. 死锁解除：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，分配给其他的进程。

#### 8.3.3.1 银行家算法



## 8.4 线程的终止
1. 尽量使用join()而不是detach()；

## 8.5 僵尸线程和孤儿线程
### 8.5.1 什么是正常进程、孤儿进程和僵尸进程？
1. **正常进程** 正常情况下，子进程是通过父进程创建的，子进程再去创建新的进程。子进程的结束和父进程的运行是一个异步的过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。UNIX提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。在每个进程退出的时候，内核释放该进程的所有资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，直到父进程通过wait()/waitpid()来取时才释放。保存的信息包括：1. 进程号 2. 退出状态 3. 运行时间等。

2. **孤儿进程** 一个父进程退出，而它的一个或者多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

3. **僵尸进程** 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()获取子进程的状态信息，那么子进程的状态描述符仍然会保存在系统中。这种进程称之为僵尸进程。
	1. 僵尸进程是一个进程必然会经过的过程，是每个子进程在结束时都要经过的阶段。
	2. 如果子进程在exit()之后，父进程没有来的及处理，这时用ps命令就能看到子进程的状态是“Z”(僵死状态)。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。
	3. 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

### 8.5.2 僵尸进程有什么危害？怎样解决这个问题？
如果进程不调用wait()/waitpid()的话，那么其保留的诸多信息就不会被释放，其进程号就会被一直占用着，但是系统所能使用的进程号是有限的，如果大量地产生僵尸进程，将因为没有可用的进程号而不能再产生新的进程。<br>
解决僵尸进程给系统带来的问题:
1. 外部消灭：通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。
2. 内部解决：
	1. 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait()进行处理僵尸进程。
	2. fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。