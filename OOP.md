# 1.面向对象的设计原则

## 1.1 单一功能原则(SRP: Single-Responsibility Principle)
**解耦和增强内聚性**（高内聚、低耦合）<br>
单一功能原则的核心就是控制类的粒度大小，将对象解耦、提高其内聚性。<br>
一个类，最好只做一件事，只有一个引起它变化的原因。单一功能原则可以看做是低耦合、高内聚在面向对象原则上的引申，将功能定义为引起变化的原因，以提高内聚性来减少引起变化的原因。功能过多，可能引起它变化的原因就越多，这将导致功能依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。

### 1.1.1 单一功能原则的优点
1. 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
2. 提高类的可读性。复杂性降低，自然其可读性会提高。
3. 提高系统的可维护性。可读性提高，那自然更容易维护了。
4. 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

## 1.2 开放封闭原则(OCP: Open-Closed Principle)
**软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。**
开放封闭原则主要体现在两个方面:<br>
1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
2. 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。

实现开放封闭原则的核心思想就是**对抽象编程，而不对具体编程**，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。“需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。

### 1.2.1 开放封闭原则的作用： 
开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。

1. 对软件测试的影响<br>
软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
2. 可以提高代码的可复用性<br>
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
3. 可以提高软件的可维护性<br>
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

## 1.3 里氏代换原则(LSP: Liskov-Substituion Principle)
**子类必须能够替换基类。**<br>
这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。<br>
Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠的。<br>
实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。<br>Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。<br>Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

### 1.3.1 里氏替换原则的作用：
1. 里氏替换原则是实现开闭原则的重要方式之一；
2. 里氏替换原则克服了继承中重写父类造成的可复用性变差的缺点；
3. 里氏替换原则是动作正确性的保证，即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

## 1.4 依赖倒转原则(DIP: Dependency-Inversion Principle)
**依赖于抽象。高层模块不依赖于底层模块，二者共同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。**<br>
依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是**分离接口和实现**：**在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。**<br>
抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。<br>
依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一成不变的。依赖于抽象，就是**对接口编程，不要对实现编程**。

### 1.4.1 依赖倒置原则的作用
1. 依赖倒置原则可以降低类间的耦合性。
2. 依赖倒置原则可以提高系统的稳定性。
3. 依赖倒置原则可以减少并行开发引起的风险。
4. 依赖倒置原则可以提高代码的可读性和可维护性。

### 1.4.2 依赖倒置原则的实现
1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

## 1.5 接口分离原则(ISP: Interface-Segregation Principle)
**使用多个小的专门的接口，而不要使用一个大的总接口。**
具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。<br>
接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。<br>
分离的手段主要有以下两种：<br>
1. 委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。
2. 多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

### 1.5.1 接口分离原则的作用
1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

### 1.5.2 接口分离原则的实现
1. 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
2. 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
3. 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
4. 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

## 1.6 合成复用原则(CPR: Composite-Reuse Principle)
**尽量使用合成/聚合的方式，而不是使用继承。**
### 1.6.1 继承复用和合成复用
继承复用具有简单个易实现的优点，它也存在以下缺点：<br>
1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用；
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护；
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：<br>
1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用；
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口；
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

### 1.6.2 合成服用原则的实现方法
合成复用原则是通过将已有的对象纳入新对象中，**作为新对象的成员对象**来实现的，新对象可以调用已有对象的功能，从而达到复用。

## 1.7 最少知识原则(LKP: Least-Knowledge Principle，迪米特法则)
**一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。**
迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

### 1.7.1 迪米特法则的优点
迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：<br>
1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使**模块之间的通信效率降低**。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
### 1.7.2 迪米特法则的实现方法
从迪米特法则的定义和特点可知，它强调以下两点：
1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。

### 1.7.3 运用迪米特法则时的注意项
1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
2. 在类的结构设计上，尽量降低类成员的访问权限。
3. 在类的设计上，优先考虑将一个类设置成不变类。
4. 在对其他类的引用上，将引用其他对象的次数降到最低。
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
6. 谨慎使用序列化（Serializable）功能。


# 2. 面向对象的特征
## 2.1 封装
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
## 2.2 继承
继承是可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。
## 2.3 多态
一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。


# 3. C++ 面向对象编程
## 3.1 封装

## 3.2 继承

### 3.2.1 友元可以继承吗？
不能！友元只是能访问指定类的私有和保护成员的自定义函数，不是被指定类的成员，自然不能继承。 使用友元类时注意： 
1. 友元关系不能被继承。 
2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 
3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。

### 3.2.2 静态数据成员及静态函数成员能不能被继承？
基类与派生类的静态成员函数与静态成员是共用一段空间的，即静态成员和静态成员函数是可以继承的。 <br>
所以，我们可以得出以下结论：父类的static变量和函数在派生类中依然可用，但是受访问性控制（比如，父类的private域中的就不可访问）。而且对static变量来说，派生类和父类中的static变量是共用空间的，这点在利用static变量进行引用计数的时候要特别注意。

### 3.2.3 继承类型
#### 3.2.3.0 类访问修饰符

修饰符|类内部|该类对象|子类(派生类)|友元函数
-|-|-|-|-
public|可访问|可访问|可访问|可访问
private|可访问|不可访问|不可访问|可访问
protected|可访问|不可访问|可访问|可访问

#### 3.2.3.1 公有继承(public):
1. 基类成员对其对象的可见性与一般类及其对象的可见性相同,公有成员可见，其他成员不可见。
2. 对于派生类来说，基类的公有成员和保护成员可见，基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态；基类的私有成员不可见，基类的私有成员仍然是私有的，派生类不可访问基类中的私有成员。
3. 对于派生类对象来说，基类的公有成员是可见的，其他成员不可见。

#### 3.2.3.2 私有继承(private):
1. 基类成员对其对象的可见性与一般类及其对象的可见性相同，公有成员可见，其他成员不可见。
2. 对于派生类来说，基类的公有成员和保护成员时可见的，基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问；基类的私有成员是不可见的，派生类中不可访问基类中的私有成员。
3. 对于派生类对象来说，基类的所有成员都是不可见的。

#### 3.2.3.3 保护继承(protected):
1. 基类成员及其对象的可见性与一般类及其对象的可见性相同，公有成员可见，其他成员不可见。
2. 对派生类来说，基类的公有成员和保护成员时可见的，基类的公有成员和保护成员都作为派生类的保护成员，并且不能被这个派生类的子类所访问；基类的私有成员是不可见的，派生类中不可访问基类中的私有成员。
3. 对派生类对象来说，基类的所有成员都是不可见的。

### 3.2.4 虚继承

### 3.2.5 多重继承有什么优点和缺陷？


## 3.3 多态
### 3.3.1 什么是多态，多态又分哪几种？
多态指事物的多种形态，在C++中，对象在接受到相同的消息时，能够做出不同响应的特性称为多态。<br>
在面向对象程序设计中，多态一般有四类：<br> 
1. **重载多态**： 函数重载、运算符重载；
2. **强制多态**： 将一个变量的类型转换成符合函数或者操作的类型，如强制类型转换；
3. **包含多态**： 类族中不同类中的同名成员函数的多态行为，可以通过虚函数实现；
4. **参数多态**： 与类模板相关联，与类型有关。
 
### 3.3.2 C++ 多态的实现方式


### 3.3.3 如何理解虚函数和多态？

### 3.3.4 静态函数和虚函数有什么区别？

### 3.3.5 虚函数和纯虚函数有什么区别？
1. 虚函数声明如下：virtual ReturnType FunctionName(Parameter); 虚函数必须实现，如果不实现，编译器将报错。
2. 纯虚函数声明如下： virtual void FunctionName()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
3. 对于虚函数来说，父类和子类都有各自的版本，由多态方式调用的时候动态绑定。
4. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5. 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
6. 包含纯虚函数的类不能定义其对象，而包含虚函数的则可以。

### 3.3.6 虚函数表具体是怎样实现运行时多态的？

### 3.3.7 构造函数为什么不能是虚函数？
1. **从存储空间角度**， 虚函数对应一个vtable，这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。 
2. **从使用角度**， 构造函数本身就是要初始化实例，那使用虚函数也不具有实际意义。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 
3. 构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。 
4. 从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数。

### 3.3.8 为什么析构函数必须是虚函数？ 为什么C++默认的析构函数不是虚函数？
假设析构没有设置成虚函数，如果有基类指针指向派生类，那么用基类指针delete时，派生类中派生的那部分无法析构，造成内存泄漏。
默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数。

### 3.3.9 构造函数和析构函数的调用顺序是什么样的？
1. 基类对象首先被创建 
2. 派生类构造函数应通过成员初始化列表（调用顺序和继承顺序相关）将基类信息传递给基类构造函数，可以使用初始化列表句法指明要使用的基类构造函数，否则将使用默认的基类构造函数。 
3. 派生类构造函数应初始化派生类新增的数据成员 
4. 派生类对象析构时，程序首先调用派生类析构函数，再调用基类析构函数。

### 3.3.10 C++ 虚函数的用处、缺点、什么时候该用、什么时候不该用？
 

### 3.3.11 类成员函数中重载、重写(覆盖)、重定义(隐藏)的区别？
**函数重载**：重载函数通常用来命名一组功能相似的函数<br>
1. 函数要在相同的类域；
2. 函数的名字要相同；
3. 函数的参数列表或返回值不同。

**函数覆盖**：覆盖是指派生类函数覆盖基类函数<br>
1. 函数是要在不同的类域 
2. 两个函数的名称相同 
3. 基类函数必须是虚函数 
4. 两个函数的参数相同

**函数隐藏**：指派生类的函数屏蔽了与其同名的基类函数<br>
1. 两个函数在不同的类域 
2. 函数名称相同 
3. 函数参数不同 
4. 如果派生类函数与基类函数参数相同，但是在基类函数中没有virtual关键字，发生函数隐藏

### 3.3.12 虚函数表和虚函数指针
 

### 3.3.13 override说明符与final说明符
派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。<br>
1. **override**  被override标记的函数如果没有覆盖已存在的虚函数，编译器将报错。
2. **final**  被final标记的函数，之后任何尝试覆盖该函数的操作都将引发错误。

### 3.3.14 为什么虚函数效率较低？
因为虚函数需要一次简介寻址，而一般的函数可以在编译时定位到函数的地址，虚函数(动态类型调用)是要根据某个指针定位到函数的地址。多增加了一个过程，效率肯定会低一些，但带来了运行时的多态。

### 3.3.15 虚函数的入口地址与普通函数有什么不同？
每个虚函数都在vtable中占了一个表项，保存着一条跳转到它的入口地址的指令(实际上就是保存了它的入口地址)。当一个包含虚函数的对象(不是对象的指针)被创建的时候，它在头部附加一个指针，指向vtable中相应的位置。调用虚函数的时候，不管是用什么指针调用的，它先根据vtable找到入口地址再执行，从而实现“动态联编”，而不是像普通函数那样简单地调到一个固定的地址。

### 3.3.16 