# 1.面向对象的设计原则

## 1.1 单一功能原则(SRP: Single-Responsibility Principle)
**解耦和增强内聚性**（高内聚、低耦合）<br>
单一功能原则的核心就是控制类的粒度大小，将对象解耦、提高其内聚性。<br>
一个类，最好只做一件事，只有一个引起它变化的原因。单一功能原则可以看做是低耦合、高内聚在面向对象原则上的引申，将功能定义为引起变化的原因，以提高内聚性来减少引起变化的原因。功能过多，可能引起它变化的原因就越多，这将导致功能依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。

### 1.1.1 单一功能原则的优点
1. 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
2. 提高类的可读性。复杂性降低，自然其可读性会提高。
3. 提高系统的可维护性。可读性提高，那自然更容易维护了。
4. 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

## 1.2 开放封闭原则(OCP: Open-Closed Principle)
**软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。**
开放封闭原则主要体现在两个方面:<br>
1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
2. 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。

实现开放封闭原则的核心思想就是**对抽象编程，而不对具体编程**，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。“需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。

### 1.2.1 开放封闭原则的作用： 
开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。

1. 对软件测试的影响<br>
软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
2. 可以提高代码的可复用性<br>
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
3. 可以提高软件的可维护性<br>
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

## 1.3 里氏代换原则(LSP: Liskov-Substituion Principle)
**子类必须能够替换基类。**<br>
这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。<br>
Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠的。<br>
实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。<br>Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。<br>Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

### 1.3.1 里氏替换原则的作用：
1. 里氏替换原则是实现开闭原则的重要方式之一；
2. 里氏替换原则克服了继承中重写父类造成的可复用性变差的缺点；
3. 里氏替换原则是动作正确性的保证，即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

## 1.4 依赖倒转原则(DIP: Dependency-Inversion Principle)
**依赖于抽象。高层模块不依赖于底层模块，二者共同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。**<br>
依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是**分离接口和实现**：**在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。**<br>
抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。<br>
依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一成不变的。依赖于抽象，就是**对接口编程，不要对实现编程**。

### 1.4.1 依赖倒置原则的作用
1. 依赖倒置原则可以降低类间的耦合性。
2. 依赖倒置原则可以提高系统的稳定性。
3. 依赖倒置原则可以减少并行开发引起的风险。
4. 依赖倒置原则可以提高代码的可读性和可维护性。

### 1.4.2 依赖倒置原则的实现
1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。  
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

## 1.5 接口分离原则(ISP: Interface-Segregation Principle)
**使用多个小的专门的接口，而不要使用一个大的总接口。**
具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。<br>
接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。<br>
分离的手段主要有以下两种：<br>
1. 委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。
2. 多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

### 1.5.1 接口分离原则的作用
1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

### 1.5.2 接口分离原则的实现
1. 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
2. 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
3. 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
4. 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

## 1.6 合成复用原则(CPR: Composite-Reuse Principle)
**尽量使用合成/聚合的方式，而不是使用继承。**
### 1.6.1 继承复用和合成复用
继承复用具有简单个易实现的优点，它也存在以下缺点：<br>
1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用；
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护；
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：<br>
1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用；
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口；
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

### 1.6.2 合成服用原则的实现方法
合成复用原则是通过将已有的对象纳入新对象中，**作为新对象的成员对象**来实现的，新对象可以调用已有对象的功能，从而达到复用。

## 1.7 最少知识原则(LKP: Least-Knowledge Principle，迪米特法则)
**一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。**
迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

### 1.7.1 迪米特法则的优点
迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：<br>
1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使**模块之间的通信效率降低**。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
### 1.7.2 迪米特法则的实现方法
从迪米特法则的定义和特点可知，它强调以下两点：
1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。

### 1.7.3 运用迪米特法则时的注意项
1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
2. 在类的结构设计上，尽量降低类成员的访问权限。
3. 在类的设计上，优先考虑将一个类设置成不变类。
4. 在对其他类的引用上，将引用其他对象的次数降到最低。
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
6. 谨慎使用序列化（Serializable）功能。


# 2. 面向对象的特征
## 2.1 封装
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
## 2.2 继承
继承是可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。
## 2.3 多态
一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。


# 3. C++ 面向对象编程
## 3.1 封装
### 3.1.1 
### 3.1.2 友元

## 3.2 继承

### 3.2.1 友元可以继承吗？
不能！友元只是能访问指定类的私有和保护成员的自定义函数，不是被指定类的成员，自然不能继承。 使用友元类时注意： 
1. 友元关系不能被继承。 
2. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 
3. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。

### 3.2.2 静态数据成员及静态函数成员能不能被继承？
基类与派生类的静态成员函数与静态成员是共用一段空间的，即静态成员和静态成员函数是可以继承的。 <br>
所以，我们可以得出以下结论：父类的static变量和函数在派生类中依然可用，但是受访问性控制（比如，父类的private域中的就不可访问）。而且对static变量来说，派生类和父类中的static变量是共用空间的，这点在利用static变量进行引用计数的时候要特别注意。

### 3.2.3 继承类型
#### 3.2.3.0 类访问修饰符

修饰符|类内部|该类对象|子类(派生类)|友元函数
-|-|-|-|-
public|可访问|可访问|可访问|可访问
private|可访问|不可访问|不可访问|可访问
protected|可访问|不可访问|可访问|可访问

#### 3.2.3.1 公有继承(public):
1. 基类成员对其对象的可见性与一般类及其对象的可见性相同,公有成员可见，其他成员不可见。
2. 对于派生类来说，基类的公有成员和保护成员可见，基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态；基类的私有成员不可见，基类的私有成员仍然是私有的，派生类不可访问基类中的私有成员。
3. 对于派生类对象来说，基类的公有成员是可见的，其他成员不可见。

#### 3.2.3.2 私有继承(private):
1. 基类成员对其对象的可见性与一般类及其对象的可见性相同，公有成员可见，其他成员不可见。
2. 对于派生类来说，基类的公有成员和保护成员时可见的，基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问；基类的私有成员是不可见的，派生类中不可访问基类中的私有成员。
3. 对于派生类对象来说，基类的所有成员都是不可见的。

#### 3.2.3.3 保护继承(protected):
1. 基类成员及其对象的可见性与一般类及其对象的可见性相同，公有成员可见，其他成员不可见。
2. 对派生类来说，基类的公有成员和保护成员时可见的，基类的公有成员和保护成员都作为派生类的保护成员，并且不能被这个派生类的子类所访问；基类的私有成员是不可见的，派生类中不可访问基类中的私有成员。
3. 对派生类对象来说，基类的所有成员都是不可见的。

### 3.2.4 虚继承

### 3.2.5 多重继承有什么优点和缺陷？


## 3.3 多态
### 3.3.1 什么是多态，多态又分哪几种？
多态指事物的多种形态，在C++中，对象在接受到相同的消息时，能够做出不同响应的特性称为多态。<br>
在面向对象程序设计中，多态一般有四类：<br> 
1. **重载多态**： 函数重载、运算符重载；
2. **强制多态**： 将一个变量的类型转换成符合函数或者操作的类型，如强制类型转换；
3. **包含多态**： 类族中不同类中的同名成员函数的多态行为，可以通过虚函数实现；
4. **参数多态**： 与类模板相关联，与类型有关。
 
### 3.3.2 C++ 多态的实现方式
#### 3.3.2.1 静态类型和动态类型、静态绑定和动态绑定
1. 静态类型和动态类型。**静态类型指的是对象声明的类型，在编译器确定的。动态类型指的是对象的所指向的类型。**动态类型是可以更改的，静态类型无法更改。继承关系会导致对象的指针和引用具有静态类型和动态类型，因为继承关系的存在中可能会存在类型之间的向上向下类型转换。

2. 静态绑定和动态绑定。某特性(函数)依赖于对象的静态类型，则在编译期确定，某特性(函数)依赖于对象的动态类型，则在运行期确定。只有通过基类的引用或者指针调用虚函数时，才能发生动态绑定，如果使用对象来操作虚函数的话，仍然会采用静态绑定的方式。因为引用或者指针既可以指向基类对象，也可以指向派生类对象的基类部分，用引用或者指针调用的虚函数，就会根据引用或者指针具体的对象类型在运行时对具体调用哪个虚函数进行动态绑定。

#### 3.3.2.2 C++虚函数动态绑定的实现机制
**对象的指针或者引用调用虚函数的行为是动态绑定。**
虚函数的动态绑定是基于虚函数表实现的。对于每一个含有虚函数的类，编译器为位子创建一个虚函数表Vtable，虚函数表中是各虚函数的函数入口指针。类的虚函数表在编译时期创建，被该类的所有对象共享。编译器会为每个类的对象分配指向该类虚函数表的指针。当类之间有继承关系发生，派生类中对应的虚函数指针会被覆盖为自己类本身的。

#### 3.3.2.3 C++多态性的体现
C++多态性代码层面体现的是父类的指针或引用调用虚成员函数。多态产生有三个条件：产生的条件是继承关系、基类中含有虚成员函数、派生类重写基类的虚成员函数。当用父类指针或引用调用虚成员函数，这个调用关系在运行器可能绑定(关联)到不同的子类，产生不同的行为。

### 3.3.3 如何理解虚函数和多态？

### 3.3.4 静态函数和虚函数有什么区别？

### 3.3.5 虚函数和纯虚函数有什么区别？
1. 虚函数声明如下：virtual ReturnType FunctionName(Parameter); 虚函数必须实现，如果不实现，编译器将报错。
2. 纯虚函数声明如下： virtual void FunctionName()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
3. 对于虚函数来说，父类和子类都有各自的版本，由多态方式调用的时候动态绑定。
4. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5. 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
6. 包含纯虚函数的类不能定义其对象，而包含虚函数的则可以。

### 3.3.6 虚函数表具体是怎样实现运行时多态的？

### 3.3.7 构造函数为什么不能是虚函数？
1. 虚函数调用是在**部分信息**完成工作的机制，允许程序只知道接口而不知道对象的确切类型。要创建一个对象，则需要知道对象的完整信息。特别需要知道待创建对象的确切类型，因此构造函数不应该被定义为虚函数。
2. 虚函数的作用在于其在派生类中被重写，而通过父类的指针或者引用指向不同的派生类对象，调用到不同派生类中的虚函数，产生不同行为。而构造函数是在创建对象时候自己主动调用的，不可能通过指向子类的指针或者引用去调用。
3. 类的对象调用虚函数是通过一个指向虚函数表的虚函数表指针来完成的，虚函数表属于整个类，对象指向虚函数表的指针属于对象本身。假设构造函数是虚函数，那么调用此构造函数时对象还没有创建，无法获取其虚函数指针，这是一个矛盾的过程。

### 3.3.8 什么情况下析构函数必须是虚函数？ 为什么C++默认的析构函数不是虚函数？
1. 具有多态性质的基类的析构函数必须是虚函数。
2. C++中基类采用虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。**假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。**那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
3. 默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数。

### 3.3.9 析构函数可以是纯虚函数吗？
纯虚析构函数一定要在派生类中得到定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。因此，缺乏任何一个基类析构函数的定义，就会导致链接失败。因此，最好不要把虚析构函数定义为纯虚析构函数。

### 3.3.9 构造函数和析构函数的调用顺序是什么样的？
对象是由“底层向上”开始构造的，当建立一个对象时，首先调用基类的构造函数，然后调用下一个派生类的构造函数，依次类推，直至到达派生类次数最多的派生次数最多的类的构造函数为止。因为，构造函数一开始构造时，总是要调用它的基类的构造函数，然后才开始执行其构造函数体，调用直接基类构造函数时，如果无专门说明，就调用直接基类的默认构造函数。在对象析构时，其顺序正好相反。

### 3.3.10 C++ 虚函数的用处、缺点、什么时候该用、什么时候不该用？
 

### 3.3.11 构造函数和析构函数中可以调用虚函数吗？
1. 在C++中，提倡不在构造函数和析构函数中调用虚函数，这样调用并不会产生预期的效果。
2. 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；
3. 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
4. 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。


### 3.3.12 虚函数表和虚函数指针


### 3.3.13 override说明符与final说明符
派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。<br>
1. **override**  被override标记的函数如果没有覆盖已存在的虚函数，编译器将报错。
2. **final**  被final标记的函数，之后任何尝试覆盖该函数的操作都将引发错误。

### 3.3.14 为什么虚函数效率较低？
因为虚函数需要一次间接寻址，而一般的函数可以在编译时定位到函数的地址，虚函数(动态类型调用)是要根据某个指针定位到函数的地址。多增加了一个过程，效率肯定会低一些，但带来了运行时的多态。

### 3.3.15 虚函数的入口地址与普通函数有什么不同？
每个虚函数都在vtable中占了一个表项，保存着一条跳转到它的入口地址的指令(实际上就是保存了它的入口地址)。当一个包含虚函数的对象(不是对象的指针)被创建的时候，它在头部附加一个指针，指向vtable中相应的位置。调用虚函数的时候，不管是用什么指针调用的，它先根据vtable找到入口地址再执行，从而实现“动态联编”，而不是像普通函数那样简单地调到一个固定的地址。

### 3.3.16 重载
C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。
重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。
当调用一个重载函数或重载运算符时，编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。<br>
#### 3.3.16.1 

#### 3.3.16.2 类中哪些函数不能被重载，为什么？
1. 析构函数不能被重载，因为析构函数没有返回值和参数列表，而重载函数之间的区别就在参数列表和定义，自然析构函数不能被重载。
2. 不能重载的运算符有：
	1. **.** ：成员访问运算符
	2. **.\*, ->\*** ：成员指针访问运算符
	3. **::** ：域运算符
	4. **sizeof** ：长度运算符
	5. **?:** ：条件运算符
	6. **#** ： 预处理符号

#### 3.3.16.3 为什么“=”操作符只能重载为类的非静态成员函数？

1. “=”操作符不能重载为类的静态成员函数是因为静态函数是属于整个类的，而不是属于某个对象，它只能操作类的静态数据成员，而赋值运算符“=”是基于对象操作的。
2. 赋值运算符也不能重载为友元函数。当类中没有定义赋值运算符重载成员函数时(在未定义形参数据类型为该类类型的赋值运算符重载函数时，编译器会自动生成加入。)，当程序执行到某一赋值语句时，程序就会调用与赋值语句中右值类型匹配的构造函数，而把这右值当做此构造函数的实参。而当类中有定义赋值运算符重载成员函数，执行赋值语句时，程序就会调用相应的赋值运算符函数。<br>
友元函数不是类的成员函数，它只是类的“朋友”，具有访问把它声明为“朋友”的类的数据成员的权限而已。
那么当把赋值运算符重载为类的友员函数，在程序中执行类对象的赋值语句时，程序就会出现两种矛盾的选择。
	1. 因为它认为类中并没有重载赋值运算符的成员函数，所以它根据C++的规则，会去调用相应的构造函数。
	2. 但是在全局里，我们已经重载了参数类型为此类类型的赋值运算符函数，而这赋值语句刚好和这函数匹配上了，根据C++的规则，也会去调用这函数。<br>
程序是不允许有矛盾不确定选择的，所以当赋值运算符重载为类的友元函数时，编译器就会提示错误。

3. 运算符 ->, [], () 也不能重载为友元函数，原因和上面一样。即编译器发现当类中没有定义这3个运算符的重载成员函数时，就会自己加入默认的运算符重载成员函数。因此这四个运算符写成友元函数时会报错，产生矛盾。

#### 3.3.16.4 类中的重载、覆盖和重定义之间有什么区别？
**函数重载**：重载函数通常用来命名一组功能相似的函数<br>
1. 函数要在相同的类域；
2. 函数的名字要相同；
3. 函数的参数列表或返回值不同。

**函数覆盖**：覆盖是指派生类函数覆盖基类函数<br>
1. 函数是要在不同的类域 
2. 两个函数的名称相同 
3. 基类函数必须是虚函数 
4. 两个函数的参数相同

**函数隐藏**：指派生类的函数屏蔽了与其同名的基类函数<br>
1. 两个函数在不同的类域 
2. 函数名称相同 
3. 函数参数不同 
4. 如果派生类函数与基类函数参数相同，但是在基类函数中没有virtual关键字，发生函数隐藏。