# 1. 视C++为一个联邦
# 2. 尽量以const、enum、inline替换 \#define
# 3. 尽可能使用const
# 4. 确定对象被使用前已经先被初始化
1. 为**内置型对象**进行手工初始化，因为C++不保证初始化它们。
	1. 读取未初始化的值会导致不明确行为。
2. 构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。
	1. 初始化和赋值的区别
		1. 如果在类的带参数的构造函数中传递参数，在构造函数体内使用实参对类的成员变量赋值，这个过程会先调用成员变量的default构造函数为其设初值，然后再立即对它们赋予新值，default构造函数所做的工作就浪费了。
	2. C++规定，对象的成员变量的初始化动作发生在进入构造函数本体前。
	3. 使用初值列的做法会减少一个环节，初值列中针对各个成员变量而设的实参，被拿做各个成员变量构造函数的实参。
	4. 如果要default构造一个成员变量，也可以使用成员初值列，只要指定初始化参数为空。
	5. 如果成员变量是const或者reference，那么它们就一定需要初值，不能被赋值。
	6. 在有继承关系的类中，基类的初始化发生在子类初始化之前。
	7. 类中的成员变量按照其声明的顺序初始化。
3. 为免除“跨编译单元之初始化次序”，应该以local static对象替换non-local static对象。
	1. 编译单元是指产出单一目标文件的源码，基本上编译单元是单一源码文件加上其所含入的头文件。
	2. static对象是指其寿命持续时间为从其被构造出来到程序结束为止，static对象包括global对象、声明于namespace作用于内的对象、在classes内、函数内和file作用于内被生命为static的对象。
	3. 函数内的static对象被称为local static对象，其它static对象被称为non-local static对象。static对象的析构函数会在main()函数结束时被自动调用，即static对象会在程序结束时被自动销毁。
	4. C++对定义与不同编译单元内的non-local static对象的初始化次序没有明确的定义。那么如果某个编译单元内的non-local static对象的初始化操作使用了另一个编译单元内的某个non-local static对象，它所用到的这个对象可能还没有被初始化。
	5. 解决上述问题的办法是为每一个non-local static对象声明一个专属函数(此对象在专属函数中被生命为local static，且专属函数返回一个reference指向它所包含的对象)。
	6. C++规定，函数内的local static对象会在函数被调用，首次碰到该对象定义式时被初始化。如果以专属函数返回一个reference指向local static对象替换对non-local static对象的直接访问，就可以保证调用专属函数获得的reference指向的对象是初始化过的。此做法还有一个优势是，如果没有调用此专属函数，那么就不会产生构造和析构的成本。

# 5. 了解C++默默编写并调用了哪些函数
1. 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符和析构函数。
	1. 如果程序中没有声明，编译器会为类声明一组编译器版本的一个copy构造函数、一个copy assignment操作符(=)和一个析构函数，如果类中没有声明任何构造函数，编译器也会为类声明一个default构造函数。
	2. 编译器为类声明的函数只有在被调用时才会被创建出来。
	3. 编译器声明的析构函数是non-virtual析构函数，除非这个类的基类自身声明有virtual析构函数。
	4. 编译器生成的copy构造函数和copy assignment操作符只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象。对于int等内置类型的成员变量，拷贝过程是拷贝源对象成员变量的每一个bits。对于其他类型的成员变量，拷贝过程是调用类型的copy构造函数。
	5. C++规定让引用对象改指不同对象和修改const成员的内容都是不合法的，所以当类的成员变量中含有reference成员或者const成员的话，编译器不会为其自动生命copy assignment操作符。
	6. 如果基类将自己的copy assignment操作符声明为private，编译器会拒绝为其派生类生成copy assignment操作符。因为编译器为派生类所声明的copy assignment操作符在理想情况下是可以处理基类的成员部分的，当基类将自己的复制操作符声明为private时，派生类将失去这种能力。
	7. **当有新对象被定义，会调用copy 构造函数，当没有新对象被定义时，会调用copy assignment操作符**

# 6. 如果不想使用编译器自动生成的函数，应该明确拒绝。
1. 为了拒绝编译器自动提供的功能，可以将相应的成员函数声明为private并且不予实现。另外还可以在基类中将copy构造函数和copy assignment操作符声明为private，那么编译器将不会为这个基类的派生类自动声明copy构造函数和copy assignment操作符。
	1. 在具体的问题环境中，有的类对象不需要复制功能，也就不需要copy构造函数和copy assignment操作符。
	2. 通过编译器产出的函数都是public，为了阻止copy构造函数和copy assignment操作符被自动创建出来，可以在类中自行声明，为了阻止相应的函数被调用，可以将其声明为private。
	3. 类的成员函数和友元函数仍然可以调用private函数，所以将编译器会自动声明但不想被调用的函数声明为private且不予实现。这样如果在成员函数或者友元函数中调用这些函数，会产生一个连接错误(linkage error)。
	4. 为了阻止编译器自动生成函数还可以在基类中将copy构造函数和copy assignment操作符声明为private，那么编译器将不会为这个基类的派生类自动声明copy构造函数和copy assignment操作符。因为在这种情况下，如果试图复制一个派生类对象，编译器会试着生成一个copy构造函数和一个copy assignment操作符，但是因为基类的拷贝操作相应的函数为private，这样的操作不会成功。

# 7. 为多态基类生命virtual析构函数
1. 带多态性质的基类应该声明一个virtual析构函数，如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。
	1. 当派生类对象经由一个基类指针被删除，而该基类带有一个non-virtual析构函数，则结果未定义，实际执行过程中通常发生的是对象的派生成分没有被销毁。
	2. 析构函数的运作方式是，最深层派生类的析构函数最先被调用，然后时期每一个基类的析构函数被调用。
2. 类的设计如果不是作为基类使用，或者不是为了具备多态性质而设计，就不应该为其声明virtual函数。
	1. 析构函数会使类的对象体积增加。(指向虚函数表的指针)


# 8. 别让异常逃离析构函数
1. 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉到任何异常，然后吞下异常不传播或者结束程序。
2. 如果客户需要对某个操作函数运行时期抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数中)执行该操作。
	1. 如果某个操作可能在失败时候抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。

# 9. 绝不在构造和析构过程中调用virtual函数
1. 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类。

# 10. 令 operator= 返回一个reference to \*this
1. 令赋值操作符返回一个reference to \*this
	1. 为了实现连续赋值，赋值操作符必须返回一个reference指向操作符的左侧实参。
	2. 此协议适用于所有赋值相关运算，包括 =、+=、-=、\*=、\=。

# 11. 在 operator= 中处理自我赋值 
1. 确保对象自我赋值时operator= 有良好的行为。其中技术包括比较来源对象和目标对象的地址、精心周到的语句顺序和copy-and-swap。
	1. 

2. 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其运行仍然正确。

# 12. 复制对象时勿忘其每一个成分
1. 

# 13. 用对象管理资源
1. 为防止资源泄漏，应该使用RAII对象，这类对象在构造函数中获得资源并在析构函数中释放资源。
	1. RAII(Resource Acquisition Is Initialization/资源取得时机便是初始化时机)。
	2. 动态分配的内存可能因为中途语句抛出异常等情况而使delete或者delete[]语句得不到执行，造成内存泄漏。
	3. 很多资源被动态分配于堆中而后被用于单一区块或函数内，它们应该在控制流离开那个区块或者函数时被释放。所以将资源放进对象中，便可依赖C++的析构函数自动调用保证动态分配的资源被释放。
	4. RAII保证总是在获得一笔资源的同一语句内一它初始化某个管理对象。有时候获得的资源被拿来赋值某管理对象，上面这两种做法都可以让一笔资源在获得的同时被立刻放入管理对象中。**获得资源后立刻放进管理对象**
	5. 不论控制流如何离开区块，一旦对象被销毁其析构函数自然会被自动调用，于是资源被释放。**管理对象调用析构函数确保资源被释放**

2. 两个常被使用的RAII classes是tr1::shared_ptr和auto_ptr。前者的copy行为比较直观，auto_ptr复制动作会使其指向null。
	1. auto_ptr是个类指针(pointer-like)对象，其析构函数自动对其所指对象调用delete。
	2. 如果通过复制构造函数或者复制运算符复制auto_ptr，则复制所得的auto_ptr会得到资源的唯一拥有权，原auto_ptr会变成null。
	3. tr1::shared_ptr是一种RCSP(Reference-counting smart pointer/引用计数型指针)，由tr1::shared_ptr管理的对象可以有正常的复制操作，即允许多个tr1::shared_ptr指向同一个对象。
	4. auto_ptr和tr1::shared_ptr两者都在其析构函数内做delete而不是delete[]，这就意味着在动态分配的数组上使用auto_ptr或者tr1::shared_ptr会造成内存泄漏。


# 18. 让接口更容易被使用，不容易被误用
1. 好的接口很容易被正确使用，不容易被误用。
	1. 很多客户端错误(输入参数的类型、顺序或者是否为有效值)可以因为导入新类型而获得预防。
2. “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。
3. “阻止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。
4. 

# 22. 将成员变量声明为private
1. 将成员变量声明为private，这可以赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件得到保证，并提供class作者提供充分的弹性。
	1. 如果成员变量不是public，客户访问对象的唯一方法就是通过成员函数。如果public接口内的每样东西都是函数，那么客户就不需要在访问class成员时考虑是否需要加上小括号。
	2. 使用成员函数控制对成员变量的访问可以使对成员变量的处理有更精确的控制。
	3. 如果通过函数访问成员变量，日后可以改以某个计算替换这个成员变量，而class的用户不会察觉到class的内部实现发生了变化，这就实现了封装。
	4. 将成员变量隐藏在函数接口的背后，可以为所有可能的实现提供弹性。(可以使成员变量在被读或者被写时很容易通知到其他对象，可以验证class的约束条件和前提和事后状态，可以在多线程环境中执行同步控制等)。
2. protected并不比public更具封装性。
	1. 成员变量的封装性和与成员变量的内容改变时所破坏的代码量成反比。
	2. 对于一个public成员变量，如果最终取消了它，那么所有使用它的客户代码都会被破坏。对于一个protected成员变量，如果最终取消了它，那么所有使用它的子类都会被破坏。从封装的角度看，其实只有两种访问权限，提供封装的private和不提供封装的public和protected。

# 23. 宁以non-member函数、non-friend替换member函数
1. 宁可拿non-member函数、non-friend函数替换member函数，这样做可以增加封装性、包裹弹性和机能扩充性。
	1.

# 25. 考虑写出一个不抛出异常的swap函数
1. 当std::swap对具体类型的效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。
	1. 
2. 如果类中提供一个member swap，也应该提供一个non-member swap来调用前者。对于classes(而非 templates)，也应该特化std::swap。
	1. 
3. 调用swap是应针对std::swap使用using声明式，然后调用swap并且不带任何命名空间资格修饰。
4. 为“用户定义类型”进行std templates全特化是好的，但是千万不要尝试在std内加入某些对std而言全新的东西。

# 26. 尽可能延后变量定义式的出现时间
1. 尽可能延后变量定义式的出现，这样做可以增加程序的清晰度并改善程序效率。
	1. 如果程序中定义的变量带有一个构造函数或者析构函数，那么当程序的控制流达到这个变量的定义式时，便会产生构造成本，当控制流离开变量的作用域时，就会产生析构成本，这些成本与变量是否被使用无关。所以应该在真正需要一个变量时，再定义它。
	2. 尽可能延后变量定义式的出现时间不仅仅意味着延后到使用该变量的前一刻，甚至可以延后变量的定义式直到可以赋予它初值实参为止，这样的话不仅能够避免构造或者析构非必要对象，还可以避免没有意义的default构造行为。
	3. 对于循环体中的变量，变量的定义有两种方式，定义于循环外然后在每次循环迭代中赋值或者定义域循环内。对于定义于循环外的做法，整个循环过程的成本是1个构造函数+1个析构函数+n次赋值操作，对于定义于循环内的做法，整个循环过程的成本是n个构造函数和n个析构函数。所以，如果类的一次赋值成本低于一组构造+析构成本，应该将变量定义域循环外，否则应该将其定义于循环内。

# 27. 尽量减少类型转换操作
1. 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。
	1. C++ 中的类型转换语法有两种旧式转型 (T)expression/ T(expression)和新式转型
		1. const_cast
		```cpp
		const_cast<T> (expression)
		```
		2. dynamic_cast
		```cpp
		dynamic_cast<T>(expression)
		```
		3. reinterpret_cast
		```cpp
		reinterpret_cast<T>(expression)
		```
		4. static_cast
		```static_cast
		static_cast<T>(expression)
		```

2. 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进自己的代码内。

3. 宁可使用新式转型，也不要使用旧式转型。前者很容易辨识出来，而且不同转型之间功能区别度比较大。

# 28. 避免返回句柄指向对象内部部分
1. 
2. 

# 29. 为“异常安全”努力是值得的
1. 异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构损坏。这样的函数分三种可能的保证：基本型、强烈型、不抛异常型。
	1. 异常安全函数提供以下三个保证**之一**：
		1. **基本承诺**： 如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或者数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态。
		2. **强烈保证**： 如果异常被抛出，程序状态不改变。调用这样的函数需要这样的认知：如果函数成功，就是完全成功。如果函数失败，程序就会恢复到调用函数之前的状态。
		3. **不抛掷保证**： 承诺绝不抛出异常，
	2. 当异常被抛出时，带有异常安全性的函数会**不泄露任何资源**、**不允许数据败坏**。
2. “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或者具备现实意义。
	1. copy-and-swap 即为打算修改的对象原件做出一个副本，然后在副本上做一切必要的修改。若有任何修改动作抛出异常，原对象仍保持未改变的状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换。
	2. copy-and-swap 通常是将所有“隶属于对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的副本。
3. 函数提供的异常安全保证通常最高只等于其所调用的各个函数的异常安全性中的最弱者。


# 30. 透彻理解inlining的里里外外
1. 将大多数inlining限制在小型、被频繁调用的函数身上。这可以使日后的调试过程和二进制升级更容易，也可以使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。
	1. inline函数会使程序免去函数调用成本，并且编译器有能力对inline函数本体(不含函数调用)执行语境相关优化。但是程序对inline函数的每一次调用都用函数本体替换，这样会使得程序的目标码过大。
	2. 如果inline函数的本体很小，编译器对函数本体所产生的码可能比针对函数调用所产生的码更小。这种情况下将函数inlining确实可以导致更小的目标码和较高的指令告诉缓存装置集中率。
	3. inline函数一般被置于头文件中，因为大多数建置环境在编译过程中进行inlining，为了将一个函数调用替换为被调用的函数本体，编译器必须知道这个函数长得什么样子。
2. 不要因为function templates出现在头文件，就将它们声明为inline。
	1. templates通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长的什么样子。
	2. 大部分编译器会拒绝将太过复杂(比如带有循环或者递归)的函数inlining，同样对virtual函数的inlining也不太合适，因为virtual意味着“等待，知道运行时才确定调用哪个函数”，而inline意味着“执行前先将调用动作替换为被调用函数的本体”。
	3. inline函数无法随着程序库的升级而升级。如果f是程序库内的一个inline函数，客户将“f函数本体”编进其程序中，那么一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译。然而如果f是non-inline函数，一旦它有任何修改，客户端只需重新连接就好，远比重新编译的负担少很多。 

# 32. 确定public继承塑模出is-a关系
