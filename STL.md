# 1. STL的六大组件


# 2. STL常用的容器有哪些以及各自的底层实现和特点是什么?
1. **vector**:底层数据结构为**数组**，支持快速随机访问。
2. **list**:底层数据结构为**双向链表**，支持快速增删。
3. **deque**:底层数据结构为**一个中央控制器和多个缓冲区**，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问。
4. **stack**:底层一般用**list或者queue**实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时。
5. **queue**:底层一般用**list或者deque**实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
6. **priority_queue**:底层数据结构一般为**vector**，堆heap为处理规则来管理底层容器实现。
7. **set**:底层数据结构为**红黑树**，有序，不重复。
8. **multiset**:底层数据结构为**红黑树**，有序，可重复。 
9. **map**:底层数据结构为**红黑树**，有序，不重复。
10. **multimap**:底层数据结构为**红黑树**，有序，可重复。
11. **hash_set**:﻿﻿﻿﻿底层数据结构为**hash表**，无序，不重复。
12. **hash_multiset**:底层数据结构为**hash表**，无序，可重复 。
13. **hash_map**:﻿﻿﻿﻿底层数据结构为**hash表**，无序，不重复。
14. **hash_multimap**:底层数据结构为**hash表**，无序，可重复。

# 2. STL常用容器分别有什么特点，它们的的底层机制分别是什么？
## 2.1 **vector**
### 2.1.1 vector的底层机制
vector的底层数据结构是**动态数组**，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放，如果新值大于当前大小时会重新分配内存。
### 2.1.2 vector的特点
1. 拥有一段连续的内存空间，并且起始地址不变，因此能够非常好的支持随机存取，即[]操作符，但是由于它的内存空间是连续的，所以在头部和中间进行插入和删除操作会造成内存块的拷贝，另外，当该数组的内存空间不够时，需要重新申请一块足够大得内存并且进行内存的拷贝，这些都大大的影响了vector的效率。
2. 对头部和中间进行添加删除元素操作需要移动内存，如果你得元素是struct或者class，那么移动的同时还会进行构造和析构操作，所以性能不高。
3. 对任何元素的访问时间都是O(1)，所以常用来保存需要经常进行随机访问的内容，并且不需要经常对中间元素进行添加删除操作。
4. 属性与string差不多，同样可以使用capacity看当前保留的内存，使用swap来减少它使用的内存，如push_back 1000个元素，capacity返回值为16384。
5. 对最后元素操作最快（在后面添加删除元素最快），此时一般不需要移动内存，只有保留内存不够时才需要重新分配内存。

### 2.1.3 vector的使用要点
1. 需要经常随机访问且不用经常对中间元素删除插入时使用vector。
2. 如果元素是结构或类，最好是将结构或类的指针放入vector中，这样不仅能够节省空间，而且可以避免移动时构造和析构操作。
3. 删除元素时采用后面的元素覆盖前面的元素的方法可以提高效率。

### 2.1.4 vector的常用操作


## 2.2 **list**
### 2.2.1 list的底层机制
list的底层数据结构时**双向链表**，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供[]操作符的重载。但是由于链表的特点，它可以很有效率的支持任意地方的删除和插入操作。

### 2.2.2 list的特点
1. 没有空间预留习惯，所以每分配一个元素都会从内存中分配，每删除一个元素都会释放它占用的内存。
2. 在哪里添加删除元素性能都很高，不需要移动内存，当然也不需要对每个元素都进行构造与析构了，所以常用来做随机插入和删除操作容器。
3. 访问开始和最后两个元素最快，其他元素的访问时间都是O(n)。

### 2.2.3 list的使用要点
1. 如果经常进行添加和删除操作并且不经常随机访问的话，使用list。
2. list<指针>完全是性能最低的做法，还不如直接使用list<对象>或使用vector<指针>好，因为指针没有构造与析构，也不占用很大内存。

### 2.2.4 list的常用操作

## 2.3 **deque**
### 2.3.1 deque的底层机制
### 2.3.2 deque的特点
### 2.3.3 deque的使用要点
### 2.3.4 deque的常用操作

## 2.4 **stack**
### 2.4.1 stack的底层机制
### 2.4.2 stack的特点
### 2.4.3 stack的使用要点
### 2.4.4 stack的常用操作

## 2.5 **queue**
### 2.5.1 qeque的底层机制
### 2.5.2 qeque的特点
### 2.5.3 qeque的使用要点
### 2.5.4 qeque的常用操作

## 2.6 **heap**
### 2.6.1 heap的底层机制
### 2.6.2 heap的特点
### 2.6.3 heap的使用要点
### 2.6.4 heap的常用操作

## 2.7 **priority_queue**
### 2.7.1 priority_queue的底层机制
### 2.7.2 priority_queue的特点
### 2.7.3 priority_queue的使用要点
### 2.7.4 priority_queue的常用操作


## 2.8 **set**和**multiset**
### 2.8.1 set的底层机制
### 2.8.2 set的特点
### 2.8.3 set的使用要点
### 2.8.4 set的常用操作

## 2.9 **map**和**multimap**
### 2.9.1 map的底层机制
### 2.9.2 map的特点
### 2.9.3 map的使用要点
### 2.9.4 map的常用操作


## 2.10 **hash_set**和**hash_multiset**
### 2.10.1 hash_set的底层机制
### 2.10.2 hash_set的特点
### 2.10.3 hash_set的使用要点
### 2.10.4 hash_set的常用操作

## 2.11 **hash_map**和**hash_multimap**
### 2.11.1 hash_map的底层机制
### 2.11.2 hash_map的特点
### 2.11.3 hash_map的使用要点
### 2.11.4 hash_map的常用操作

# 3. 红黑树
## 3.1 红黑树的定义和特点
### 3.1.1 红黑树的定义
1. 红黑树是一种自平衡二叉查找树
2. 红黑树每个节点有5个属性，分别是color、key、left、right、parent。
3. 红黑树是一种特殊的二叉查找树，与一般二叉查找树不同的是，如果一个节点没有子节点或者父节点，在二叉查找树中其相应的指针就会指向空(NULL)，而红黑树中会用一个nil哨兵节点(哨兵节点nil是所有一个与普通节点有相同属性的对象。它的color属性为BLACK，而它的其他属性可以任意设置，一般时没有什么意义。)来取代，当一个节点的left、right或者parent为空时，其指针会指向nil节点。故红黑树中没有任何一个节点的left、right、parent指针会指向空。
4. 红黑树通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，红黑树可以保证没有一条路径会比其他路径长出2倍以上，所以称之为平衡。为了保持平衡，红黑树要满足以下五条性质：
    1. **每个节点不是红色就是黑色的。**
    2. **根结点是黑色的。**
    3. **每个叶节点(nil)是黑色的，实际上nil只有一个。**
    4. **如果一个节点是红色的，则它的两个子节点都是黑色的。**
    5. **对每个节点，从该节点到其所有后代叶结点的简单路径上，均包含相同数目的黑色节点。**

### 3.1.2 红黑树的左旋和右旋


#### 3.1.2.1 左旋
```cpp
//以x为支点进行左旋
void left_rotate(node* x) {
	if (x == nil_node) {
		return;
	}

	node* y = x->right;

	x->right = y->left; //让y的左节点接到x的右节点位置，这样能满足二叉搜索树的性质

	if (y->left != nil_node) { //这一句判断不能少
		y->left->parent = x; //让左节点的父指针指向x
	}

	y->parent = x->parent;

	if (x->parent == nil_node) { //x原本为根结点的情况
		this->root = y;
	} else if (x == x->parent->right) {
		y->parent->right = y;
	} else {
		y->parent->left = y;
	}
	//处理左节点
	y->left = x;
	x->parent = y;
}
```

#### 右旋

```cpp
//以x为支点进行右旋
void right_rotate(node* x) {
	if (x == nil_node) {
		return;
	}

	node* y = x->left;

	x->left = y->right;
	x->left->parent = x;

	y->parent = x->parent;

	if (x->parent == nil_node) { //x原本为根结点的情况
		this->root = y;
	} else if (x == x->parent->left) {
		y->parent->left = y;
	} else {
		y->parent->right = y;
	}

	y->right = x;
	x->parent = y;
}
```

# 3. vector插入删除和list有什么区别？
vector插入和删除数据，需要对现有数据进行复制移动，如果vector存储的对象很大或者构造函数很复杂，则开销较大，如果是简单的小数据，效率优于list。
list插入和删除数据，需要对现有数据进行遍历，但在首部插入数据，效率很高。

# 4. 顺序性容器vector、list和deque在工程中应该如何选择？
容器vector、list和deque的底层实现原理和特点如下：
1. vector是一种**动态数组**，在内存中具有连续的存储空间，支持快速随机访问。由于具有连续的存储空间，所以在插入和删除操作方面，效率比较慢。vector有多个构造函数，默认的构造函数是构造一个初始长度为0的内存空间，且分配的内存空间是以2的倍数动态增长的，即内存空间增长是按照2^0,2^1,2^2,2^3......增长的，在push_back()的过程中，若发现分配的内存空间不足，则重新分配一段连续的内存空间，其大小是现在连续空间的2倍，再将原先空间中的元素复制到新的空间中，性能消耗比较大，尤其是当元素是非内部数据时(非内部数据往往构造及拷贝构造函数比较复杂)。
2. list是一种**双向链表**，因此它的内存空间是可以不连续的，通过指针来进行数据的访问，这使list的随机存储变得非常低效，因此list没有提供[]操作符的重载。但list可以很好地支持任意位置的插入和删除，只需移动相应的指针即可。
3. deque和vector类似，支持快速随机访问。二者最大的区别在于，vector只能在末端插入数据，而deque支持双端插入数据。**deque的内存空间分布是小片的连续，小片间用链表相连**，实际上内部有一个map的指针。deque空间的重新分配要比vector快，重新分配空间后，原有的元素是不需要拷贝的。

所以在工程中对顺序型容器的选择应该遵从以下标准：
1. 如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector。
2. 如果需要大量的插入和删除，而不关心随机存取，则应使用list。
3. 如果需要随机存取，而且关心两端数据的插入和删除，则应使用deque。

# 5. vector的clear()操作会引起什么问题吗？该怎么应对？
**对vector的clear操作会引起内存泄漏。**
1. **原因** 对vector进行clear操作以后，其capacity(vector capacity: vector目前使用实际内存大小)大小并没有改变，也就是clear只是将vector的size置0，其占用的内存并没有被释放，这就产生了内存泄漏的问题。
2. **解决方法** clear不会改变vector容量，也不会引起内存的重新分配。C++标准建议强制内存重新分配应该使用：
```cpp
//C++标准建议
vector<T>().swap(x);
//实例
vector<int> V;
V.push_back(1); 
V.push_back(2);
V.push_back(1); 
V.push_back(2);
vector<int>().swap(V);
//通过一个临时的空vector与原来的V交换，临时对象占有原来V的内存，然后临时对象消失、原来V占有的内存被释放，现在V占有的是capacity=0的空间，即内存泄露问题得到解决。 
```

# 6. vector中begin和end函数返回的是什么？
begin返回的是第一个元素的迭代器，end返回的是最后一个元素后面位置的迭代器。

# 7. STL迭代器在什么情况下会失效？为什么？
**当使用一个容器的insert()或者erase()函数通过迭代器插入或删除元素可能会导致迭代器失效。**因此为了避免代码出错，应该获取insert()或者erase()返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作。
1. **vector** 对vector的insert或者erase操作可能引起其迭代器失效。vector底层依赖动态数组实现，故其内存分布连续。所以在vector大小增长的过程中，如果发现现有的已分配内存空间不足，会重新分配一段连续的内存空间，大小一般为现有的2倍，再将原空间的元素依次分配到新空间中去。所以对vector做insert操作时，假设insert位置在p，分两种情况：
	1. 容器还有空余空间，不重新分配内存，那么p之前的迭代器都有效，p之后的迭代器都失效。
	2. 容器重新分配了内存，那么所有迭代器都无效。

erase操作时，假设erase位置在p，则p之前的迭代器都有效并且p指向下一个元素位置(如果之前p在尾巴上，则p指向无效尾end)，p之后的迭代器都无效。

2. **list** insert操作和splice操作不会造成原有的list迭代器失效。list的erase操作也只有指向被删除元素的那个迭代器失效，其他迭代器不受影响。
3. **set**和**map** 与list相同，当对它进行insert和erase操作时，操作之前的所有迭代器，在操作完成之后都依然有效，但被删除的元素的迭代器失效。


# 8. vector、list和deque区别有哪些？？？
1. vector是单向开口的连续线性空间，deque是双向开口的连续线性空间。（双向开口是指可以在头尾两端分别做元素的插入和删除操作）。
2. deque没有提供空间保留功能，而vector则要提供空间保留功能。
3. deque也提供随机访问迭代器，但是其迭代器比vector迭代器复杂很多。

# 9. 不允许有遍历行为的容器有哪些（不提供迭代器）？
1. queue，除了头部外，没有其他方法存取qeque的其他元素。 
2. stack（底层以deque实现），除了最顶端外，没有任何其他方法可以存取stack的其他元素。
3. heap，所有元素都必须遵循特别的排序规则，不提供遍历功能。

# 10. STL容器的参数allocate是用来做什么的？
一般用在容器中，作为容器的一个成员，但一般是用模版参数传入，这样才可以让我们换成我们自定义的allocator；分配器用于封装STL容器在内存管理上的低层细节

# 11. 应该怎样理解迭代器？
Iterator(迭代器)用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，相当于智能指针。包括Input Iterator, Output Iterator, Forward Iterator, Bidirectional Iterator, Random Access Iterator。

# 12. vector每次insert或erase之后，以前保存的iterator会不会失效？
理论上会失效，理论上每次insert或者erase之后，所有的迭代器就重新计算的，所以都可以看作会失效，原则上是不能使用过期的内存
但是vector一般底层是用数组实现的，我们仔细考虑数组的特性，不难得出另一个结论，
insert时，假设insert位置在p，分两种情况：
1. 容器还有空余空间，不重新分配内存，那么p之前的迭代器都有效，p之后的迭代器都失效。
2. 容器重新分配了内存，那么所有迭代器都无效。
erase时，假设erase位置在p，则p之前的迭代器都有效并且p指向下一个元素位置（如果之前p在尾巴上，则p指向无效尾end），p之后的迭代器都无效。

# 13. STL对于小内存块请求与释放的处理是什么样的？
STL考虑到小型内存区块的碎片问题，设计了双层级配置器，第一级配置直接使用malloc()和free()；第二级配置器则视情况采用不同的策略，当配置区大于128bytes时，直接调用第一级配置器；当配置区块小于128bytes时，便不借助第一级配置器，而使用一个memory pool来实现。究竟是使用第一级配置器还是第二级配置器，由一个宏定义来控制。SGI STL中默认使用第二级配置器。
二级配置器会将任何小额区块的内存需求量上调至8的倍数，(例如需求是30bytes,则自动调整为32bytes)，并且在它内部会维护16个free-list， 各自管理大小分别为8， 16， 24，…，128bytes的小额区块，这样当有小额内存配置需求时，直接从对应的free list中拔出对应大小的内存(8的倍数)；当客户端归还内存时，将根据归还内存块的大小，将需要归还的内存插入到对应free list的最顶端。
小结：
STL中的内存分配器实际上是基于空闲列表(free list)的分配策略，最主要的特点是通过组织16个空闲列表，对小对象的分配做了优化。
1. 小对象的快速分配和释放。当一次性预先分配好一块固定大小的内存池后，对小于128字节的小块内存分配和释放的操作只是一些基本的指针操作，相比于直接调用malloc/free，开销小。
2. 避免内存碎片的产生。零乱的内存碎片不仅会浪费内存空间，而且会给OS的内存管理造成压力。
3. 尽可能最大化内存的利用率。当内存池尚有的空闲区域不足以分配所需的大小时，分配算法会将其链入到对应的空闲列表中，然后会尝试从空闲列表中寻找是否有合适大小的区域，但是，这种内存分配器局限于STL容器中使用，并不适合一个通用的内存分配。因为它要求在释放一个内存块时，必须提供这个内存块的大小，以便确定回收到哪个free list中，而STL容器是知道它所需分配的对象大小的，比如上述：
stl::vector array;
array是知道它需要分配的对象大小为sizeof(int)。一个通用的内存分配器是不需要知道待释放内存的大小的，类似于free(p)。

 

# 14. vector和list的区别
1. vector和数组类似，拥有连续的内存空间，支持随机的存取，在中间进行元素的插入和删除的操作时间复杂度是O(n)。
2. list是由双向链表实现的，只能通过数组指针来进行数据访问，遍历中间的元素，时间的复杂度是O(n)。

# 15. vector中erase方法与algorithm中的remove方法的区别？
vector中erase方法真正删除了元素，迭代器不能访问了。
remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为algorithm通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除。

 

十八、STL中的容器都有哪些，优缺点？
介绍一下STL，详细说明STL如何实现vector。

STL(标准模板库)可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。
STL (标准模版库，Standard Template Library.它由容器、算法、迭代器组成。
STL有以下的一些优点：
可以方便容易地实现搜索数据或对数据排序等一系列的算法；
调试程序时更加安全和方便；
即使是人们用STL在UNIX平台下写的代码你也可以很容易地理解（因为STL是跨平台的）。
vector实质上就是一个动态数组，会根据数据的增加,动态的增加数组空间。
deque从逻辑上来看是连续的内存，本质上是由一段段固定大小 的连续空间组成。deque采用类似索引的结构管理内存。vector有capacity和reserve函数，deque和list一样，没有capacity和reserve函数。

总结如下： 
1. 在deque中间 插入或者删除将使所有deque元素的迭代器、引用、指针失效 
2. 在deque首部或者尾部插入元素会使迭代器失效，但不会引起引用和指针失效 
3. 在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效

vector模板的数据在内存中连续的排列，所以随机存取元素（即通过[]运算符存取）的速度最快，这一点和数组是一致的。同样由于它的连续排列，所以它在除尾部以外的位置删除或添加元素的速度很慢，在使用vector时，要避免这种操作。
list模板的数据是链式存储，所以不能随机存取元素。它的优势在于任意位置添加 删除元素的速度。
deque模板是通过链接若干片连续的数据实现的，所以均衡了以上两个容器的特点

 

# 19. 说说std::deque的底层机制。
deque动态地以分段连续空间组合而成，随时可以增加一段新的连续空间并链接起来，不提供空间保留功能。<br>
除非必要，否则应该尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。对deque排序，为了提高效率，可先将deque复制到一个vector上排序，然后再复制回deque。<br>
deque采用一块map（不是STL的map容器）作为主控，其为一小块连续空间，其中每个元素都是指针，指向另一段较大的连续空间（缓冲区）。
deque的迭代器包含4个内容：
1. cur：迭代器当前所指元素
2. first：此迭代器所指的缓冲区的头。
3. last：缓冲区尾。
4. node：指向管控中心。

 

# 20.  说说std::map底层机制。
map以RB-TREE为底层机制。RB-TREE是一种平衡二叉搜索树，自动排序效果不错。
通过map的迭代器不能修改其键值，只能修改其实值。所以map的迭代器既不是const也不是mutable。

 

# 21. 红黑树有什么性质？
1. 每个结点是红色或者黑色。
2. 根结点为黑色。
3. 叶结点为黑色的NULL结点。
4. 如果结点为红，其子节点必须为黑。
5. 任一结点到NULL的任何路径，所含黑结点数必须相同。

 

二十二、vector、list、map、deque用erase（it）后，迭代器的变化。

vector和deque是序列式容器，其内存分别是连续空间和分段连续空间，删除迭代器it后，其后面的迭代器都失效了，此时it及其后面的迭代器会自动加1，使it指向被删除元素的下一个元素。

list删除迭代器it时，其后面的迭代器都不会失效，将前面和后面连接起来即可。

map也是只能使当前删除的迭代器失效，其后面的迭代器依然有效。

 

二十三、hash_map与map的区别？什么时候用hash_map，什么时候用map？

构造函数：hash_map需要hash function和等于函数，而map需要比较函数（大于或小于）。

存储结构：hash_map以hashtable为底层，而map以RB-TREE为底层。 

总的说来，hash_map查找速度比map快，而且查找速度基本和数据量大小无关，属于常数级别。而map的查找速度是logn级别。但不一定常数就比log小，而且hash_map还有hash function耗时。

如果考虑效率，特别当元素达到一定数量级时，用hash_map。

考虑内存，或者元素数量较少时，用map。

 

二十四、hashtable，hash_set，hash_map的区别。

hash_set以hashtable为底层，不具有排序功能，能快速查找。其键值就是实值。（set以RB-TREE为底层，具有排序功能。）

hash_map以以hashtable为底层，没有自动排序功能，能快速查找，每一个元素同时拥有一个实值和键值。（map以RB-TREE为底层，具有排序功能。）

 

二十五、map和set的3个问题。

1）为何map和set的插入删除效率比其他序列容器高。

因为不需要内存拷贝和内存移动

2）为何map和set每次Insert之后，以前保存的iterator不会失效？

因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

2）当数据元素增多时（从10000到20000），map的set的查找速度会怎样变化？

RB-TREE用二分查找法，时间复杂度为logn，所以从10000增到20000时，查找次数从log10000=14次到log20000=15次，多了1次而已。

 

二十六、map是怎么实现的？查找的复杂度是多少？能不能边遍历边插入？

红黑树和散列

O(logn)

不可以，map不像vector，它在对容器执行erase操作后不会返回后一个元素的迭代器，所以不能遍历地往后删除。

 

二十七、hash_map和map的区别在哪里？

hash_map底层是散列的所以理论上操作的平均复杂度是常数时间，map底层是红黑树，理论上平均复杂度是O(logn)，这里总结一下，选用map还是hash_map，关键是看关键字查询操作次数，以及你所需要保证的是查询总体时间还是单个查询的时间。如果是要很多次操作，要求其整体效率，那么使用hash_map，平均处理时间短。如果是少数次的操作，使用 hash_map可能造成不确定的O(N)，那么使用平均处理时间相对较慢、单次处理时间恒定的map，考虑整体稳定性应该要高于整体效率，因为前提在操作次数较少。如果在一次流程中，使用hash_map的少数操作产生一个最坏情况O(N)，那么hash_map的优势也因此丧尽了。

 

二十八、为何map和set不能像vector一样有个reserve函数来预分配数据？

map和set内部存储的已经不是元素本身了，而是包含元素的节点。也就是说map内部使用的Alloc并不是map声明的时候从参数中传入的Alloc。例如：
map, Alloc > intmap;
这时候在intmap中使用的allocator并不是Alloc, 而是通过了转换的Alloc，具体转换的方法时在内部通过
Alloc::rebind重新定义了新的节点分配器，详细的实现参看彻底学习STL中的Allocator。
其实你就记住一点，在map和set里面的分配器已经发生了变化，reserve方法你就不要奢望了。
