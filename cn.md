# 1. 物理层
## 1.1 

# 2. 数据链路层
## 2.1

# 3. 网络层
## 3.1 IP地址和MAC地址有什么区别？
**IP地址**是指互联网协议地址（Internet Protocol Address），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。<br>
**MAC地址**又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家烧入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。
1. **是否可更改**。对于网络上的某一设备，如一台计算机或一台路由器，其IP地址是基于网络拓扑设计出的，同一台设备或计算机上，改动IP地址是很容易的（但必须唯一），而MAC则是生产厂商烧录好的，一般不能改动。我们可以根据需要给一台主机指定任意的IP地址，如我们可以给局域网上的某台计算机分配IP地址为192.168.0.112 ，也可以将它改成192.168.0.200。而任一网络设备（如网卡，路由器）一旦生产出来以后，其MAC地址不可由本地连接内的配置进行修改。如果一个计算机的网卡坏了，在更换网卡之后，该计算机的MAC地址就变了。 
2. **长度不同**。IP地址为32位，MAC地址为48位。 
3. **分配依据不同**。IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商。 
4. **寻址协议层不同**。IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。 数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）。

## 3.2 有了IP地址，为什么还需要MAC地址？
1.
2.
3.
4. DHCP动态地址解析协议分配IP地址时，当DHCP服务器收到未分配IP地址的计算机发出的广播包，会从报文中解析出该计算机的MAC地址，此时只有这个MAC地址唯一，DHCP Server才能正确配置IP地址。

## 3.2 DHCP(Dynamic Host Configuration Protocol 动态地址解析协议)是怎么工作的？
DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数，简单来说，就是在DHCP服务器上有一个数据库，存放着IP地址、网关、DNS等参数。当客户端请求使用时，服务器则负责将相应的参数分配给客户端，以避免客户端手动指定IP地址等。特别是在一些大规模的网络中。客户端数目较多，使用DHCP可以方便对这些机器进行管理，为客户机提供TCP/IP参数配置，如IP地址、网关地址和DNS服务器等，不仅效率高，而且不存在IP地址冲突的情况。现在的无线路由器默认都带有DHCP功能，也就是说一个无线路由器同时也是一个DHCP服务器。

1. **DHCP DISCOVER: 寻找服务器**  当DHCP客户端第一次登录网络的时候或者是开机时，此计算机发现本机上没有任何IP地址设定，就会向网络广播去寻找DHCP服务器。该数据包的来源地址会为0.0.0.0，而目的地址则为255.255.255.255。
2. **DHCP OFFER: 分配IP地址**  当无线设备监听到客户端发出的寻找服务器的数据包后，它会从那些还没有分配出的IP地址里，选择最前面的的空闲IP，给客户端一个分配IP地址，但这里仅仅是分配，客户端还没有真正应用上。
3. **DHCP REQUEST: 请求使用**  客户端收到无线设备发送回来的分配IP地址数据包，客户端会向网络发送一个ARP数据包，确认网络中没有其他机器使用该IP地址，如果已经有，则重复发送步骤1中的动作;如果没有，则接受该IP地址，并发送一个Dhcprequest数据包给无线路由器，也就是DHCP服务器，请求使用此地址。
4. **DHCP ACK: IP地址分配确认**  当无线设备接收到客户端的Dhcprequest数据包之后，会向客户端发出一个DHCPACK回应，以确认IP地址的正式生效，也就结束了一个完整的DHCP工作过程。<br>

当此过程完成之后，DHCP客户端再重新登录网络时，就不需要再发送DHCP discover发现信息了，而是直接发送包含前一次所分配的IP地址的DHCP request请求信息。当DHCP服务器收到这一信息后，它会尝试让DHCP客户机继续使用原来的IP地址，并回答一个DHCP ack确认信息。如果此IP地址已无法再分配给原来的DHCP客户机使用时，则DHCP服务器给DHCP客户机回答一个DHCP nack否认信息。当原来的DHCP客户机收到此DHCP nack否认信息后，它就必须重新发送DHCP discover发现信息来请求新的IP地址。<br>
但DHCP服务器向DHCP客户机出租的IP地址一般都有一个租借期限，期满后DHCP服务器便会收回出租的IP地址。如果DHCP客户机要延长其IP租约，则必须更新其IP租约。DHCP客户机启动时和IP租约期限过一半时，DHCP客户机都会自动向DHCP服务器发送更新其IP租约的信息。

## 3.2 ARP(Address Resolution Protocol 地址解析协议)是怎么工作的？
1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示本局域网上IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4. 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，则表示ARP查询失败。
5. 广播发送ARP请求，单播发送ARP响应。

## 3.3 IP数据报的格式是怎么样的？
IP数据报由首部和数据两部分组成。<br>
IP数据报首部的固定部分中的各字段：<br>
1. **版本**    	  占4位，指IP协议的版本。
2. **首部长度**	  占4位，表示首部长度为其值\*32bit，因为IP首部固定长度为20字节，故此首部长度字段的最小值是5。
3. **区分服务**	  占8位。
4. **总长度**	  占16位，单位为字节，值首部和数据之和的长度。
5. **标识**  占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但是这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被赋值到所有数据报片的表示字段中。相同的表示字段的值使分片后的各数据报片最后能够正确地重装成为原来的数据报。
6. **标志** 占3位
	1. 标志字段中最低为记为MF(More Fragment)。 MF=1即表示后面还有分片的数据报，MF=0表示这已是若干数据报片的最后一个。
	2. 标志字段中间的一位记为DF(Don't Fragment)，意思是不能分片，只有当DF=0时才允许分片。
7. **片偏移** 占13位， 片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。片偏移以8个字节为偏移单位。
8. **生存时间** 占8位， TTL(Time To Live), TTL字段功能为“跳数限制”，路由器在每次转发数据报之前就把TTL值减一，若TTL值减小到零，则丢弃这个数据报，不再转发。
9. **协议**  占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道将数据部分上交给哪个协议进行处理。
10. **首部检验和** 占16位。 
11. **源地址** 占32位。
12. **目的地址** 占32位。

## 3.5 ICMP(Internet Control Messages Protocol 网际控制报文协议)的作用和工作方式？ ICMP有什么具体的应用？ 
### 3.5.1 ICMP是什么？它有什么作用？是哪一层的协议？
ICMP(Internet Control Messages Protocol)网际控制报文协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP是网络层协议，ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发出去。

### 3.5.2 ICMP报文有哪几种？都是什么格式？
ICMP报文有两种，即ICMP差错报告报文和ICMP询问报文。
1. 常用的ICMP差错报告报文的类型有终点不可达、超时、参数问题和改变路由等。
	1. **终点不可达** 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。
	2. **超时**  当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预定时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片全部丢弃，并向源点发送时间超过报文。
	3. **参数问题** 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。
	4. **改变路由(重定向)** 路由器把改变路由报文发送给主机，让主机知道下次应该将数据报发送给另外的路由器。
2. 常用的ICMP询问报文的类型有回送(Echo)请求或回答(ECHO REQUEST/ECHO REPLY)、和时间戳(TimesStamp)请求或回答。
	1. **回送请求与回答**  ICMP回送请求报文(ECHO REQUEST)是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文(ECHO REPLY)，这种询问报文用来测试目的站是否可达以及了解其有关状态。
	2. **时间戳请求和回答**  ICMP时间戳请求报文是请某台主机或路由器回答当前的日期和时间，在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。

ICMP报文的前4个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的4个字节内容与ICMP的类型有关，最后面是数据字段，其长度取决于ICMP的类型。<br>
1. ICMP的代码字段是为了进一步区分某种类型中的几种不同情况。检验和字段用来检验整个ICMP报文，IP数据报首部检验和并不检验IP数据报的内容，因此不能保证经过传输的ICMP报文不产生差错。
2. 所有的ICMP差错报告报文中的数据字段都具有相同的格式。把收到的需要进行差错报告的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段，再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP的差错报告报文。提取收到的数据报的数据字段的前8个字节是为了得到运输层的端口号(对于TCP和UDP)以及运输层报文的发送序号(对于TCP)，这些信息对源点通知高层协议是有用的，整个ICMP报文作为IP数据报的数据字段发送给源点。


### 3.5.3 ICMP的应用
#### 3.5.3.1 ping
##### 3.5.3.1.1 ping同网段(IP地址和子网掩码相与得到相同的网络地址)的ip
1. 同一网段的主机A要去ping主机B，A会封装两层报文，A会先查询自己ARP映射表，如果其中没有B的MAC地址，就会向外发送一个ARP广播包。
2. 交换机收到这个ARP广播包后，会检查在交换机中是否包含B的MAC地址，如果有就直接返回给A；如果没有就向所有端口发送ARP，该网段的主机的MAC如果与B的MAC地址不同就丢弃，如果主机B收到了该ARP就马上返回相同格式的ARP。
3. 这时主机A已经有了B的MAC地址，就把B的MAC地址封装到ICMP报中，向主机B发送一个回显请求(ECHO REQUEST)。
4. 主机B收到该报文后，知道是主机A的一个回显请求，就会返回一个相同格式的报文(ECHO REPLY)，这样就完成了同一个网段的ping的过程。

##### 3.5.3.1.2 跨网段ping某个域名
**获取域名对应的IP地址**--->**获取本网络一个路由的MAC地址**--->**发送和接收ICMP报文**

1. 主机查找本地系统Hosts文件的DNS缓存，如果存在该域名对应的IP，则获取IP，跳转到第8步；如果不存在，则继续。
2. 主机向本网络路由器发起请求，查找路由DNS缓存，如果存在该域名对于的IP，则获取IP，跳转到第8步；如果不存在，则继续。
3. 路由器向本地域名服务器(local name server)发起请求，查找DNS服务器的缓存，如果存在该域名对应的IP，则跳转到第7步；如果不存在，则继续。
4. 本地域名服务器向根域名服务器发起请求，根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器的IP地址。
5. 本地域名服务器向顶级域名服务器进行查询，顶级域名服务器告诉本地域名服务器，下一步应查询的权限服务器的IP地址。
6. 本地域名服务器向权限域名服务器进行查询，权限域名服务器告诉本地域名服务器，所查询的主机的IP地址。 
7. 本地域名服务器最后把查询结果——该域名对应的IP地址告诉给主机。
8. 至此，主机知道了该域名的IP地址。

9. 主机通过子网掩码判断该IP地址是本网段还是跨网段。
10. 主机先查看本地ARP高速缓存，查看表中是否有本网络路由器（网关）的MAC地址，如果有，则获取MAC地址，跳转到第12步；如果没有，则继续。
11. 主机使用ARP解析协议获取到本网段路由的MAC地址。
12. 至此，主机知道本网络一个路由的MAC地址。

13. 主机将ICMP报文封装成IP数据报，IP数据报的源地址为主机的IP地址，目的地址是域名对应的IP地址；
14. 主机将IP数据报封装成MAC帧，MAC帧的源地址为主机的MAC地址，目的地址是路由器的MAC地址；
15. 路由器接收到ICMP报文之后，发现MAC帧的目的地址是自己，IP地址是主机想要访问的IP地址，则将MAC帧的源地址改为自己的MAC地址，目的地址改为本网段另一个路由的MAC地址（也要通过ARP协议获取），转发下去...
16. 直到最后一个路由根据ARP协议，找到了主机想要访问的IP地址对应的主机的MAC地址，然后将ICMP报文封装成MAC帧发送给该域名主机。
17. 由于ARP协议具有相互学习性，域名主机接收到主机发送的ICMP回送请求报文之后，将向本网络路由发送ICMP回送回答报文，该路由又会转发下去...
18. 当主机收到域名主机发送的ICMP回送回答报文之后，这样就表明该主机到域名主机是连通可达的。

#### 3.5.3.2 tracert(Windows)/traceroute(UNIX)
**tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。**<br>
1. tracert送出一个TTL是1的IP 数据包到目的地，当路径上的第一个路由器收到这个数据包时，它将TTL减1。此时，TTL变为0，所以该路由器会将此数据包丢掉，并送回一个「ICMP time exceeded」消息(包括发IP包的源地址，IP包的所有内容及路由器的IP地址)。
2. tracert收到这个消息后，便知道这个路由器存在于这个路径上，接着tracert 再送出另一个TTL是2 的数据包，发现第2 个路由器...... tracert 每次将送出的数据包的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个数据包 抵达目的地。
3. 当数据包到达目的地后，该主机则不会送回ICMP time exceeded消息，一旦到达目的地，由于tracert通过UDP数据包向不常见端口(30000以上)发送数据包，因此会收到「ICMP port unreachable」消息，故可判断到达目的地。

## 3.6 路由选择协议
### 3.6.1 路由选择协议的核心就是路由算法，一个理想的路由算法应该有哪些特点？
1. 算法必须正确和完整。
2. 算法在计算上应该简单。
3. 算法应该能适应通信量和网络拓扑的变化。
4. 算法应该具有稳定性。
5. 算法应该是公平的。
6. 算法应该是最佳的。

### 3.6.2 静态路由算法和动态路由算法各有什么特点？它们有什么区别？
1. 静态路由算法和动态路由算法以算法能否随着网络的通信量或拓扑自适应地进行调整变化来划分。
2. 静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。对于很简答的小网络，完全可以选择静态路由算法，用人工配置每一条路由。
3. 动态路由选择也叫做自适应路由选择，其特点是能较好地适应网络状态的变化，但是实现起来较为复杂，开销也比较大。因此，动态路由选择适用于比较复杂的网络。

### 3.6.3 为什么要选择分层的路由选择协议？
1. 互联网的规模非常大。如果让所有路由器知道所有的网络该怎么到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。
2. 许多单位不愿意让外界了解自己单位网络的布局细节和本部门所采用的路由选择协议。但同时还希望连接到互联网上。<br>
为此，可以把整个互联网划分为许多较小的自治系统(Autonomous System/AS)，自治系统AS是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量，一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。

### 3.6.4 内部网关协议
#### 3.6.4.1 RIP(Routing Information Protocol/路由信息选择协议)

#### 3.6.4.2 OSPF(Open Shortest Path First/开放最短路径优先)

### 3.6.5 外部网关协议
#### 3.6.5.1 BGP(Border Gateway Protocol/边界网关协议)

## 3.7 桥接和路由
### 3.7.1 什么是桥接？什么是交换？什么是路由？它们之间有什么区别？
#### 3.7.1.1 桥接
1. 桥接工作在OSI网络参考模型的第二层数据链路层，是一种以MAC地址来作为判断依据来将网络划分成两个不同物理段的技术。
2. 桥接的工作机制是将物理网络段（也就是常说的冲突域）进行分隔，根据MAC地址来判断连接两个物理网段的计算机的数据包发送。

#### 3.7.1.2 交换
1. 交换同样工作在OSI网络参考模型的第二层数据链路层，也是一种以MAC地址来作为判断依据来将网络划分成两个不同段的技术，不同的是交换将物理网段划分到每一个端口当中，简单的理解就是一种多端口的网桥，它实际上是一种桥接技术的延伸。

#### 3.7.1.3 路由
1. 路由工作在OSI参考模型的第三层网络层当中，它是基于第三层的IP地址信息来作为判断依据来将网络划分成不同段（IP子网）的技术。
2. 与桥接和交换不同，路由划分的是独立的逻辑网段，每个所连接的网段都具有独立的网络IP地址信息，而不是以MAC地址作为判断路径的依据，这样路由便有隔离广播的能力；而交换和桥接是划分物理网段，它们仅仅是将物理传输介质进行分段处理。同时路由具备路径选择的功能，会根据不同的目的IP地址来分析到达目的地最合适的路径。 

#### 3.7.1.4 桥接、交换和路由之间的区别？
1. **位于参考模型的层数不同**  在OSI(开放系统互联参考模型)当中，网桥和交换机都是位于参考模型的第二层-数据链路层，而路由器则位于更高一层-网络层。
2. **基于的路径判断条件不同**  由于位于OSI参考模型的层数不同，所以使交换机、网关这两种设备判断路径的条件也不相同，网桥和交换机是根据端口的MAC地址来判断数据包转发，而路由器则使用IP地址来进行判断。
3. **控制广播的能力不同**  网桥和交换机（三层交换机或支持VLAN功能的除外）这两种设备是无法控制网络的广播，如果有广播数据包，就会向所有的端口转发，所以在大的网络环境当中，必须得要有路由器来控制网络广播。
4. **智能化程度不同**  在判断数据的时候，网桥只能判断是否在同一个物理网段，交换机则可以判断数据包是属于那个端口，但是这两种设备都没有选择最优路径的能力，而路由器基于IP地址判断路径，所以会根据IP地址信息来判断到达目的地的最优路径。

### 3.7.2 什么是冲突域？什么是广播域？
#### 3.7.2.1 冲突域
1. **冲突域是连接在同一导线上的所有工作站的集合**，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。
2. 冲突域代表了冲突在其中发生并传播的区域，这个区域可以被认为是共享段。在OSI模型中，冲突域被看作是第一层的概念，连接同一冲突域的设备有Hub(集线器)，Reperter(中继器)或者其他进行简单复制信号的设备。也就是说，用Hub或者Repeater连接的所有节点可以被认为是在同一个冲突域内，它不会划分冲突域。而第二层设备（网桥，交换机）第三层设备（路由器）都可以划分冲突域的，当然也可以连接不同的冲突域。简单的说，可以将Repeater等看成是一根电缆，而将网桥等看成是一束电缆。

#### 3.7.2.2 广播域
1. **广播域是指接收同样广播消息的节点的集合。**
2. 在该集合中的任何一个节点传输一个广播帧，则所有其他能收到这个帧的节点都被认为是该广播域的一部分。由于许多设备都极易产生广播，所以如果不维护，就会消耗大量的带宽，降低网络的效率。
3. 由于广播域被认为是OSI中的第二层概念，所以像集线器，交换机等第一，第二层设备连接的节点被认为都是在同一个广播域。而路由器，第三层交换机则可以划分广播域，即可以连接不同的广播域。

### 3.7.3 为什么要有桥接和路由的区分？
1. **分割广播域，控制流量** 
	1. 桥接无法控制广播在不同物理接口之间的穿梭，广播域(物理接口)多，连接的主机多，广播报文多，广播嘈杂，对主机的干扰程度很严重。
	2. 同一桥接下的主机，可以自由通信，桥对这些通信之间没有任何控制，即没有办法过滤掉某些主机与另外一些主机之间的通信。
	3. 而路由功能，可以将某些主机放在一个广播域，将另外一些主机放在另外的广播域。这样分割开来的广播域间的通信必须流经路由器，路由器就可以对这些流量进行控制。
2. **不同类型的物理接口，不能使用桥接，只能路由**
	1. 以太网接口与其它串行接口是不可能通过桥接将它们连接起来的，它们的二层封装方式不一样。一个是Ethernet封装，另外的可能是PPP/HDLC封装。

### 3.7.4 路由器和交换机有什么区别？
1. **工作层次不同** OSI模型中，交换机工作在链路层(工作原理比较简单)，路由器工作在网络层(得到更多的协议支持，可以做更多理智的决策)。
2. **数据转发所依据的对象不同**  交换机利用MAC地址来确定转发数据的目的地址，
路由器则是利用IP地址来确定数据转发的地址。
3. 传统的交换机：只能够分割冲突域，不能分割广播域；由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会  导致通讯拥塞以及产生漏洞。
路由器：可以分割广播域。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播之间是不能够通讯交流的，他们之间的交流仍然需要路由器。
4. **交换机负责同一网段的通信，路由器负责不同网段的通信**，
路由器提供了防火墙的服务，它仅仅转发特定地址的数据包，不传送不支持路由协议的数据包，也不传送未知目标网络数据包，从而可以防止广播风暴。

# 4. 运输层
## 4.1 

## 4.2 UDP(User Datagram Protocol/用户数据报协议)
### 4.2.1 UDP有什么特点？
用户数据报协议UDP是在IP数据报服务至上增加了复用、分用和差错检测的功能。UDP的主要特点有：<br>
1. UDP是无连接的，即发送数据前不需要建立连接，发送结束时也没有连接可释放，因此减少了开销和发送数据之间的时延。
2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态。
3. UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。
4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。
5. UDP支持一对一、一对多、多对一和多对多的交互通信。
6. UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

## 4.3 TCP(Transmission Control Protocol/传输控制协议)
### 4.3.1 TCP有什么特点？
1. TCP是面向连接的运输层协议。
2. 每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点(一对一)的。
3. TCP提供可靠交付的服务。通过TCP连接传输的数据，无差错、不丢失、不重复，并且按序到达。
4. TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来存放双向通信的数据。
5. TCP面向字节流。

### 4.3.2 TCP可靠传输的工作原理是什么？
#### 4.3.2.1 停止等待协议(stop-and-wait)/ARQ(Automatic Repeat reQuest/自动重传请求)
1. “停止等待”就是每发完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。
2. 发送方在等待超过超时计时器设置的时间后仍没有收到确认信息后，会认为刚才发送的分组丢失了，因而会重传前面发送过的分组，这是**超时重传**
	1. 发送方在发送完一个分组后，必须暂时保留已发送的分组的副本，只有在收到相应的确认后才能清除暂时保留的分组副本。
	2. 分组和确认分组都必须进行编号。
	3. 超时计时器设置的重传时间应该比数据在分组传输的平均往返时间更长一些。
3. 对于“确认丢失”，发送方在超时计时器到期后会重传上一个分组，接收方收到重传的分组后会丢弃这个分组并且向发送方发送确认消息，发送方收到确认消息后正常工作。
4. 对于“确认迟到”，发送方在超时计时器到期后会重传上一个分组，接收方收到重传的分组后会丢弃这个分组并且向发送方发送确认消息，发送方收到确认消息后正常工作，对于重复收到的确认消息什么也不做。
5. 为了改善停止等待协议信道利用率过低的缺点，可以采用流水线传输，即发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待确认消息。

#### 4.3.2.2 连续ARQ协议
1. 发送窗口。
2. 累积确认。


### 4.3.3 TCP可靠传输如何实现？
#### 4.3.3.1 TCP如何保证传输的可靠性？
1. **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
2. **对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
3. **丢弃重复数据**：对于重复数据，能够丢弃重复数据；
4. **应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
5. **超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
6. **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

#### 4.3.3.2 超时重传时间该怎么选择？
如果把超时重传时间设置的太短，就会引起许多报文段不必要的重传，是网络负荷增大。但如果把超时重传时间设置的过场，则又使网络的空闲时间增大，降低了传输效率。<br>
1. 
2. 计算加权平均RTTS时，只要报文段重传了，就不采用其往返时间样本。

### 4.3.4 TCP如何进行流量控制？
1. 如果发送方把数据发送的过快，接收方可能来不及接收，这样会造成数据的损失。流量控制(flow control)就是为了避免这种情况，让发送方的发送速率不要太快，要让接收方来得及接收。
2. TCP利用滑动窗口机制实现对发送方的流量控制。
3. 当TCP连接建立时，接收方会告诉发送方其接收窗口的大小(单位为字节)，发送方的发送窗口不能超过接收方给出的接受窗口的数值。
4. 发送方会根据接收方发送的ACK=1有效的报文段中的接收窗口值大小调整自己的发送窗口大小。
5. 接收端发送零窗口报文段会使发送方暂停发送。
6. TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），而对方就在确认这个探测报文段时给出现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计数器。如果窗口不是零，那么死锁的僵局就打破了。

### 4.3.5 TCP的拥塞控制

#### 4.3.5.1 为什么需要拥塞控制？
1. 在计算机网络中的链路容量(带宽)、交换节点中的缓存和处理机等，都是网络资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。
2. 网络拥塞往往是由许多因素引起的，单纯地增加一种网络资源，不但不能解决拥塞问题，而且还可能使网络的性能更坏。例如，当某个结点缓存的容量太小时，到达该节点的分组因存储空间而不得不被丢弃。现在设想将该节点缓存的容量扩展到非常大，于是凡到达该节点的分组均可在节点的缓存队列中排队，不受任何限制。由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数分组的排队等待时间将会大大增加，结果上层软件只好因为超时把它们进行重传，由此可见，简单地改善一种网络资源并不会解决网络拥塞的问题，拥塞控制是一个全局性的过程。
3. 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

#### 4.3.5.2 TCP如何进行拥塞控制？
1. **慢开始** 
	1. 当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞。较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增加拥塞窗口(cwnd / congestion window)数值。
2. **拥塞避免** 
	1. TCP协议会维护一个慢开始门限(ssthresh)的状态变量，当cwnd < ssthresh时，对拥塞窗口的控制使用慢开始算法，当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
	2. 拥塞避免算法的思路是让拥塞避免窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段有加法增大的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢的多。

3. **快重传** 
	1. 快重传要求接收方在收到一个失序的报文段后就立即发出对最后接收到的有序报文段的重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
4. **快恢复** 
	1. 快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

整个拥塞控制的过程就是


### 4.3.6 TCP的运输连接管理
#### 4.3.6.1 TCP的连接建立的过程是怎么样的？
TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段。<br>
1. 最初TCP客户程序和TCP服务程序都处于CLOSED状态，在之后客户程序要主动打开连接，服务程序被动打开连接。
2. TCP服务程序和TCP客户程序先后建立各自的传输控制模块TCB，TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等等。
3. **第一次握手**  客户端向服务端发出连接请求报文(此报文首部中同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文(即SYN=1的报文)不能携带数据，但是要消耗一个序号)，这时，TCP客户程序进入SYN-SENT(同步已发送)状态。
4. **第二次握手**  服务端收到连接请求报文后，如果同意建立连接，则向客户端发送确认。在确认报文段中应把SYN和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。此确认报文也不能携带数据，但同时也要消耗掉一个序号。这是TCP服务器进程进入SYN-RCVD(同步收到)状态。
5. **第三次握手**  TCP客户端收到服务端的确认报文后，还要向服务端给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己序号seq=x+1。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x+1。这时TCP连接已经建立，客户端进入ESTABLISHED(已建立连接)状态。
6. 当服务端收到客户端的确认后，也进入ESTABLISHED状态。

#### 4.3.6.2 TCP建立连接的过程中，为什么客户端最后还要发送一次确认报文？
**为了防止已失效的连接请求报文突然又传到了服务端，因而产生错误。**<br>
假设出现一种特殊情况，客户程序发出连接请求但是这个请求报文因为种种原因没有按时到达，于是客户程序再重传一次连接请求，后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。如果第一个连接请求报文真的丢失，则没有“已失效的连接请求报文段”，但是如果第一个请求报文并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放后的某个时间才到达服务端。本来这是一个早已失效的报文段，但是服务端收到此失效的连接请求报文段后，会误以为是客户端又发送的一次新的连接请求，于是想客户端发出确认报文，同意建立连接。**如果不采用报文握手**，那么只要服务端发出确认，新的连接就建立了。由于此时客户端并没有真正发出建立连接的请求，因此并不会理睬服务程序的确认报文，也不会像服务端发送数据，而服务端却以为新的运输连接已经建立，并一直等待客户端发送来的数据，服务端的许多资源就这样浪费了。<br>
采用三次报文握手的办法，就能防止上述现象的发生。例如在上述的异常情况下，客户端不会像服务端的确认发出确认，服务端收不到确认，就知道客户端并没有要求建立连接。

#### 4.3.6.3 TCP连接释放的过程是怎么样的？
1. 数据传输结束后，TCP客户程序和服务程序都处于ESTABLISHED状态。
2. **第一次挥手**  客户程序的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。客户程序把连接释放报文段首部的终止控制位FIN置1，其序号seq=u，u等于前面已传送过的数据的最后一个字节的序号加1。此时客户程序进入FIN-WAIT-1(终止等待1)状态，等待服务程序的确认。(TCP规定，FIN报文段即使不携带数据，也消耗一个序号。)
3. **第二次挥手**  服务程序收到连接释放报文后即发出确认，确认号ack=u+1，而这个报文自己的序号是v，v等于服务程序前面已经传送过的数据的最后一个字节的序号加1。然后服务端进入CLOSE-WAIT(等待关闭)状态。TCP服务器进程这时通知高层应用进程，因而这对TCP客户程序到服务程序这个方向间的连接就释放了。这是TCP连接处于半关闭状态，即客户端已经没有数据要发送了，但服务端如果要发送数据，客户端仍要接收。
4. 客户端收到来自服务端的确认后，就进入FIN-WAIT-2(终止等待2)状态，等待服务端发出的连接释放报文段。
5. **第三次挥手**  若服务程序已经没有要想客户端发送的数据，其应用进程就通知TCP释放连接。这时服务端发出的连接释放报文必须使FIN=1。先假设服务端的序号为w(在半关闭状态服务端可能又发送了一些数据)。服务端还必须重复上次发送过的确认号ack=u+1。这时服务端就进入了LAST-ACK(最后确认)状态，等待客户程序的确认。
6. **第四次挥手**  客户程序在收到服务程序的连接释放报文后，必须对此发出确认。在确认报文段把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1，然后进入到TIME-WAIT(时间等待)状态。此时TCP连接并没有释放掉，必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL(Maximum Segment Lifetime/最长报文寿命)后，客户端才进入到CLOSED状态，TCP连接被释放掉。

#### 4.3.6.4 TCP连接释放的过程中，为什么客户端在TIME-WAIT状态必须等待2MSL时间呢？
1. **为了保证客户程序发送的最后一个ACK报文段能够到达服务端。**<br>
客户端的ACK报文段可能丢失，因而使处在LAST-ACK状态的服务程序收不到对已发送的FIN+ACK报文段的确认。服务端会超时重传这个FIN+ACK报文段，这样客户端就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着客户端重传一次确认，重启2MSL计时器。最后客户程序和服务程序都正常进入到CLOSED状态。如果客户端在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文后立即释放连接，那么就无法在上述意外情况出现后收到服务端重传的FIN+ACK报文段，因此也就不会再发送一次确认报文段，这样服务端就无法按照正常步骤进入CLOSED状态。
2. **防止“已失效的连接请求报文段”出现在本连接中。**<br>
客户程序在发完最后一个ACK确认报文段后，再经过时间2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络上消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 4.3.7 TCP的短连接和长连接
#### 4.3.7.1 TCP的短连接和长连接是什么？
1. **TCP短连接：** TCP短连接的过程大概是client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作，因为一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作。
2. **TCP长连接：** TCP长连接的过程大概是client向server发起连接，server接受client连接，双方建立连接。client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。TCP长连接时会用到TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将永远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。

#### 4.3.7.2 TCP保活
**TCP保活负责在服务器端检测已经没有数据传输却仍然占用服务器资源的半连接。**
##### 4.3.7.2.1 为什么会需要TCP保活？
在TCP长连接中，双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会，那么在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些TCP连接并未来得及正常释放，那么连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用TCP的保活报文来实现。

##### 4.3.7.2.2 TCP保活有什么作用？
1. **探测连接的对端是否存活。**在应用交互的过程中，可能存在以下几种情况：
	1. 客户端或服务器端意外断电、死机、崩溃、重启。
	2. 中间网络已经中断，而客户端与服务器端并不知道。<br>
利用保活探测功能，可以探知这种对端的意外情况，从而保证在意外发生时，可以释放半打开的TCP连接。

2. **防止中间设备因超时删除连接相关的连接表**<br>
中间设备如防火墙等，会为经过它的数据报文建立相关的连接信息表，并为其设置一个超时时间的定时器，如果超出预定时间，某连接无任何报文交互的话，中间设备会将该连接信息从表中删除，在删除后，再有应用报文过来时，中间设备将丢弃该报文，从而导致应用出现异常。这种情况在有防火墙的应用环境下非常常见，这会给某些长时间无数据交互但是又要长时间维持连接的应用（如数据库）带来很大的影响，为了解决这个问题，应用本身或TCP可以通过保活报文来维持中间设备中该连接的信息。

##### 4.3.7.2.3 TCP保活报文的格式是怎样的？具体的工作方式是怎样的？
1. TCP保活工作机制： 如果在一段时间(**保活时间**)内连接处于非活动状态，开启保活功能的一端将向对方发送一个**保活探测报文**。如果发送端没有收到**保活响应报文**，那么经过一个已经提前配置好的**保活时间间隔**后继续发送一个保活探测报文，直到发送探测报文的次数达到**保活探测数**，这时对方主机将被确认为不可到达，连接也将被中断。<br>
TCP保活功能的规则过程中，开启该功能的一端会发现对方处于以下四种状态之一：<br>
	1. **对方主机仍在工作，并且可以到达。**请求端将保活计时器重置(重新设定为保活时间值)。如果在计时器超时前有应用程序通过该连接传输数据，那么计时器将再次被设定为保活时间值。
　　2. **对方主机已经奔溃，包括已经关闭或者正在重新启动。**请求端接收不到响应报文，并在经过保活时间间隔指定的时间后超时。超时前，请求端会持续发送探测报文，一共发送保活探测数指定次数为止，如果请求端没收到任何探测报文响应，那么它将认为对方主机已经关闭，连接也将被断开。
　　3. **对方主机奔溃并且已重启。**请求端会受到一个对其保活探测报文的响应，但这个响应是一个重置报文段，请求端将会断开连接。
　　4. **对方主机仍在工作，但是由于某些原因不能到达请求端。**这种情况与状态2相同，因为TCP不能区分状态2和状态4，结果都是没有受到探测报文的响应。

2. 保活探测报文为一个空报文段(只包含1字节)。它的序列号等于对方主机发送的ACK报文的最大序列号减1，因为这一序列号的数据段已经被成功接收，所以不会对到达的报文段造成影响，但探测报文返回的响应可以确定连接是否仍在工作。需要注意的是，探测及其响应报文丢失时不会进行重传。

## 4.4 TCP和UDP有什么区别？ 它们各自有怎么样的应用场景？
1. **TCP是面向连接的协议，UDP是无连接协议** TCP发送数据前使用三次握手建立连接，UDP 发送数据前不需要建立连接。

2. **TCP可靠，UDP不可靠**  TCP丢包会自动重传，UDP不会(任何必需的可靠性必须由应用层来提供)。 TCP可靠性由三个机制保证：
	1. 序号(TCP报文的序号)
	2. 确认(ACK机制)
	3. 重传(超时或者冗余的ACK)
3. **TCP有序，UDP无序**  消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重新排序，UDP不会。
4. **TCP无界，UDP有界**  TCP通过字节流传输，UDP中每一个包都是单独的。
5. **TCP有流量控制、拥塞控制，UDP没有**  TCP协议的流量控制是基于滑窗协议实现的。 拥塞控制和流量控制不同，流量控制是点对点的通信量抑制，抑制发送端发送速率，使得接收端来得及接收。
6. **TCP传输慢，UDP传输快**  因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。 这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。
7. **TCP是重量级的，UDP是轻量级的** TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。
8. **TCP的头部比UDP大**


# 5. 应用层  
## 5.1 DNS(Domain Name System/域名系统)
### 5.1.1 什么是域名系统？为什么要有域名系统？
1. DNS(Domain Name System/域名系统)是互联网使用的命名系统，用来把人们使用的机器名字转换成IP地址。
2. 用户与互联网上某台主机通信时，必须知道对方的IP地址。然而用户很难记住长达32位的二进制主机地址，即使是点分十进制的IP地址也不太好记。所以在应用层为了便于用户记忆各种网络应用，连接在互联网上的主机不仅有IP地址，还有便于用户记忆的主机名字，域名系统DNS能够把互联网上的主机名字转换为IP地址。
3. IP地址的长度是固定的，域名的长度不是固定的，机器处理起来比较困难。

### 5.1.2 域名解析的过程？
当某一个应用进程需要把主机名解析为IP地址时，首先操作系统会检查本地hosts文件是否已存在这个URL映射关系，如果有就调用这个IP地址映射，完成域名解析。如果hosts文件中没有这个域名的映射，则查找本地DNS解析器缓存。如果仍不存在当前域名的映射，则该应用进程就调用解析程序(reslover)，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP数据报(UDP可以减少开销)方式发送给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回，应用进程获得目的主机的IP地址后即可以进行通信。如果本地域名服务器不能回答该请求，则此域名服务器就暂时成为DNS中另一个客户，并向其他域名服务器发出查询请求，这种过程直至能找到能够回答该请求的域名服务器为止。
1. 主机向本地域名服务器的查询一般都采用**递归查询**(recursive query)。即如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步的查询。
2. 本地域名服务器向根域名服务器的查询通常是采用**迭代查询**(iterative query)。当根域名服务器收到本地域名服务器发出的迭代查询报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步该向哪个顶级域名服务器查询，顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步该向哪个权限域名服务器发出查询。

### 5.1.3 域名服务器的等级结构是怎么样的？
1. 一个服务器所管辖的范围叫做区(zone)。各单位根据具体情况来划分自己管辖范围的区，但是在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器(authoriative name sever)，用来保存该区中所有主机的域名到IP地址的映射。
2. 根据域名服务器起的作用，可以把域名服务器划分为以下四种不同类型：
	1. **根域名服务器**(root name server): 根域名服务器时最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，如果对互联网上任何一个域名无法自己解析，就首先要求助于跟域名服务器。根域名服务器并不直接把待查询的域名直接转换成IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。
	2. **顶级域名服务器**(top level domain sever): 顶级域名服务器负责管理在该服务器注册的所有二级域名，当收到DNS查询请求时，就能给出相应的回答，可能是最终查询结果，也可能是下一步应当照的域名服务器的IP地址。
	3. **权限域名服务器**(
authority name server): 负责一个区的域名服务器。当一个权限域名服务器不能给出最后的查询结果时，就会告诉发出查询请求的DNS客户，下一步应该找哪一个权限域名服务器。
	4. **本地域名服务器**(local name server): 当一台主机发出DNS查询请求时，这个查询请求就发送给本地域名服务器。

### 5.1.4 DNS负载均衡是什么？应该怎么实现？
DNS负载均衡技术(DNS重定向)的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。

## 5.2 FTP(File Transfer Protocol/文件传输协议)
### 5.2.1 简单介绍FTP
1. File Transfer Protocol/文件传输协议，应用层协议，基于面向连接的TCP。
2. FTP
3. FTP屏蔽了个计算机系统的细节，因而适合于在异构网络中任何计算机之间传送文件。

### 5.2.2 FTP的工作原理是怎样的？
1. FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个客户进程服务。FTP的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外有若干个从属进程，负责处理单个请求。
2. FTP服务器主进程的工作步骤：
	1. 打开熟知端口(端口号为21)，使客户进程能够连接上。
	2. 等待客户进程发送连接请求。
	3. 启动从属进程处理客户进程发送来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建一些其他子进程。
	4. 回到等待状态，继续接受其他客户进程发送来的请求。主进程与从属进程的处理是并发进行的。
3. 在进行文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接：“**控制连接**”和“**数据连接**”。控制连接在整个会话期间一直保持打开，FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但是控制连接并不用来传送文件。实际用于传输文件的是“数据连接”。服务期端的控制进程在接收到FTP客发送来的文件传输请求后就创建“数据传输进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。
4. 当客户进程像服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口21，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进程用自己传送数据的熟知端口20与客户进程所提供的端口号建立数据传送连接。由于FTP使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。




## 5.2 WWW()

## 5.3 HTTP(Hyper Text Transfer Protocol/超文本传输协议)
### 5.3.1 介绍一下HTTP协议
1. HTTP是Hyper Text Transfer Protocol/超文本传输协议的缩写，是用于从万维网(WWW:World Wide Web)服务器传输超文本到本地浏览器的传输协议。
2. HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

### 5.3.2 HTTP的工作原理
HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送请求。Web服务器根据接收到的请求后，向客户端发送响应信息。

1. **HTTP是无连接的**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
2. **HTTP是媒体独立的**：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
3. **HTTP是无状态的**：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。


### 5.3.2 HTTP的工作过程
#### 5.3.2.1 一个完整的HTTP事务的工作过程是怎么样的？
一次HTTP操作称为一个**事务**(事务是指一系列信息的交换，这一系列的信息交换是一个不可分割的整体，也就是说，要么所有的信息交换都完成，要么一次交换都不进行)，其工作整个过程如下：
1. **地址解析** 如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm
从中分解出协议名、主机名、端口、对象路径等部分，对于上面这个地址，解析得到的结果如下：
	1. 协议名：http
    2. 主机名：localhost.com
    3. 端口：8080
    4. 对象路径：/index.htm<br>
在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。<br>
2. **封装HTTP请求数据包**  把地址解析部分结合本机自己的信息，封装成一个HTTP请求数据包
3. **封装成TCP包，建立TCP连接**在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口
4. **客户机发送请求命令**  建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI：Uniform Resource Identifier）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。
5. **服务器响应**  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据
6. **服务器关闭TCP连接**
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

#### 5.3.2.2 代理服务器是什么？使用代理服务器的主机访问互联网的过程是怎么样的？
代理服务器(proxy server)是一种网络实体，又可叫做万维网高速缓存(Web cache)。代理服务器把最近的一些请求和响应暂存在本地磁盘中，当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网上访问该资源。代理服务器可在客户端或者服务端工作，也可在中间系统工作。
主机通过代理服务器访问互联网的过程是这样的：<br>
1. 主机中的浏览器向互联网的服务器请求服务时，就先和代理服务器建立TCP连接，并向代理服务器发送HTTP请求报文。
2. 若代理服务器已经存放了所请求的对象，代理服务器就把这个对象放入HTTP响应报文中返回给计算机的浏览器。
3. 若代理服务器中没有存放所请求的对象，代理服务器就代表发出请求的用户浏览器，与互联网上的源点服务器建立TCP连接，并发出HTTP请求报文。
4. 源点服务器把所请求的对象放在HTTP响应报文中返回给代理服务器。
5. 代理服务器收到这个对象后，先复制在自己的本地存储器中，然后把对象放在HTTP响应报文中，通过已建立的TCP连接，返回给请求该对象的浏览器。

### 5.3.3 HTTP的方法
#### 5.3.3.1 介绍一下HTTP的方法
HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。<br>
**幂等和非幂等**： 幂等是指多次重复操作和一次操作产生的影响是一样的。非幂等是指多次重复操作和一次操作产生的影响是不一样的。<br>
1. **GET**  GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。
**GET方法会请求指定的页面信息，并返回响应主体。**GET被认为是不安全的方法，因为GET方法会被网络爬虫等任意地访问。
2. **HEAD**  HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以**获取服务器的响应头信息**。HEAD方法**常被用于客户端查看服务器的性能**。
3. **POST**  **POST请求会向指定资源提交数据，请求服务器进行处理。**如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。
4. **PUT** PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。
5. **DELETE** DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法是幂等的。
6. **CONNECT**
CONNECT方法是HTTP/1.1协议预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。
7. **OPTIONS**  OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'\*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。
8. **TRACE**
TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

#### 5.3.3.2 HTTP中GET和POST有什么区别？

#### 5.3.3.3 

### 5.3.4 HTTP的状态码
**HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理结果是否正常、通知出现的错误等工作。**
#### 5.3.4.1 1XX/Informational/信息性状态码/接收的请求正在处理
#### 5.3.4.2 2XX/Success/成功状态码/请求正常处理完毕
1. 200 ok/请求成功 表示从客户端发来的请求在服务器端被正常处理了。
2. 204 no content/ 表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
3. 206 partial content/ 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

#### 5.3.4.3 3XX/Redirection/重定向状态码/需要进行附加操作以完成请求
**3XX响应结果表明浏览器需要执行某些特殊处理以正确处理请求。**
1. 301 move permanently/永久重定向 表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。
2. 302 found/临时性重定向 表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。
3. 303 see other/ 表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。
4. 304 not modified/  表示客户端发送附带条件的请求时，
5. 307 temporary redirect/临时重定向 与302 found含义相同，307遵照浏览器标准，不会从POST变成GET。

#### 5.3.4.4 4XX/Client Error/客户端错误状态码/服务器无法处理请求
1. 400 bad request/错误请求 表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求。
2. 401 unanthorized/认证失败 表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息，另外若之前已进行过1次请求，则表示用户认证失败。
3. 403 forbidden/请求被拒 表示对请求资源的访问被服务器拒绝了。
4. 404 not found/ 表示服务器上无法找到请求的资源，也可以在服务器端拒绝请求且不想说明理由时使用。

#### 5.3.4.5 5XX/Server Error/服务端错误状态码/服务器处理请求出错
1. 500 internal server error/服务器错误 表示服务器端在执行请求时发生了错误。
2. 503 server unavailable/服务器暂时不可用 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### 5.3.5 HTTP的报文结构
1. HTTP有两类报文，分别是请求报文(从客户向服务器发送请求报文)和相应报文(从服务器到客户的回答)。
2. 请求报文和响应报文都有三部分组成，分别是开始行(请求行/状态行)、首部行和实体主体。
	1. **开始行** 用于区分是请求报文还是响应报文。请求报文的开始行叫做请求行(Request-Line，包括发放、URL和版本)，响应报文的开始行叫做状态行(Status-Line，包括版本、状态码和短语)。在开始行的三个字段之间都以空格分隔开，开始行最后会加上回车和换行。
	2. **首部行** 用来说明浏览器、服务器或者报文主体的一些信息。首部行可以有若干行，也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束地方都要有回车加换行。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。
	3. **实体主体** 在请求报文中一般都不用这个字段，在响应报文中也可能没有这个字段。

### 5.3.6 HTTP与其它协议的关系


### 5.3.7 HTTP的长连接和短连接
#### 5.3.7.1 HTTP的长连接和短连接是什么？
1. **在HTTP/1.0中，默认使用的是短连接**。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。
2. **从HTTP/1.1起，默认使用长连接，用以保持连接特性。**使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。<br>
3. **HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**


### 5.3.8 HTTPS
#### 5.3.8.1 HTTP有什么缺点？
1. 通信使用明文(不加密)，内容可能会被窃听。
2. 不验证通信方的身份，因此有可能遭遇伪装。
3. 无法证明报文的完整性，所以有可能已遭篡改。

#### 5.3.8.2 HTTPS在加密、认证和报文完整性保护上有什么改进？
1. HTTPS中涉及到两种加密方式，公开密钥加密技术和共享密钥加密技术。
	1. 共享密钥加密技术/对称密钥加密技术： 加密和解密用同一个密钥。 (发送密钥就有被窃听的风险，但不发送，对方就不能解密。但是密钥要是能够安全发送，那数据也应该能安全送达。)
	2. 公开密钥加密技术： 公开密钥加密使用一对非对称密钥，私有秘钥(private key)和公开密钥(public key)。(公开密钥和私有密钥是配对的一套密钥)使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。
	3. HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制，在交换密钥环节使用公开加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。(公开密钥加密处理起来比共享密钥加密方式更为复杂，因此若在通信时使用公开密钥加密方式，效率就很低。)
2. 为了证明公开密钥正确性，可以使用由数字证书认证机构颁发的公开密钥证书：
	1. 服务器把自己的公开密钥登录至数字证书认证机构。
	2. 数字证书认证机构用自己的私有密钥向服务器的公开密码署数字签名并颁发公钥证书。
	3. 客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥(多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥)，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性。
	4. 客户端使用服务器的公开密钥对报文加密后发送。
	5. 服务器用私有密钥对报文解密。
3. 

#### 5.3.8.3 HTTPS的通信步骤
1. **客户端通过发送Client Hello报文开始SSL通信。**报文中包含客户端支持的SSL的指定版本、加密组件列表(所使用的加密算法及密钥长度等)。
2. **服务器可进行SSL通信时，会以Server Hello报文作为应答。**和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件中筛选出来的。
3. **服务器发送Certificate报文。**报文中包含公开密钥证书。
4. **服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。**
5. **SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应。**报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。此报文已经用3.中的公开密钥加密。
6. **客户端继续发送Change Cipher Spec报文。**该报文会提示想服务器，在此报文之后的通讯会采用Pre-master secret密钥加密。
7. **客户端发送finished报文**。该报文包含连接至今前部报文的整体校验值。这次握手协商是否成功，要以服务器是否能够正确解密该报文作为判定标准。
8. **服务器同样发送Change Cipher Spec报文。**
9. **服务器同样发送Finished报文。**
10. **服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。**通信会受到SSL的保护。从此开始进行应用层的协议通信，即发送HTTP响应。
11. **应用层协议通信，即发送HTTP响应。**
12. **最后客户端断开连接。**断开连接时，发送close_notity报文。


#### 5.3.8.4 HTTPS有什么优缺点？
##### 5.3.8.4.1 HTTPS的优点
1. SEO(Search Engine Optimization/搜索引擎优化)方面
	1. 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

2. 安全性<br>
尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：
	1. 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
	2. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
	3. HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
	4. 全站HTTPS是根治运营商、中间人流量劫持的解决方案，不仅可以杜绝网页中被插入的小广告，更可以保护用户隐私安全。
	5. HTTPS地址栏绿色图标可以帮助用户识别出钓鱼网站，保障用户和企业的利益不受损害，增强用户信任。

##### 5.3.8.4.2 HTTPS的缺点
1. SEO(Search Engine Optimization/搜索引擎优化)和安全方面
	1. 使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。
	2. HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。
	3. HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。
	4. SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
2. 成本方面
	1. SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
	2. SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。
	3. HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。
	4. HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。
	5. HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。

### 5.3.9 HTTP与HTTPS
#### 5.3.9.1 HTTPS要比HTTP多用多少服务器资源？
1. 建立连接方面： HTTP使用TCP三次握手建立连接，客户端和服务器之间需要交换3个包；HTTPS除了TCP的3个包，还需交换SSL握手的9个包。
2. 报文传输方面： 当SSL连接建立之后的加密方式就变成了对CPU负荷较轻的对称加密方式，相对于之前SSL建立时的非对称加密方式，对称加密方式对CPU的负荷基本可以忽略不记。所以如果频繁重建SSL的session，对于服务器的性能将带来巨大损耗。

#### 5.3.9.2 HTTP和HTTPS有什么区别？
1. HTTP明文传输，数据都是未加密的，安全性较差，HTTPS(SSL+HTTP)数据传输过程是加密的，安全性较好。
2. 使用HTTPS协议需要到CA(Certificate Authority，数字证书认证机构) 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
3. HTTP页面响应速度比HTTPS快，主要是因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的三个包，还要加上SSL握手需要的9个包，所以一共是12个包。
4. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
5. HTTPS其实就是建构在SSL/TLS之上的HTTP协议，所以HTTPS比HTTP要更耗费服务器资源。

### 5.3.10 Cookie
#### 5.3.10.1 什么是Cookie
Cookie/Cookies 指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据。

#### 5.3.10.2 Cookie的工作机制是怎么样的？
1. 当用户浏览某个使用Cookie的网站时，该网站的服务器就为此用户产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。接着在给此用户的HTTP响应报文中添加一个叫做Set-cookie的首部行。首部字段名就是“Set-cookie”，而后面的值就是赋予该用户的识别码。
2. 当用户收到这个响应报文时，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括这个服务器的主机名个Set-cookie后面给出的识别码。当用户继续浏览这个网站时，每发送一个HTTP请求报文，其浏览器就会从其Cookie文件中取出这个网站的识别码，并放到HTTP请求报文的Cookie首部行中。
3. 这样，网站就能跟踪特定用户在其网站上的活动。

#### 5.3.10.3 Cookie有什么缺陷？
1. Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。
2. 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。
3. Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。

## 5.4 SMTP()

## 5.5 DHCP(Dynamic Host Configuration Protocol/动态主机配置协议)
### 5.5.1 DHCP的工作方式是怎么样的？
DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)它可以为客户机自动分配IP地址、子网掩码以及缺省网关、DNS服务器的IP地址等TCP/IP参数，简单来说，就是在DHCP服务器上有一个数据库，存放着IP地址、网关、DNS等参数。当客户端请求使用时，服务器则负责将相应的参数分配给客户端，以避免客户端手动指定IP地址等。特别是在一些大规模的网络中。客户端数目较多，使用DHCP可以方便对这些机器进行管理，为客户机提供TCP/IP参数配置，如IP地址、网关地址和DNS服务器等，不仅效率高，而且不存在IP地址冲突的情况。现在的无线路由器默认都带有DHCP功能，也就是说一个无线路由器同时也是一个DHCP服务器。

1. **DHCP DISCOVER: 寻找服务器**  当DHCP客户端第一次登录网络的时候或者是开机时，此计算机发现本机上没有任何IP地址设定，就会向网络广播去寻找DHCP服务器。该数据报的IP源地址会为0.0.0.0，而目的IP地址则为255.255.255.255。
2. **DHCP OFFER: 分配IP地址**  当无线设备监听到客户端发出的寻找服务器的数据包后，它会从那些还没有分配出的IP地址里，选择最前面的的空闲IP，给客户端一个分配IP地址，但这里仅仅是分配，客户端还没有真正应用上。
3. **DHCP REQUEST: 请求使用**  客户端收到无线设备发送回来的分配IP地址数据包，客户端会向网络发送一个ARP数据包，确认网络中没有其他机器使用该IP地址，如果已经有，则重复发送步骤1中的动作;如果没有，则接受该IP地址，并发送一个DHCP REQUEST数据包给无线路由器，也就是DHCP服务器，请求使用此地址。
4. **DHCP ACK: IP地址分配确认**  当无线设备接收到客户端的DHCP REQUEST数据包之后，会向客户端发出一个DHCP PACK回应，以确认IP地址的正式生效，也就结束了一个完整的DHCP工作过程。<br>

当此过程完成之后，DHCP客户端再重新登录网络时，就不需要再发送DHCP DISCOVER发现信息了，而是直接发送包含前一次所分配的IP地址的DHCP REQUEST请求信息。当DHCP服务器收到这一信息后，它会尝试让DHCP客户机继续使用原来的IP地址，并回答一个DHCP ACK确认信息。如果此IP地址已无法再分配给原来的DHCP客户机使用时，则DHCP服务器给DHCP客户机回答一个DHCP NACK否认信息。当原来的DHCP客户机收到此DHCP NACK否认信息后，它就必须重新发送DHCP DISCOVER发现信息来请求新的IP地址。<br>
但DHCP服务器向DHCP客户机出租的IP地址一般都有一个租借期限，期满后DHCP服务器便会收回出租的IP地址。如果DHCP客户机要延长其IP租约，则必须更新其IP租约。DHCP客户机启动时和IP租约期限过一半时，DHCP客户机都会自动向DHCP服务器发送更新其IP租约的信息。

## 5.6 MQTT(Message Queuing Telemetry Transport/消息队列遥测传输协议)

### 5.6.1 简单介绍MQTT
MQTT(Message Queuing Telemetry Transport，消息队列遥测传输协议)，是一种基于发布/订阅（publish/subscribe）模式的"轻量级"通讯协议，该协议构建于TCP/IP协议上，属于应用层协议。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。

### 5.6.2 MQTT协议设计时遵从了什么样的规范？
1. 精简，不添加可有可无的功能；
2. 发布/订阅（Publish/Subscribe）模式，方便消息在传感器之间传递；
3. 允许用户动态创建主题，零运维成本；
4. 把传输量降到最低以提高传输效率；
5. 把低带宽、高延迟、不稳定的网络等因素考虑在内；
6. 支持连续的会话控制；
7. 理解客户端计算能力可能很低；
8. 提供服务质量管理；
9. 假设数据不可知，不强求传输数据的类型与格式，保持灵活性。

### 5.6.3 MQTT协议有什么特性？
MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：<br>

1. 使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。
2. 对负载内容屏蔽的消息传输。

3. 使用TCP/IP提供网络连接。

主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。

4. 有三种消息发布服务质量：
	1. "至多一次"，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。
	2. "至少一次"，确保消息到达，但消息重复可能会发生。
	3. "只有一次"，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。

5. 小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。
这就是为什么在介绍里说它非常适合"在物联网领域，传感器与服务器的通信，信息的收集"，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。

6. 使用Last Will和Testament特性通知有关各方客户端异常中断的机制。
	1. Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。
	2. Testament：遗嘱机制，功能类似于Last Will。

### 5.6.4 MQTT协议的工作原理是怎样的？
#### 5.6.4.1 MQTT协议的实现方式
实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker/服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。<br>
MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：<br>
1. Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；
2. payload，可以理解为消息的内容，是指订阅者具体要使用的内容。

#### 5.6.4.2 网络传输与应用消息
MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。
当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。

#### 5.6.4.3 MQTT客户端的功能
一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：<br>
1. 发布其他客户端可能会订阅的信息；
2. 订阅其它客户端发布的消息；
3. 退订或删除应用程序的消息；
4. 断开与服务器连接。

#### 5.6.4.4 MQTT服务器的功能
MQTT服务器以称为"消息代理"（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：<br>
1. 接受来自客户的网络连接；
2. 接受客户发布的应用信息；
3. 处理来自客户端的订阅和退订请求；
4. 向订阅的客户转发应用程序消息。

#### 5.6.4.5 MQTT协议中的订阅、主题、会话
1. **订阅(Subscription)**
订阅包含主题筛选器(Topic Filter)和最大服务质量(QoS)。订阅会与一个会话(Session)关联，一个会话可以包含多个订阅，每一个会话中的每个订阅都有一个不同的主题筛选器。
2. **会话(Session)**
每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。
3. **主题名(Topic Name)**
连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。
4. **主题筛选器(Topic Filter)**
一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。
5. **负载(Payload)**
消息订阅者所具体接收的内容。

#### 5.6.4.6 MQTT协议中的方法
MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：<br>
1. **Connect** 等待与服务器建立连接。
2. **Disconnect** 等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。
3. **Subscribe** 等待完成订阅。
4. **UnSubscribe** 等待服务器取消客户端的一个或多个topics订阅。
5. **Publish** MQTT客户端发送消息请求，发送完成后返回应用程序线程。

### 5.6.5 MQTT协议数据包结构是什么样的？
在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：
1. 固定头(Fixed header)。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。
2. 可变头(Variable header)。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。
3. 消息体(Payload)。存在于部分MQTT数据包中，表示客户端收到的具体内容。

#### 5.6.5.1 MQTT固定头
固定头存在于所有MQTT数据包中，其结构如下：

##### 5.6.5.1.1 MQTT数据包类型
位置：Byte 1中bits 7-4。
相于一个4位的无符号值，类型、取值及描述如下：

##### 5.6.5.1.2 标识位
位置：Byte 1中bits 3-0<br>
在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：<br>
1. DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。
2. QoS：发布消息的服务质量，即：保证消息传递的次数
Ø00：最多一次，即：<=1
Ø01：至少一次，即：>=1
Ø10：一次，即：=1
Ø11：预留
3. RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。

##### 5.6.5.1.3剩余长度(Remaining Length)
地址：Byte 2<br>
固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0

#### 5.6.5.2 MQTT可变头
MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：
很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS > 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。

#### 5.6.5.3 Payload消息体
Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：
1. CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。
2. SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。
3. SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。
4. UNSUBSCRIBE，消息体内容是要订阅的主题。

# 6. 计算机网络综合
## 6.1 描述一下在浏览器中输入URL后访问的全部过程
1. **DNS解析，由URL到IP地址。**
	1. 	查找浏览器DNS缓存(内存中)，如果存在当前URL的映射则DNS解析完成。
	2. 	查找本地DNS缓存(内存中)，如果存在当前URL的映射则DNS解析完成。
	3.  操作系统检查本地hosts文件是否已存在这个URL的映射关系，如果存在就调用这个IP地址映射，完成域名解析。
	4. 	主机向本网络路由器发起请求，查找路由DNS缓存，如果查找成功则返回IP。
	5.	应用进程调用解析程序(reslover)成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP数据报方式发送给本地域名服务器(local name server)。
	6.	本地域名服务器在查找到域名的映射关系后，把对应的IP地址放在回答报文中返回，域名解析完成。如果本地域名服务器不能回答该请求，则此本地域名服务器就成为DNS的一个客户，向根域名服务器发送查询请求报文。
	7. 	根域名服务器在查找到域名的映射关系后，把对应的IP地址放在回答报文中返回，域名解析完成。如果根域名服务器不能回答该请求报文，则根域名服务器告诉本地域名服务器下一步应该向哪个顶级域名服务器查询。
	8. 	顶级域名服务器在查找到域名的映射关系后，把对应的IP地址放在回答报文中返回，域名解析完成。如果顶级域名服务器不能回答该请求报文，则顶级域名服务器告诉本地域名服务器下一步应该向哪个权限域名服务器查询。
	9.  权限域名服务器返回解析结果，本地域名服务器把查询结果返回给主机。
2. **三次握手建立TCP连接。**
	1. 最初TCP客户程序和TCP服务程序都处于CLOSED状态，在之后客户程序要主动打开连接，服务程序被动打开连接。
	2. TCP服务程序和TCP客户程序先后建立各自的传输控制模块TCB，TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等等。
	3. **第一次握手**  客户端向服务端发出连接请求报文(此报文首部中同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文(即SYN=1的报文)不能携带数据，但是要消耗一个序号)，这时，TCP客户程序进入SYN-SENT(同步已发送)状态。
	4. **第二次握手**  服务端收到连接请求报文后，如果同意建立连接，则向客户端发送确认。在确认报文段中应把SYN和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。此确认报文也不能携带数据，但同时也要消耗掉一个序号。这是TCP服务器进程进入SYN-RCVD(同步收到)状态。
	5. **第三次握手**  TCP客户端收到服务端的确认报文后，还要向服务端给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己序号seq=x+1。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq=x+1。这时TCP连接已经建立，客户端进入ESTABLISHED(已建立连接)状态。
	6. 当服务端收到客户端的确认后，也进入ESTABLISHED状态。
3. **发送HTTP报文。**
	1.  
4. **服务器处理请求并返回HTTP报文。**
	1. 
5. **浏览器解析渲染页面。**
	1. 
6. **四次挥手断开TCP连接。**
	1. 数据传输结束后，TCP客户程序和服务程序都处于ESTABLISHED状态。
	2. **第一次挥手**  客户程序的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。客户程序把连接释放报文段首部的终止控制位FIN置1，其序号seq=u，u等于前面已传送过的数据的最后一个字节的序号加1。此时客户程序进入FIN-WAIT-1(终止等待1)状态，等待服务程序的确认。(TCP规定，FIN报文段即使不携带数据，也消耗一个序号。)
	3. **第二次挥手**  服务程序收到连接释放报文后即发出确认，确认号ack=u+1，而这个报文自己的序号是v，v等于服务程序前面已经传送过的数据的最后一个字节的序号加1。然后服务端进入CLOSE-WAIT(等待关闭)状态。TCP服务器进程这时通知高层应用进程，因而这对TCP客户程序到服务程序这个方向间的连接就释放了。这是TCP连接处于半关闭状态，即客户端已经没有数据要发送了，但服务端如果要发送数据，客户端仍要接收。
	4. 客户端收到来自服务端的确认后，就进入FIN-WAIT-2(终止等待2)状态，等待服务端发出的连接释放报文段。
	5. **第三次挥手**  若服务程序已经没有要想客户端发送的数据，其应用进程就通知TCP释放连接。这时服务端发出的连接释放报文必须使FIN=1。先假设服务端的序号为w(在半关闭状态服务端可能又发送了一些数据)。服务端还必须重复上次发送过的确认号ack=u+1。这时服务端就进入了LAST-ACK(最后确认)状态，等待客户程序的确认。
	6. **第四次挥手**  客户程序在收到服务程序的连接释放报文后，必须对此发出确认。在确认报文段把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1，然后进入到TIME-WAIT(时间等待)状态。此时TCP连接并没有释放掉，必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL(Maximum Segment Lifetime/最长报文寿命)后，客户端才进入到CLOSED状态，TCP连接被释放掉。
