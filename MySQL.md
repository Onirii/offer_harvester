## SQL编译的大致过程？

## 数据库常用的操作
## 什么是左连接、右连接、全连接、内连接？

- **INNER JOIN**：如果表中有至少一个匹配，则返回行
- **LEFT JOIN**：即使右表中没有匹配，也从左表返回所有的行
- **RIGHT JOIN**：即使左表中没有匹配，也从右表返回所有的行
- **FULL JOIN**：只要其中一个表中存在匹配，则返回行



## B树和B+树有什么区别？为什么索引不用B树？
简单版：B+树在非叶子节点不保存数据，只在叶子节点保存。而B树在叶子节点和非叶子节点都会保存。这种结构导致如果使用B树来进行查询，会增加磁盘IO次数，导致性能不如B+树。


## char 和 varchar 的区别是什么？
**char(n)**
固定长度类型，比如订阅char(10)，当你输入“abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。

优点：效率高；
缺点：占用空间；
适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。

**varchar(n)**
可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。

从空间上考虑： varchar 比较合适；
从效率上考虑：char 比较合适。

## float 和 double 的区别是什么？
- float 最多可以存储 8 位的十进制，并在内存中占 4 字节。
- double 最多可以存储 16 位的十进制数，并在内存中占 8 字节。

## 什么是索引，优点与缺点
## 数据库的索引有什么作用？用什么来实现？
索引是用来加快查找速度的。
目前在数据库中一般使用B+树来实现索引。

## MySQL 索引是怎么实现的？
索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查询数据。

具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索 效率，可以达到二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。

---
## 索引的代价
- 空间上的代价
 每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，
 一棵很大的 B+ 树 由许多数据页组成，这可能会占用很大一片存储空间。

- 时间上的代价

 总结：一个表上索引见得越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

## 怎么验证 MySQL 的索引是否满足需求？
使用`explain`查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。
explain 语法：
> explain select * from table where type = 1

## MySQL 常用的引擎？
- InnoDB 引擎：MySQL 5.1 后默认的数据库引擎，提供了对数据库 ACID 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较慢，它是不会保存表的行数的，所以当进行 `select count(*) from table`指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的，所以在并发度较高的场景下使用会提高效率的。
- MyISAM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是， MyISAM 引擎是保存了表的行数，于是当进行 `select count(*) from table`语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyISAM 作为数据库引擎的首选。

----
**InnoDB**
是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻影读。

主索引的聚簇索引，在索引中保存了数据，从而避免了直接读取磁盘，因此对查询性能有很大的提升，

内部做了很多优化，包括从磁盘读取数据时采用的可预测读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读混合场景中，停止写入可能也意味着停止读取。

**MyISAM**
设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 `DELAY_KEY_WRITE` 选项，在每次修改执行完时，不会立将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

比较：
- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键
- 备份：InnoDB 支持在线热备份
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其他特性：MyISAM 支持压缩表和空间数据索引。

## MySQL 的行锁和表锁
MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。
-表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概念最高，并发量最低。
- 行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高。

## MySQL 问题排查都有哪些手段？
- 使用 `show processlist` 命令查看当前所有连接信息；
- 使用 `explain`命令查询 SQL 语句执行计划；
- 开启慢查询日志，查看慢查询的 SQL。

## 如何做 MySQL 的性能优化？
- 为搜索字段创建索引；
- 避免使用 select * ， 列出需要查询的字段；
- 垂直分割分表；
- 选择正确的存储引擎。

## 一张自增表里面总共有 7 条数据，删除了最后两条，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？
- 表类型如果是 MyISAM，那 id 就是 8；
- 表类型如果是 InnoDB，那 id 就是 6。

InnDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。

## 如何获取当前数据库版本？
使用`select version()`获取当前 MySQL 数据库版本。


## 什么是事务，列举业务场景的例子 事务的四大特性

## 事务隔离级别
MySQL 是一个客户端/服务器 架构的软件。

### 事务并发执行遇到的问题
按照严重性排序：
```
脏写 > 脏读 > 不可重复读 > 幻读
```
舍弃部分隔离性换取部分性能：
设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生。

**脏写（Dirty Write）**
如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写。

**脏读（Dirty Read）**
如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读。

**不可重复读（Non-Repeatable Read）**
如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读。

**幻读（Phantom）**
如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读。

> 幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。对于先前已经读到的记录，之后又读取不到的情况，这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。

### SQL 标准中的 4 个隔离级别：
- **READ UNCOMMITTED**：未提交读
- **READ COMMITTED**：已提交读
- **REPEATABLE READ**：可重复读	
- **SERIALIZABLE**：可串行化	

隔离级别 | 脏读 | 不可重复读 | 幻读
-- | -- | -- | --
READ UNCOMMITTED 	| √ | √ | √
READ COMMITTED 			| × | √ | √
REPEATABLE READ 			| × | × | √
SERIALIZABLE 					| × | × | ×

> 脏写这个问题太严重，不论是哪种隔离级别，都不允许脏写的情况发生。

### MySQL 中支持的 4 种隔离级别
与 SQL 标准中所规定的各级隔离级别允许发生的问题有些出入。

MySQL 的默认隔离级别是 `REPEATABLE READ`，可以禁止幻读问题的发生。

## 数据库连接池、解释参数、最大连接数怎么配置

## 数据库死锁、死锁的解决方式

数据库的事务有哪些特性？
主要有四个特性（隔离性需要深入了解），ACID
原子性（Atomicity）、一致性（Consistency）
隔离性（Isolation）、持久性（Durability）

数据库中的隔离等级有哪些？
前提基础：
脏读、不可重复读、幻读
MySQL的四个隔离等级的作用、默认隔离等级
oracle的两个隔离等级的作用、默认隔离等级
