# 1. 全天空极光图像聚类分析及异常事件检测
## 1.1 全天空极光图像预处理

## 1.2 全天空极光图像聚类分析
### 1.2.1 极光特征提取

### 1.2.1 聚类分析
#### 1.2.1.1 常用聚类算法
##### 1.2.1.1.1 K-means 
##### 1.2.1.1.2 Mean-Shift
##### 1.2.1.1.3 DBSCAN(Density-Based Spatial Clustering of Applications with Noise/基于密度的带噪声的空间聚类的应用) 
##### 1.2.1.1.4 基于高斯混合模型(GMM)的期望最大化(EM)聚类
##### 1.2.1.1.5 凝聚层次聚类

## 1.3 全天空极光图像异常事件检测

# 2. SMILE卫星地基极光数据传输/分析平台
## 2.1 平台主要模块的功能及设计
### 2.1.1 数据分析客户端
1. Keogram处理
2. 可视化处理
3. 实时监控

### 2.1.2 网络传输客户端
1. 极光文件网络传输

## 2.2 主要功能的技术实现细节
### 2.2.1 开发框架选择
1. 为什么要用Qt开发这个平台？
	1. 因为极地端的电脑主要是Linux系统(OpenSUSE)，考虑到跨平台开发的效率，选择Qt这个快平台的开发框架。
	2. 平台主要功能是极光图像的处理与传输，考虑到C++在图像处理方面的语言优势还有现有的大量的图形图像处理库(Opencv等)，选择Qt。
	3. Qt命名，继承，类的组织等方面保持了优秀的一致性，这对项目中面向对象实现功能提供了大量可用的优秀接口。

### 2.2.2 极光可视化处理
1. 使用OpenCV做了什么工作？
	1. 对指定站点、波段、时间段的极光数据实现从图像到视频的转换。

2. 具体怎么样把图像转换成了视频？
	1. 定义一个VideoWriter类对象，指明视频存储路径和名称，视频存储格式和图片大小。
	2. 定义一个MAT帧对象，使用imread()函数向这个帧中写入一张图片数据。
	3. 把MAT帧对象中的数据写入VideoWriter类对象。重复执行2、3，直到所有图片都处理完成。

3. 极光3D投影是怎么样的功能？为什么用OSG实现？
	1. 极光3D投影是将指定站点、波段和时间段的极光数据投影在立体的地球表面，有一种极光再现的3D效果。
	2. 选用OSG(OpenSceneGraph)是因为OSG完全基于OpenGL开发，它封装了OpenGL的所有特性，提供了小部分OpenGL接口。
	3. OSG开源免费。
	4. OSG是基于C++开发的，与项目主体兼容。

4. 具体怎么样把极光图像投影在了3D的地球图像上？
	1. 太空场景仿真
		1. 
		2. 工程实现时，在每一帧的渲染中应该首先渲染太空背景，在渲染其他场景，并且保证后渲染的像素遮盖先渲染的像素。
		3. 黑色的太空背景使用清除颜色缓存来实现，并将清除颜色设置为黑色。
		4. 随机产生星星的坐标，然后为生成的小正方形贴上星星纹理。

	2. 地球仿真
		1. 绘制球体
			1. 在球坐标系中，有规律地选取一系列坐标点，每次在这些坐标中选取相距最近的三个点，组成一个三角形，这一系列坐标可以组成无数个三角形，这些小三角形就形成了一个球面。
			2. 在进行由地球平面图向3D地球转换时，需要进行直角坐标系坐标和球坐标系坐标之间的转换。在划分三角形面元时需要确定对球坐标系方位角和仰角的采样频率，最终综合考虑视觉效果和计算效率，选取的采样周期为10°。
			3. 
		2. 添加纹理
			1. 在一张图上采样像素值，将这些像素值绘制到球体的每个三角面元上。
			2. 
		3. 添加公告板效果
			1. 公告板(Billboard)技术，通常是利用多边形总是朝向观察者这一特性，来达到某些特定的效果。公告板技术指出：在场景运动过程中，物体始终保持与实现垂直，观察者始终从正面观察物体，而不会从侧面看到物体。这样就实现了物体的三维显示，这样做的好处是，无需计算物体的内部结构，大大减少了计算量。这项技术常用于渲染游戏中地上的草和远处的山。
			2. 
		4. 添加辉光效果
			1. 人眼能看见实体，是因为实体反射的光线进入了人眼，反射光线与视角夹角越大人眼感知到的光线越弱。当夹角大于90°时，人眼就无法感知到光线，也就形成了实体的背面。
			2. 

	3. 极光仿真
		1. 极光伪彩色图生成
			1. 对极光图像进行伪彩色增强时，依次读取每幅极光图片，并将图片的RGB与这个阈值进行比较，在这个阈值之外的像素舍弃。而在这个阈值之内的像素读取，并重新为像素赋值，使得像素的RGB接近黄绿色，因为黄绿色与真实的极光现象是比较接近的。经过这样处理之后，我们就得到了可以作为纹理的图片。
		2. 添加极光纹理
			1. 为什么不选用粒子系统？
			2. 纹理贴图的工作方式

```cpp
// 太空场景仿真关键代码
// 设置首先渲染太空图层
camera->setRenderOrder(osg::Camera::PRE_RENDER);
// 太空背景颜色设置
camera->setClearColor(osg::Vec4(0.0,0.0,0.0,1.0)); //黑色完全不透明的太空背景
// 生成球形
osg::ref_ptr<osg::Drawable> sphere = new osg::ShapeDrawable(new osg::Sphere(osg::Vec3(0.0, 0.0, 0.0), 0.7));  //球心坐标及半径
// 添加公告板效果
osg::Billboard* sunBillboard = new osg::Billboard();
sunBillboard->setMode(osg::Billboard::POINT_ROT_EYE);
sunBillboard->addDrawable(
createSquare(osg::Vec3(-0.85f,0.0f,-0.85f), osg::Vec3(1.7f,0.0f,0.0f), osg::Vec3(0.0f,0.0f,1.7f), createBillboardImage( osg::Vec4( 1.0, 1.0, 1.0, 1.0f), 64, 1.0) ), osg::Vec3(0.0f,0.0f,0.0f));
osg::Group *root = new osg::Group;
root->addChild(earth);
root->addChild(sunBillboard);
```
### 2.2.3极光数据传输
1. 文件传输用什么协议实现的？
	1. 极光文件传输是基于FTP实现的，

2. 控制消息传输为什么要用MQTT协议实现？
	1. 因为时间和经费问题，选择MQTT实现远程监控模块的消息传输，而不用HTTP。
	2. MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器通信和物联网、通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。
	3. MQTT对不稳定网络环境的容忍度要比HTTP高很多，MQTT能够从断开等故障中恢复，而且没有进一步的代码需求。但是，HTTP 无法原生地实现此目的，需要客户端重试编码。
	4. 实验室有搭建好的用于物联网MQTT服务器，方面早期测试。
3. 


## 2.3 相关其他问题
### 2.3.1 工程里面有没有用到什么设计模式？是怎么样实现？
1. 远程监控模块中用到了**单例模式**。
	1. 在远程监控监控模块中，首先定义了一个基类MQTT管理器，这个管理器支持登录/登出服务器，发布/订阅消息，添加/删除Topic，存储Topic操作。 MQTT管理器类一个抽象基类，因为存在纯虚函数 这是一个抽象基类，因为存在纯虚函数MqttManager::connectToHost。 因此这个类不能生成对象， 需要继承这个类，并在子类中实现纯虚函数。我们分别现了两个子类YRMqttManager和RTEMqttManager。YRMqttManager是用于北极黄河站光数据传输MQTT管理 器；RTEMqttManager是用于科考站点实时监控MQTT管理器。为了保证在一个模块中只会存MQTT管理器，我们使用了“单例 模式”。
2. 

### 2.3.2 网络相关
#### 2.3.2.1 MQTT有什么优点？
1. 实现简单
2. 提供数据传输的 QoS
3. 轻量、占用带宽低
4. 可传输任意类型的数据
5. 可保持的会话（session）

#### 2.3.2.2 MQTT为什么轻量而且灵活？
1. **发布和订阅模型**，和所有消息协议一样，MQTT将数据的发布者和使用者分离。MQTT协议在网络中定义了两种实体类型：一个消息代理和一些客户端。代理是一个服务器，它从客户端接收所有消息，然后将这些消息路由到相关的目标客户端。客户端是能够与代理交互来发送和接收消息的任何事物。客户端可以是现场的IoT 传感器，或者是数据中心内处理IoT数据的应用程序。
	1. 客户端连接到代理。它可以订阅代理中的任何消息 “主题”。此连接可以是简单的TCP/IP连接，也可以是用于发送敏感消息的加密TLS连接。
	2. 客户端通过将消息和主题发送给代理，发布某个主题范围内的消息。
	3. 代理然后将消息转发给所有订阅该主题的客户端。


#### 2.3.2.1 MQTT协议有什么缺点或者不足呢？
1. 没有齐备的SDK，不同的异构终端，需要有对应的与MQTT服务器通信的软件SDK包，比如MCU、Linux、Android、IOS、WEB等之间要实现互联互通必然需要不同的SDK包
2. 不支持File和AV，有些应用场景，需要传输的信息可能不仅仅限于指令，比如声音信号和视频信号，这些需要通过File和AV来实现通信。
3. 不支持与第三方HTTP的集成，虽然MQTT协议优于普通的HTTP协议，但是基于传统的HTTP协议的WEB服务器仍然占主流市场，那么这些服务器要实现与MQTT协议的互联互通，以降低升级成本也尤为关键。
4. 不支持负载均衡，为防止高并发和恶意攻击，负载均衡服务器也必不可少。
5. 不支持用户管理接口，用户在进行设备的行为数据分析的时候，显得尤为重要，这又是工业4.0、大数据时代的必然需求。
6. 不支持离线消息，弥补设备离线以后，MQTT服务器对设备的控制信息丢失的问题。
7. 不支持点对点通信，采用标准的MQTT协议，理论上可以通过相互订阅的方式实现点对点通信，但是逻辑相对复杂，并且对设备的安全性方面存在担忧。当设备B和设备C在同一主题的情况下，设备A无法知道是设备B还是设备C发送的消息，也有可能消息被设备D窃听。
8. 不支持群通信和群管理，实现了对群组成员的管理，群组成员之间能互通消息，这在一个设备被多人控制，或者多个设备被一人控制的这种场景下，尤为有用。

#### 2.3.2.2 MQTT和HTTP相比较有什么区别？
1. 

#### 2.3.3.3 MQTT和CoAP相比较有什么区别？
1. MQTT协议不支持带有类型或者其它帮助Clients理解的标签信息，也就是说所有MQTT Clients必须要知道消息格式。而CoAP协议则相反，因为CoAP内置发现支持和内容协商，这样便能允许设备相互窥测以找到数据交换的方式。
2. MQTT是长连接而CoAP是无连接。MQTT Clients与Broker之间保持TCP长连接，这种情形在NAT(Network Address Translation/网络地址交换)环境中也不会产生问题。如果在NAT环境下使用CoAP的话，那就需要采取一些NAT穿透性手段。
3. MQTT是多个客户端通过中央代理进行消息传递的多对多协议。它主要通过让客户端发布消息、代理决定消息路由和复制来解耦消费者和生产者。MQTT就是相当于消息传递的实时通讯总线。CoAP基本上就是一个在Server和Client之间传递状态信息的单对单协议。

#### 2.3.3.4 通过MQTT建立的通信安全吗？ 怎么样可以保护到MQTT的通信？
1. 客户端与代理的连接可以采用加密TLS连接，可以保护传输中的数据。
2. 此外，因为MQTT协议对有效负载数据格式没有任何限制，所以系统可以协商一种加密方法和密钥更新机制。在这之后，有效负载中的所有内容可以是实际JSON或 XML消息的加密二进制数据。

#### 2.3.3.5 MQTT客户端如何传输它的存在状态？
系统可以为 “presence” 主题协商一个命名约定。例如，“presence/client-id” 主题可以拥有客户端的存在状态信息。当客户端建立连接时，将该消息被设置为 true，在断开连接时，该消息被设置为 false。客户端也可以将一条last will消息设置为 false，以便在连接丢失时设置该消息。代理可以保留该消息，让新客户端能够读取该主题并找到存在状态。


## 2.4 多线程问题
### 2.4.1 在Qt中如何建立一个新线程？
1. 继承自QThread类实现一个子类，重写(override)QThread::run()方法。QThread::run()方法中的代码会在一个新的线程中执行。只有在QThread::run()中定义的对下那个才属于新线程，QThread类成员变量仍然属于QThread对象所在的线程。
2. 继承自QObject类实现一个子类，调用QObject::moveToThread()方法将这个对象加入到一个新线程中。需要注意的是，必须直接继承自QObject实现子类，否则不能开启一个新的线程。

### 2.4.2 项目中哪些环节用到了多线程技术？
1. 多通道极光文件传输
	1. (UploadThread + DetectNewFilesThread) -> UploadImplement -> UploadModule
	2. UploadModule 界面类 负责界面显示，MQTT服务器设置，传输相关消息显示及发布，按钮的背后功能代码实现。
	3. UploadImplement //可省略
	4. UploadThread 传输线程类，继承自QThread，重写了run()方法，在run()中实现了传输状态控制、从缓冲区取出新文件、FTP服务器设置与连接、FTP对象的消息接口函数与界面显示的连接、及最终的文件上传。
	5. DetectNewFilesThread 新文件检测类，QThread，重写了run()方法，在run()中实现了新文件检测。
	6. DetectNewFilesThread类 与 UploadThread类共享一个文件缓冲区fileBuffer，DetectNewFilesThread负责把检测到的新文件写入fileBuffer，UploadThread在每次上传开始前会把fileBuffer中的文件名转移到文件列表，然后清空fileBuffer。所以在两个类对fileBuffer读写时都需要加锁，保证对fileBuffer的互斥访问。

2. 多通道Keogram处理
	1. HistoryThread -> HistoryModule
	2. HistoryMoudule 界面类，负责界面显示、按钮的背后功能代码实现，启动Keogram处理线程类。
	3. HistoryThread Keogram处理线程类，继承自QThread，重写了run()方法，在run()中指定时间段的Keogram类。对于Keogram特征数据产生，Keogram图片拼接及刷新显示这一过程进行保护，避免线程执行这些任务期间的线程切换，引起显示上不正常结果。

3. 将3D投影的极光图像预处理转移到新线程
	1. 在进行极光图像3D投影处理时，需要对选定时间段的极光图像进行预处理，包括极光内容提取及投影格式图像转换。如果在主线程中进行上述预处理，因为计算量过大会造成界面卡死，因此选择把图像预处理部分转移到新线程中，新建ImageProcessThread，继承自QThread，重写了run()方法，在run()中实现预处理。

# 3. 基于眼部特征的疲劳驾驶检测系统
## 3.1 系统主要模块的功能及设计

## 3.2 
### 3.2.1 GBDT中一棵树的构建
1. 初始形状：所有图像的回归形状/随机挑选另外一个真实形状
2. 将数据集中的N张图像作为输入数据(真实的输入数据是从当前形状提取出的像素特征)
3. 每一张图像都会落到树的一个叶子节点上，残差是每一张图像的当前形状和真实形状之间的差值，再将同一个叶子结点上所有图片的残差做平均，就是该叶子结点当前保存的残差。
4. 构造完一棵树之后，需要将每张图片的当前形状做一个更新，具体更新为 当前形状+=残差，这样每张图片就距离真实形状更近了一步。
5. 构造下一个树，以最新的当前形状作为输入。

### 3.2.2 树的节点分裂和像素差特征
1. 建立特征池(随机挑选的一些点的坐标)
2. 节点分裂时，首先在合格的特征池中随机挑选两个点，计算每一张图片在这两个点处的像素值，然后计算每一张图片在这两个点处像素值的像素差，之后随机产生一个分裂阈值，根据这个阈值进行判断，如果一副图像的像素差小于这个阈值，就往左分裂，大于阈值，就往右分裂。将所有图片都这样判断一次，就将所有图片分成了两部分，一部分在左，一部分在右。以方差为判断依据，重复上面过程若干次，保留方差最小的一次。