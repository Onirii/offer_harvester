# 1. 未解决
1. 海量数据，查找其中的url，怎么去重，设计合适的数据结构
2. ctrl+c发生什么，怎么通知进程的
3. 进程内存管理静态存储区初始化和未初始化分别怎样存储
4. 父进程和子进程共享那些信息
5. c++的头文件怎么给c项目使用
6. 段错误怎样定位
7. 编译和链接的区别！！！
8. malloc和new的区别！！！
9. 手写string的复制构造函数，拷贝构造函数，带参数构造函数，析构函数！！！
10. tcp怎么确认是否丢包，tcp的SYN序列号怎么生成，select使用了那些额外参数配置
11. tcp服务器断电后，重新来电，客户端会接受什么
12. 智能指针，weak_ptr怎么实现
13. vector的size能否减少
14. 死锁，怎么预防，写出产生死锁的图解
15. 线程加锁后，里面的变量能否访问
16. strcmp/strcpy实现原理
17. weak_ptr在多线程中的应用
18. QT信号槽原理知道吗，如果要自己实现一个你会怎么做？
19. C++11 的原子操作，C++11多线程内存模型
20. std::thread 和操作系统级别的线程有什么区别
21. 文件里很多银行账号 ，统计出现次数最多的几个账号
22. 怎么探查网络数据带宽，在不占满的情况下
23. 什么是中断
24. 进程切换怎么实现 怎么保留断点信息。
25. 哈希函数及哈希冲突
26. 日志文件10亿条，每条记录 用户账号 上线时间 下线时间。时间从0---86400s，最小时间复杂度和最小空间复杂度  得出每一秒在线人数的统计情况
27. ARP欺诈
28. 一个进程里包含什么 
29. 一个进程在32系统上寻址空间最多多大
30. 假如有一万个单词，分别用空格隔开，统计重复单词的次数
31. const函数和非const函数可以实现重载吗
32. 基类里private成员函数可以声明为虚函数吗
33. vector使用迭代器进行循环，当循环开始时push_back一个数在后面，会发生什么
34. 假如有一万个单词，分别用空格隔开，统计重复单词的次数
35. 讲一下MTU和MSS
36. 进程A和进程B只能进行网络通信，当进程B挂掉之后进程A如何快速知道进程B挂掉
37. vector v1(100,0) 和 vector v2(200,0) ，它们sizeof大小分别为多少
38. strcpy使用可能有什么缺陷
39. 子类继承父类，如果父类的析构函数不是虚函数，会有什么问题？
40. extern c有什么用
41. rand5实现rand7  有一个能可以生成1-6的随机数生成器，实现一个随机1-12的随机数生成器。！！！
42. static函数可以修改成员变量
43. 实现atoi
44. 手写简单的一个线程 手写多个线程按顺序执行 手写一定区间的随机数
45. 写一个memcpy、strcpy
46. 给几百万个网址，如何高效找出特定网址是否在其中?(布隆过滤器) 布隆过滤器优缺点，如何解决其缺点？
47. 50个红球50个蓝球，放到2个袋子里，从两个袋子各取1个球，让2个都是红球的概率最大，怎么放
48. Linux下删除同一文件夹下所有满足条件的文件
49. new/delete和malloc/free的区别
50. vector的结构？vector拷贝时发生什么
51. 一个数组，只有一个数字出现奇数次，其余数字出现偶数次，如何得到这个数字？如果出现奇数次的数字有2个呢？
52. cmake和makefile的区别
53. 2g物理内存，new一个3g的数组时发生什么？
54. char (\*p) [] 、char \*p[]、char (\*p)()的区别？
55. 说说select、poll、epoll区别？
56. 熟悉句柄么？程序执行后句柄如何处理，如何修改可打开句柄数量？
57. 如何设计一个高并发的分布式服务器？
58. 1G内存，4G url，求重复的url
59. 迭代器的++it和it++哪个好
60. 拷贝构造函数的参数为什么要传引用而不是传值？
61. strncpy的实现？为什么strcpy是不安全的？可以结合缓冲区溢出说一下。
62. STL的map底层是怎么样的？
63. C++的lambda表达式怎么用？按值捕获和按引用捕获讲一下
64. sizeof空类的大小？为什么
65. 静态链接库和动态链接库的区别
66. 如何防止c++头文件被重复引用
67. 什么叫软链接和硬链接，他们的区别是什么
68. io复用和异步io有什么区别？ 	
69. 多线程、多进程在实际服务器中的应用
70. 讲讲自旋锁，递归锁，乐观锁，悲观锁
71. 面向对象有什么优点？为什么要有面向对象？
72. 存在大量closed_wait有什么危害
73. LRU
74. malloc内存分配机制是怎么样的,在哪里分配内存，最大可以申请多大的内存
75. 怎么用C实现一些C++的特性吗，比如重载、多态？
76. 进程调度算法
77. C++智能指针如何解决内存泄露问题
78. 各种语言的应用场景，如python的应用场景
79. 用C++写一个简单的多态实现。
80. 判断一个字符串表示的ip地址是否合法
81. 如何检测死循环，答perf工具去看时间，说不用这个工具呢，说思路。
82. 为什么要字节对齐
83. 高并发频繁加锁对性能有影响吗，怎么优化
84. http报文特别大，每次读多少字节，一个报文分几次发送，怎么完整接受，有没有试过发送特别大的报文，这是TCP里面的什么问题（粘包）
85. 服务器怎么实现的
86. 子线程如果卡住了，会一直等待吗
87. 怎么判断哪个线程空闲，怎么让程序充分利用多核，线程实际上是在多核上跑吗
88. new背后会发生什么
89. 在类里面给成员赋值，会在什么时候初始化
90. 为什么析构函数不要抛出异常，构造函数中出现异常会怎么样
91. lamda表达式原理，lamda表达式内的变量的生命周期   编译器是如何实现lambda表达式
92. http2.0和1.1区别，多路复用原理
93. 介绍下重载和重写，f(int, float), f(float, int), 调用f(1, 1)用的哪个
94. stl用过哪些，sort怎么实现，unordered_map实现
95. 手写线程安全的单例模式！！！
96. 静态成员函数能调用非静态成员函数吗
97. 编译的过程
98. 多进程下gdb调试流程
99. https 客户端和服务器是如何实现协议选择的，现在常用的协议是什么 https 客户端鉴定服务器的过程
100. 操作系统的段和页式管理，段页式优点？
101. n个数中取m个数，要求每个数取出的概率相等
102. 手写LRU
103. 在点击一个exe文件时，会发生什么样的一个操作
104. LRU有什么缺点
105. 写一个LRU的缓存，需要完成超时淘汰和LRU淘汰。
106. 请你说明智能指针是否存在内存泄露的情况？！！！
107. 就绪状态的进程在等待什么？
108. 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？
109. server端监听端口，但是还没有客户端连接进来，此时进程处于什么状态？
110. 空闲的进程和阻塞的进程状态会不会在唤醒时候误判？
111. 进程状态转换图，动态就绪、静态就绪、动态阻塞、静态阻塞是什么？
112. 多进程和多线程的使用场景
113. 游戏服务器应该为用户开辟一个线程还是一个进程，为什么？
114. 有了进程，为什么还要线程？
115. 单核机器上写多线程程序，是否需要考虑加锁，为什么？
116. 线程需要保存那些上下文，SP、PC、EAX这些寄存器有什么作用？
117. 线程间的同步方式是怎么样的？ 具体的系统调用是怎么样的？
118. 死循环和来连接时新建线程的方法效率有点低，怎么改进？
119. 怎么唤醒被阻塞的socket线程？
120. 怎么确定当前线程是繁忙还是阻塞？
121. 假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？
122. 线程池的概念、有点、调度处理方式和保护任务队列的方式？
123. 线程池对线程的管理方式，包括初始化线程的方法、线程创建后的管理、指派任务的方式
124. 线程池的实现
125. 进程的内存结构
126. 协程相对于进程和线程有什么共同点和区别？
127. 怎么看一个进程占用了哪些端口？
128. Linux下进程与线程的区别？
129. 如果要计算0-1000000所有的质数，用单线程和多线程计算有什么区别？
130. 如果一个进程有异常该如何监控?

# 2. 已解决

## 4. 子进程和父进程共享哪些信息？
**子进程继承的来自父进程的属性：**

1. 已打开的文件描述符
2. 实际用户ID、实际组ID、有效用户ID、有效组ID
3. 附属组ID
4. 进程组ID
5. 会话ID
6. 控制终端
7. 设置用户ID标志和设置组ID标志
8. 当前工作目录
9. 根目录
10. 文件模式创建屏蔽字
11. 信号屏蔽和安排
12. 对任一打开文件描述符的执行时关闭标志
13. 环境
14. 连接的共享存储段（共享内存）
15. 存储映像
16. 父进程的用户堆栈

**子进程和父进程不一样的：**
1. fork()的返回值不同
2. 进程ID不同
3. 父进程ID不同
4. 子进程不继承父进程设置的文件锁
5. 子进程的未处理闹钟被清除
6. 子进程的未处理信号集合设置为空集
7. 父进程和子进程有独立的地址空间和PID参数
8. 子进程不继承父进程的异步输入和输出

## 7. 编译和链接的区别

### 7.1 C/C++文件执行全过程
#### 7.1.1 预编译
**预编译相当于根据预处理指令组装新的C/C++程序。经过预编译，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义与原本文件无异，只是内容上有所不同。**<br>
**预编译过程由.c/.cpp文件生成.i文件**
### 7.1.1.1 读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理
1. 将所有的“#define”删除，并且展开所有的宏定义。
2. 处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。
3. 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。

#### 7.1.1.2 删除所有注释

#### 7.1.1.3 添加行号和文件名标识
以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告是能够显示行号。

#### 7.1.1.4 保留所有的#pragma编译器指令

### 7.1.2 编译
**将预处理完的文件进行一系列词法分析、语法分析、语义检查和中间代码生成、代码优化和目标代码生成，产生相应的汇编代码文件。编译由.i文件生成.s文件。**
1. **词法分析**：将源代码文件的字符序列划分为一系列的记号，一般词法分析产生的记号有：标识符、关键字、数字、字符串、特殊符号（加号、等号）；在识别记号的同时也将标识符放好符号表、将数字、字符放入到文字表等；有一个lex程序可以实现词法扫描，会按照之前定义好的词法规则将输入的字符串分割成记号，所以编译器不需要独立的词法扫描器；
2. **语法分析**：语法分析器将对产生的记号进行语法分析，产生语法树----就是以表达式尾节点的树，一步步判断如何执行表达式操作。
3. **语义分析**：由语法阶段完成分析的并没有赋予表达式或者其他实际的意义，比如乘法、加法、减法，必须经过语义阶段才能赋予其真正的意义；
语义分析主要分为静态语义和动态语义两种；静态语义通常包括声明和类型的匹配、类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程。只要存在类型不匹配编译器会报错。经过语义分析后的语法树的所有表达式都有了类型。动态语义分析只有在运行阶段才能确定。
4. **中间代码生成**
5. **代码优化** 
6. **代码生成** 
7. **符号表管理** 
8. **将多个步骤组合成趟** 
9. **编译器构造工具** 

### 7.1.3 汇编
**将编译完成的代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。**<br>
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。目标文件由段组成。通常一个目标文件中至少有两个段： **代码段**：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。 **数据段**：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。

### 7.1.4 链接
**通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。**
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。<br>
例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。<br>
链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。<br>

## 8. malloc和new的区别？

1. **申请的内存所在位置**

	1. **new操作符从自由存储区(free store)上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。**

	2. 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

	3. 自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

2. **返回类型安全性**

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void \* ，需要通过强制类型转换将void \*指针转换成我们需要的类型。 类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图分配自己没被授权的内存区域。

3. **内存分配失败时的返回值**

new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。

4. **是否需要指定内存大小**

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
```cpp
class A{...};
A * ptr = new A;
A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A);
```
5. **是否调用构造函数/析构函数**

	1. 使用new操作符来分配对象内存时会经历三个步骤：
		1. 调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
		2. 编译器运行相应的构造函数以构造对象，并为其传入初值。
		3. 对象构造完成后，返回一个指向该对象的指针。
	2. 使用delete操作符来释放对象内存时会经历两个步骤：
		1. 调用对象的析构函数。
		2. 编译器调用operator delete(或operator delete[])函数释放内存空间。

总之来说，**new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构，而malloc则不会。**

6. **对数组的处理**

C++提供了new[]与delete[]来专门处理数组类型:
```cpp
A * ptr = new A[10];//分配10个A对象
```
使用new[]分配的内存必须使用delete[]进行释放：
```cpp
delete [] ptr;
```
new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

至于malloc，它并不知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：
```cpp
int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
```

7. **是否可以相互调用**

operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：

```cpp
void * operator new (sieze_t size){
    if(void * mem = malloc(size))
        return mem;
    else
        throw bad_alloc();
}

void operator delete(void *mem) noexcept
{
    free(mem);
}
```

8. **是否可以被重载**

opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：

```cpp
//这些版本可能抛出异常
void * operator new(size_t);
void * operator new[](size_t);
void * operator delete (void * )noexcept;
void * operator delete[](void *0)noexcept;

//这些版本承诺不抛出异常
void * operator new(size_t ,nothrow_t&) noexcept;
void * operator new[](size_t, nothrow_t& );
void * operator delete (void *,nothrow_t& )noexcept;
void * operator delete[](void *0,nothrow_t& ）noexcept;
```
用户可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。总之，用户有足够的自由去重载operator new /operator delete ,以决定其new与delete如何为对象分配内存，如何回收对象。

而malloc/free并不允许重载。

9. **是否能够直观地重新分配内存**

使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

new没有这样直观的配套设施来扩充内存。

10. **客户处理内存分配不足**


## 9. 手写string的复制构造函数，拷贝构造函数，带参数构造函数，析构函数
```cpp
class String 
{
public:
    String(const char *str=NULL);//构造函数
    String(const String &other);//拷贝构造函数
    ~String(void);//析构函数
    String& operator=(const String &other);//等号操作符重载
    ShowString();
private:
    char *m_data;//指针
};

String::~String()
{
  delete[] m_data;//析构函数，释放地址空间
}
String::String(const char *str)
{
    if (str==NULL){//当初始化串不存在的时候，为m_data申请空间
       m_data = new char[1];
       *m_data='\0';
    }
    else{
        int length = strlen(str);
        m_data = new char[length+1];
        strcpy(m_data,str);
    }
}

String::String(const String &other)//拷贝构造函数
{
    int length = strlen(other.m_data);
    m_data = new char[length+1];
    strcpy(m_data,other.m_data);
}

String& String::operator=(const String &other)
{
    if (this==&other)
    {
        return *this; //检查自赋值。
    }
    delete []m_data; //释放原有的内存资源。
    int length = strlen(other.m_data);
    m_data=new char[length+1]; //分配新的内存资源。
    strcpy(m_data,other.m_data); //复制内容。
    return *this; //返回对本对象的引用。
}

//
```

```cpp
// 在检查自赋值->释放原有的内存资源->分配新的内存资源、复制内容->返回对本对象的引用这几步构成的赋值运算符函数中，程序在分配新的内存之前释放掉了m_data的内存。如果此时内存不足导致new char抛出异常，则m_data将是一个空指针，这样容易导致程序崩溃。这段代码违背了异常安全性的原则。
// String copy assignment的异常安全版本。
String& String::operator =(const String &other){
	if(this != other){
		String Strtemp(other); //Strtemp为局部变量，当程序运行到if()外面时也就出了该变量的作用域，就会自动调用Strtemp的析构函数，把Strtemp.m_data指向的内存释放掉。由于Strtemp指向的内存就是实例之前m_data的内存，就相当于自动调用析构函数释放掉实例的内存。

		char *temp = Strtemp.m_data;
		Strtemp.m_data = m_data;
		m_data = temp;
	}
	return *this;
}
```

## 14. 死锁产生的原因？死锁应该怎么预防？写出产生死锁的图解
如果一组进程中的每一个进程**都在**等待仅由该组进程中的其他进程才能引发的时间，那么该组进程就是死锁的。<br>
死锁是指两个或者两个以上的进程在执行过程中，因争夺资源而造成的相互等待的现象。死锁发生的四个必要条件如下:<br>
1. **互斥条件**： 进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；
2. **请求和保持条件**： 进程获得一定资源后，又对其他资源发出请求，但是该资源可能被其他进程占有。此时请求阻塞，但是该进程不会释放掉自己已经占有的资源；
3. **不可抢占条件**： 进程已经获得的资源，在未使用完成前，不可被抢占，只能在使用后自己释放；
4. **环路等待条件**： 进程发生死锁后，必然存在一个进程-资源之间的环形链。

## 20. std::thread和操作系统级别的线程有什么区别？


## 41. rand5(1-5的随机整数生成函数)实现rand7(1-7的随机整数生成函数)
### 41.1 已知rand5()产生1-5的随机整数，利用该函数生成函数rand7()产生1-7的随机整数。
1. rand5()等概率生成1、2、3、4、5。
2. 5 \* (rand5() - 1)等概率生成0、5、10、15、20。
3. 5 \* (rand5() - 1) + rand5() 等概率生成1-25。出现1-25中任一结果只有一种特定的两个rand()组合，故等概率。
4. 利用rand25()生成rand7()。

```cpp
#include <climits>
int rand7(){
	int x = INT_MAX;
	while(x > 7){
		x = 5*(rand5() - 1) + rand5();
	}
	return x;
}
```
```cpp
#include <climits>
int rand7(){
	int x = INT_MAX;
	while(x > 21){
		x = 5*(rand5() - 1) + rand5();
	}
	return x%7 + 1;
}
```

### 41.2 已知randA()产生1-A的随机整数，利用该函数生成函数randB()产生1-B的随机整数。
1. 如果A > B，进入步骤2；否则构造randA2 = A * (randA – 1) + randA， 表示生成1到A2 随机数的函数。如果A2 仍小于B，继教构造 randA3 = A * (randA2 - 1) + randA…直到Ak > B，这时我们得到randAk , 我们记为randA。
2. 步骤1中得到了randA(可能是randa或randAk )，其中A > B，可以用以下代码构造RandB：

```cpp
#include <climits>
int randB(){
	int x = INT_MAX;
	while(x > B*(Ak/B)){
		x = randAk();
	}
	return x%B + 1;
}
```

## 59. 迭代器的++it和it++哪个好？
**++it好。**两种方式iterator遍历的次数是相同的，但在STL中效率不同。**++it返回引用，it++返回一个临时对象。**因为iterator是类模板，使用 it++这种形式要返回一个无用的临时对象，而it++是重载，所以无法对其进行优化，所以每遍历一个元素，就相当于创建并销毁了一个无用的临时对象。

## 95. 手写线程安全的单例模式
```cpp
//双检查锁
class Singleton
{
private:
	static Singleton* m_Instance;
	Singleton(){}
	Singleton(const Singleton& other);
	Singleton& operator=(const Singleton&);
public:
	static Singleton* GetInstance(){
		if(m_Instance == nullptr){ //第一次检查
			Lock lock; //加锁
			if(m_Instance == nullptr){ //第二次检查
				m_Instance = new Singleton();
			}
		}
		return m_Instance;
	}
}

//双检查锁两次检查的意义：
//第一次检查：第一次检查负责检查是不是对m_Instance的读操作，如果m_Instance此时已经被创建(非nullptr)，则多线程只读m_Instance不需要加锁。
//第二次检查：如果没有第二次检查，则在m_Instance未完全创建时，凡是通过第一次检查的线程均能获得lock，可能有多个m_Instance被创建。
```


## 106. 智能指针是否存在内存泄露的情况？
智能指针也可能存在内存泄漏的情况，比如当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。
为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。
**将造成循环引用的其中一个shared_ptr用weak_ptr替换。**