# 1. 未解决
1. 海量数据，查找其中的url，怎么去重，设计合适的数据结构
2. ctrl+c发生什么，怎么通知进程的
3. 进程内存管理静态存储区初始化和未初始化分别怎样存储
4. 父进程和子进程共享那些信息
5. c++的头文件怎么给c项目使用
6. 段错误怎样定位
7. 编译和链接的区别！！！
8. malloc和new的区别
9. 手写string的复制构造函数，拷贝构造函数，带参数构造函数，析构函数
10. tcp怎么确认是否丢包，tcp的SYN序列号怎么生成，select使用了那些额外参数配置
11. tcp服务器断电后，重新来电，客户端会接受什么
12. 智能指针，weak_ptr怎么实现
13. vector的size能否减少
14. 死锁，怎么预防，写出产生死锁的图解
15. 线程加锁后，里面的变量能否访问
16. strcmp/strcpy实现原理
17. weak_ptr在多线程中的应用
18. QT信号槽原理知道吗，如果要自己实现一个你会怎么做？
19. C++11 的原子操作，C++11多线程内存模型
20. std::thread 和操作系统级别的线程有什么区别
21. 文件里很多银行账号 ，统计出现次数最多的几个账号
22. 怎么探查网络数据带宽，在不占满的情况下
23. 什么是中断
24. 进程切换怎么实现 怎么保留断点信息。
25. 哈希函数及哈希冲突
26. 日志文件10亿条，每条记录 用户账号 上线时间 下线时间。时间从0---86400s，最小时间复杂度和最小空间复杂度  得出每一秒在线人数的统计情况
27. ARP欺诈
28. 一个进程里包含什么 
29. 一个进程在32系统上寻址空间最多多大
30. 假如有一万个单词，分别用空格隔开，统计重复单词的次数
31. const函数和非const函数可以实现重载吗
32. 基类里private成员函数可以声明为虚函数吗
33. vector使用迭代器进行循环，当循环开始时push_back一个数在后面，会发生什么
34. 假如有一万个单词，分别用空格隔开，统计重复单词的次数
35. 讲一下MTU和MSS
36. 进程A和进程B只能进行网络通信，当进程B挂掉之后进程A如何快速知道进程B挂掉
37. vector v1(100,0) 和 vector v2(200,0) ，它们sizeof大小分别为多少
38. strcpy使用可能有什么缺陷
39. 子类继承父类，如果父类的析构函数不是虚函数，会有什么问题？
40. extern c有什么用
41. rand5实现rand7  有一个能可以生成1-6的随机数生成器，实现一个随机1-12的随机数生成器。！！！
42. static函数可以修改成员变量
43. 实现atoi
44. 手写简单的一个线程 手写多个线程按顺序执行 手写一定区间的随机数
45. 写一个memcpy、strcpy
46. 给几百万个网址，如何高效找出特定网址是否在其中?(布隆过滤器) 布隆过滤器优缺点，如何解决其缺点？
47. 50个红球50个蓝球，放到2个袋子里，从两个袋子各取1个球，让2个都是红球的概率最大，怎么放
48. Linux下删除同一文件夹下所有满足条件的文件
49. new/delete和malloc/free的区别
50. vector的结构？vector拷贝时发生什么
51. 一个数组，只有一个数字出现奇数次，其余数字出现偶数次，如何得到这个数字？如果出现奇数次的数字有2个呢？
52. cmake和makefile的区别
53. 2g物理内存，new一个3g的数组时发生什么？
54. char (\*p) [] 、char \*p[]、char (\*p)()的区别？
55. 说说select、poll、epoll区别？
56. 熟悉句柄么？程序执行后句柄如何处理，如何修改可打开句柄数量？
57. 如何设计一个高并发的分布式服务器？
58. 1G内存，4G url，求重复的url
59. 迭代器的++it和it++哪个好
60. 拷贝构造函数的参数为什么要传引用而不是传值？
61. strncpy的实现？为什么strcpy是不安全的？可以结合缓冲区溢出说一下。
62. STL的map底层是怎么样的？
63. C++的lambda表达式怎么用？按值捕获和按引用捕获讲一下
64. sizeof空类的大小？为什么
65. 静态链接库和动态链接库的区别
66. 如何防止c++头文件被重复引用
67. 什么叫软链接和硬链接，他们的区别是什么
68. io复用和异步io有什么区别？ 	
69. 多线程、多进程在实际服务器中的应用
70. 讲讲自旋锁，递归锁，乐观锁，悲观锁
71. 面向对象有什么优点？为什么要有面向对象？
72. 存在大量closed_wait有什么危害
73. LRU
74. malloc内存分配机制是怎么样的,在哪里分配内存，最大可以申请多大的内存
75. 怎么用C实现一些C++的特性吗，比如重载、多态？
76. 进程调度算法
77. C++智能指针如何解决内存泄露问题
78. 各种语言的应用场景，如python的应用场景
79. 用C++写一个简单的多态实现。
80. 判断一个字符串表示的ip地址是否合法
81. 如何检测死循环，答perf工具去看时间，说不用这个工具呢，说思路。
82. 为什么要字节对齐
83. 高并发频繁加锁对性能有影响吗，怎么优化
84. http报文特别大，每次读多少字节，一个报文分几次发送，怎么完整接受，有没有试过发送特别大的报文，这是TCP里面的什么问题（粘包）
85. 服务器怎么实现的
86. 子线程如果卡住了，会一直等待吗
87. 怎么判断哪个线程空闲，怎么让程序充分利用多核，线程实际上是在多核上跑吗
88. new背后会发生什么
89. 在类里面给成员赋值，会在什么时候初始化
90. 为什么析构函数不要抛出异常，构造函数中出现异常会怎么样
91. lamda表达式原理，lamda表达式内的变量的生命周期   编译器是如何实现lambda表达式
92. http2.0和1.1区别，多路复用原理
93. 介绍下重载和重写，f(int, float), f(float, int), 调用f(1, 1)用的哪个
94. stl用过哪些，sort怎么实现，unordered_map实现
95. 手写线程安全的单例模式！！！
96. 静态成员函数能调用非静态成员函数吗
97. 编译的过程
98. 多进程下gdb调试流程
99. https 客户端和服务器是如何实现协议选择的，现在常用的协议是什么 https 客户端鉴定服务器的过程
100. 操作系统的段和页式管理，段页式优点？
101. n个数中取m个数，要求每个数取出的概率相等
102. 手写LRU
103. 在点击一个exe文件时，会发生什么样的一个操作
104. LRU有什么缺点
105. 写一个LRU的缓存，需要完成超时淘汰和LRU淘汰。
106. 请你说明智能指针是否存在内存泄露的情况？！！！
107. 就绪状态的进程在等待什么？
108. 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？
109. server端监听端口，但是还没有客户端连接进来，此时进程处于什么状态？
110. 空闲的进程和阻塞的进程状态会不会在唤醒时候误判？
111. 进程状态转换图，动态就绪、静态就绪、动态阻塞、静态阻塞是什么？
112. 多进程和多线程的使用场景
113. 游戏服务器应该为用户开辟一个线程还是一个进程，为什么？
114. 有了进程，为什么还要线程？
115. 单核机器上写多线程程序，是否需要考虑加锁，为什么？
116. 线程需要保存那些上下文，SP、PC、EAX这些寄存器有什么作用？
117. 线程间的同步方式是怎么样的？ 具体的系统调用是怎么样的？
118. 死循环和来连接时新建线程的方法效率有点低，怎么改进？
119. 怎么唤醒被阻塞的socket线程？
120. 怎么确定当前线程是繁忙还是阻塞？
121. 假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？
122. 线程池的概念、有点、调度处理方式和保护任务队列的方式？
123. 线程池对线程的管理方式，包括初始化线程的方法、线程创建后的管理、指派任务的方式
124. 线程池的实现
125. 进程的内存结构
126. 协程相对于进程和线程有什么共同点和区别？
127. 怎么看一个进程占用了哪些端口？
128. Linux下进程与线程的区别？
129. 如果要计算0-1000000所有的质数，用单线程和多线程计算有什么区别？
130. 如果一个进程有异常该如何监控?

# 2. 已解决

## 4. 子进程和父进程共享哪些信息？
**子进程继承的来自父进程的属性：**

1. 已打开的文件描述符
2. 实际用户ID、实际组ID、有效用户ID、有效组ID
3. 附属组ID
4. 进程组ID
5. 会话ID
6. 控制终端
7. 设置用户ID标志和设置组ID标志
8. 当前工作目录
9. 根目录
10. 文件模式创建屏蔽字
11. 信号屏蔽和安排
12. 对任一打开文件描述符的执行时关闭标志
13. 环境
14. 连接的共享存储段（共享内存）
15. 存储映像
16. 父进程的用户堆栈

**子进程和父进程不一样的：**
1. fork()的返回值不同
2. 进程ID不同
3. 父进程ID不同
4. 子进程不继承父进程设置的文件锁
5. 子进程的未处理闹钟被清除
6. 子进程的未处理信号集合设置为空集
7. 父进程和子进程有独立的地址空间和PID参数
8. 子进程不继承父进程的异步输入和输出

## 7. 编译和链接的区别

### 7.1 C/C++文件执行全过程
#### 7.1.1 预编译
**预编译相当于根据预处理指令组装新的C/C++程序。经过预编译，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义与原本文件无异，只是内容上有所不同。**<br>
**预编译过程由.c/.cpp文件生成.i文件**
### 7.1.1.1 读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理
1. 将所有的“#define”删除，并且展开所有的宏定义。
2. 处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。
3. 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。

#### 7.1.1.2 删除所有注释

#### 7.1.1.3 添加行号和文件名标识
以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告是能够显示行号。

#### 7.1.1.4 保留所有的#pragma编译器指令

### 7.1.2 编译
**将预处理完的文件进行一系列词法分析、语法分析、语义检查和中间代码生成、代码优化和目标代码生成，产生相应的汇编代码文件。编译由.i文件生成.s文件。**
1. **词法分析**：将源代码文件的字符序列划分为一系列的记号，一般词法分析产生的记号有：标识符、关键字、数字、字符串、特殊符号（加号、等号）；在识别记号的同时也将标识符放好符号表、将数字、字符放入到文字表等；有一个lex程序可以实现词法扫描，会按照之前定义好的词法规则将输入的字符串分割成记号，所以编译器不需要独立的词法扫描器；
2. **语法分析**：语法分析器将对产生的记号进行语法分析，产生语法树----就是以表达式尾节点的树，一步步判断如何执行表达式操作。
3. **语义分析**：由语法阶段完成分析的并没有赋予表达式或者其他实际的意义，比如乘法、加法、减法，必须经过语义阶段才能赋予其真正的意义；
语义分析主要分为静态语义和动态语义两种；静态语义通常包括声明和类型的匹配、类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程。只要存在类型不匹配编译器会报错。经过语义分析后的语法树的所有表达式都有了类型。动态语义分析只有在运行阶段才能确定。
4. **中间代码生成**
5. **代码优化** 
6. **代码生成** 
7. **符号表管理** 
8. **将多个步骤组合成趟** 
9. **编译器构造工具** 

### 7.1.3 汇编
**将编译完成的代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。**<br>
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。目标文件由段组成。通常一个目标文件中至少有两个段： **代码段**：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。 **数据段**：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。

### 7.1.4 链接
**通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。**
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。<br>
例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。<br>
链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。<br>

## 9. 手写string的复制构造函数，拷贝构造函数，带参数构造函数，析构函数
```cpp
class String 
{
public:
    String(const char *str=NULL);//构造函数
    String(const String &other);//拷贝构造函数
    ~String(void);//析构函数
    String& operator=(const String &other);//等号操作符重载
    ShowString();
private:
    char *m_data;//指针
};

String::~String()
{
  delete[] m_data;//析构函数，释放地址空间
}
String::String(const char *str)
{
    if (str==NULL){//当初始化串不存在的时候，为m_data申请空间
       m_data = new char[1];
       *m_data='\0';
    }
    else{
        int length = strlen(str);
        m_data = new char[length+1];
        strcpy(m_data,str);
    }
}

String::String(const String &other)//拷贝构造函数
{
    int length = strlen(other.m_data);
    m_data = new char[length+1];
    strcpy(m_data,other.m_data);
}

String& String::operator=(const String &other)
{
    if (this==&other)
    {
        return *this; //检查自赋值。
    }
    delete []m_data; //释放原有的内存资源。
    int length = strlen(other.m_data);
    m_data=new char[length+1]; //分配新的内存资源。
    strcpy(m_data,other.m_data); //复制内容。
    return *this; //返回对本对象的引用。
}

//
```

```cpp
// 在检查自赋值->释放原有的内存资源->分配新的内存资源、复制内容->返回对本对象的引用这几步构成的赋值运算符函数中，程序在分配新的内存之前释放掉了m_data的内存。如果此时内存不足导致new char抛出异常，则m_data将是一个空指针，这样容易导致程序崩溃。这段代码违背了异常安全性的原则。
// String copy assignment的异常安全版本。
String& String::operator =(const String &other){
	if(this != other){
		String Strtemp(other);

		char *temp = Strtemp.m_data;
		Strtemp.m_data = m_data;
		m_data = temp;
	}
	return *this;
}
```

# 41. rand5(1-5的随机整数生成函数)实现rand7(1-7的随机整数生成函数)
## 41.1 已知rand5()产生1-5的随机整数，利用该函数生成函数rand7()产生1-7的随机整数。
1. rand5()等概率生成1、2、3、4、5。
2. 5 \* (rand5() - 1)等概率生成0、5、10、15、20。
3. 5 \* (rand5() - 1) + rand5() 等概率生成1-25。出现1-25中任一结果只有一种特定的两个rand()组合，故等概率。
4. 利用rand25()生成rand7()。

```cpp
#include <climits>
int rand7(){
	int x = INT_MAX;
	while(x > 7){
		x = 5*(rand5() - 1) + rand5();
	}
	return x;
}
```
```cpp
#include <climits>
int rand7(){
	int x = INT_MAX;
	while(x > 21){
		x = 5*(rand5() - 1) + rand5();
	}
	return x%7 + 1;
}
```
## 20. std::thread和操作系统级别的线程有什么区别？

## 41.2 已知randA()产生1-A的随机整数，利用该函数生成函数randB()产生1-B的随机整数。
1. 如果A > B，进入步骤2；否则构造randA2 = A * (randA – 1) + randA， 表示生成1到A2 随机数的函数。如果A2 仍小于B，继教构造 randA3 = A * (randA2 - 1) + randA…直到Ak > B，这时我们得到randAk , 我们记为randA。
2. 步骤1中得到了randA(可能是randa或randAk )，其中A > B，可以用以下代码构造RandB：

```cpp
#include <climits>
int randB(){
	int x = INT_MAX;
	while(x > B*(Ak/B)){
		x = randAk();
	}
	return x%B + 1;
}
```

## 59. 迭代器的++it和it++哪个好？
**++it好。**两种方式iterator遍历的次数是相同的，但在STL中效率不同。**++it返回引用，it++返回一个临时对象。**因为iterator是类模板，使用 it++这种形式要返回一个无用的临时对象，而it++是重载，所以无法对其进行优化，所以每遍历一个元素，就相当于创建并销毁了一个无用的临时对象。

## 95. 手写线程安全的单例模式
```cpp
//双检查锁
class Singleton
{
private:
	static Singleton* m_Instance;
	Singleton(){}
	Singleton(const Singleton& other);
	Singleton& operator=(const Singleton&);
public:
	static Singleton* GetInstance(){
		if(m_Instance == nullptr){ //第一次检查
			Lock lock; //加锁
			if(m_Instance == nullptr){ //第二次检查
				m_Instance = new Singleton();
			}
		}
		return m_Instance;
	}
}

//双检查锁两次检查的意义：
//第一次检查：第一次检查负责检查是不是对m_Instance的读操作，如果m_Instance此时已经被创建(非nullptr)，则多线程只读m_Instance不需要加锁。
//第二次检查：如果没有第二次检查，则在m_Instance未完全创建时，凡是通过第一次检查的线程均能获得lock，可能有多个m_Instance被创建。
```


## 106. 智能指针是否存在内存泄露的情况？
智能指针也可能存在内存泄漏的情况，比如当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。
为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。
**将造成循环引用的其中一个shared_ptr用weak_ptr替换。**