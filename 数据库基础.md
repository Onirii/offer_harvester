- mysql 有哪些存储引擎，区别
- MySQL 的索引 底层，为什么用B+树 不用红黑树；与哈希的区别
- 事务的隔离级别：幻读、脏读、不可重复读
- 复制原理：主从复制，如何实现的
- 数据库的优化思路
- 数据库的事务，ACID
- 数据库的三大范式
- 数据库的mvcc
- 数据库的视图
- 锁粒度： 表级锁 VS 行级锁
- group by VS
- SQL 的约束：
- mysql 日志
- 连接池
- 查询优化
**多版本并发控制：MVCC**
- 乐观锁与悲观锁
- SQL 语句基础


## SQL 语言的功能有哪些？
SQL 是结构化查询语句（Structured Query Language）的缩写，其功能包括数据查询、数据操纵、数据定义和数据控制 4 个部分。

- 数据查询是数据库中最常见的操作，通过 select 语句可以得到所需的信息。
- SQL 语言的数据操纵语句（Data Manipulation Language，DML）主要包括插入数据、修改数据以及删除数据 3 种语句。
- SQL 语言使用数据定义语言（Data Definition Language，DDL）实现数据定义功能，可对数据库用户、基本表、视图、索引进行定义和撤销。
- 数据控制语句（Data Control Language， DCL）用于对数据库进行统一的控制管理，保证数据在多用户共享的情况下能够安全。

## 数据库的事务，ACID
事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 	Rollback 进行回滚。


### 原子性（Atomicity）
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

### 一致性（Consistency）
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

### 隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。

### 持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发送崩溃，事务执行的结果也不能丢失。

使用重做日志来保证持久性。

P.S 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：
- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下， 多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。
![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/417bc315-4409-48c6-83e0-59e8d405429e.jpg)

**AUTOCOMMIT**
MySQL 默认采用自动提交模式。也就是说，如果不显式使用 `START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。

---
- **Atomicity（原子性）**：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
- **Consistency（一致性）**：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
- **Isolation（隔离性）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **Durability（持久性）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。


## 组合查询（UNION、UNION ALL）
使用 `UNION` 来组合两个查询，如果第一个查询返回	 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。

每个查询必须包含相同的列、表达式和聚集函数。

默认会去除相同行，如果需要保留相同行，使用 `UNION ALL`。

只能包含一个 `ORDER BY` 子句，并且必须位于语句的最后。

---
`UNION` 在进行表求并集后会去掉重复的元素，所以会对所产生的结果集进行排序运算，删除重复的记录再返回结果。

`UNION ALL` 则只是简单地将两个结果集合并后就返回结果。因此，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据。

在执行查询操作时，`UNION ALL` 要比`UNION`快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据，那么最好使用 `UNION ALL`。


## 视图
视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。

对视图的操作和对普通表的操作一样。

视图具有如下好处：
- 简化复杂的 SQL 操作，比如复杂的连接；
- 只使用实际表的一部分数据；
- 通过只给用户访问视图的权限，保证数据安全性；
- 更改数据格式和表示。

## 存储过程
存储过程可以看成对一系列 SQL 操作的批处理。

使用存储过程的好处：
- 代码封装，保证了一定的安全性；
- 代码复用；
- 由于是预先编译，因此具有很高的性能；

命令行中创建存储过程需要自定义分割符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误地把这部分分号当成是结束符，造成语法错误。

包含 in、out 和 inout 三种参数。

给变量赋值都需要用 select into 语句。

每次只能给一个变量赋值，不支持集合的操作。

## 游标
在存储过程中使用游标可以对一个结果集进行移动遍历。

游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。

使用游标的四个步骤：
1. 声明游标，这个过程没有实际检索出数据；
2. 打开游标；
3. 取出数据；
4. 关闭游标

## 触发器
触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。

触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另一张表中。

MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。

---


## 三大范式
范式理论是为了解决以上提到的四种异常d。

高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

**第一范式（1NF）**
属性不可分。

**第二范式（2NF）**
每个非主属性完全函数依赖于键码。

可以通过分解来满足。

**第三范式（3NF）**
非主属性不传递函数依赖于键码。

---
- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
- 第三范式：任何非主属性不依赖于其它非主属性。


## 乐观锁与悲观锁
**悲观锁**
- 优点：悲观锁利用数据库中的锁机制来实现数据变化的顺序执行，这是最有效的办法。
- 缺点：一个事务用悲观锁对数据加锁之后，其他的事务将不能对加锁的数据进行除了查询以外的所有操作，如果该事务执行时间很长，那么其他事务将一直等待，那势必影响我们想系统的吞吐量。

**乐观锁**
优点：乐观锁不在数据库上加锁，任何事务都可以对数据进行操作，在更新时才进行校验，这样就避免了悲观锁造成的吞吐量下降的劣势。
缺点：乐观锁因为是通过我们人为实现的，它仅仅适用于我们自己业务中，如果有外来事务插入，那么就可能发生错误。

应用场景：
- 悲观锁：因为悲观锁会影响系统吞吐的性能，所以适合应用在写为居多的场景下。
- 乐观锁：因为乐观锁就是为了避免悲观锁的弊端出现的，所以适合应用在读为居多的场景下。

---
- 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。
- 悲观锁：每次去数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。

数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。


## drop、delete与truncate的区别
三者都表示删除，但是三者有一些差别：

/ | delete | truncate | drop
-- | -- | -- | --
类型 | 属于 DML | 属于 DDL | 属于 DDL
回滚 | 可回滚 | 不可回滚 | 不可回滚
删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 | 从数据库中删除表，所有的数据行，索引和权限也会被删除
删除速度 | 删除速度慢，需要逐行删除 | 删除速度快 | 删除速度快

因此，不再需要一张表的时候，用 drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。



## 数据库的事务隔离
MySQL 的事务隔离是在 MySQL.ini 配置文件里添加的，在文件的最后添加：
> transaction-isolation = REPEATABLE-READ

可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。
- READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可以被其他事务读取（会出现幻读、脏读、不可重复读）。
- READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。
- REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致的，禁止读取到别的事务未提交的数据（会造成幻读）。
- SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。

**脏读**
表示一个事务能够读取另一事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

**不可重复读**
是指在一个事务内，多次读同一数据。

**幻读**
指同一事务内查询返回的结果集不一样。比如同一事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

## 连接：内连接、外连接
- 内连接关键字：`inner join`；
- 左连接关键字：`left join`
- 右连接关键字：`right join`

内连接是把匹配的关联数据显示出来的；左连接是左表的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。

---
**内连接**，也被称为自然连接，只有两个表相匹配的行才能在结果集中出现。返回的结果集选取了两个表中所匹配的数据，舍弃了不匹配的数据。由于内连接是从结果表中删除与其他连接表中没有匹配的所有行，所以内连接可能会造成信息的丢失。内连接的语法如下：
> select filedlist from table1 [inner] join table2 on tabel.column = table2.column

内连接是保证两个表中的所有行都满足连接条件，而外连接则不然。外连接不仅包含符合连接条件的行，而且还包括左表(左外连接时)、右表(右外连接时)或两个边界表(全外连接)中的所有数据行。

SQL 的外连接共有 3 种类型：左外连接（关键字为 LEFT OUTER JOIN）、右外连接（关键字为 RIGHT OUTER JOIN）和全外连接（关键字为 FULL OUTER JOIN）。

外连接的用法和内连接一样，只是将 INNER JOIN 关键字替换为相应的外连接关键字即可。

内连接只显示符合连接条件的记录，外连接除了显示符合连接条件的记录外，还显示表中的记录，例如，如果使用左外连接，还显示左表中的记录。


