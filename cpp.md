# 1. static关键字
**static被用来控制变量的存储方式和可见性。**

## 1.1 引入缘由
在函数内部定义的变量、当程序执行到定义处时，编译器为变量在**栈**上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉。为了让变量的值保存至下一次调用时，最容易想到的方法是将其定义为全局变量，但是定义为全局变量破坏了此变量的访问范围**使得在此函数中定义的变量，不仅仅只受此函数控制**, **static**关键字可以很好地解决这个问题。
另外，在C++中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。

## 1.2 静态数据的存储
全局(静态)存储区分为DATA段和BSS段。DATA段(全局初始化区)存放初始化的全局变量和静态变量，BSS段(全局未初始化区)存放未初始化的全局变量和静态变量，程序运行结束时自动释放。<br>其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
在C++中static的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。<br>这样，它的空间分配有三个可能的地方:

1. 是作为类的外部接口的头文件，那里有类声明；
2. 是类定义的内部实现，那里有类的成员函数定义；
3. 是应用程序的main()函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义(只能声明数据成员)。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。<br>
优势：可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

## 1.3 在C/C++中static关键字的作用
1. 在修饰变量的时候，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
2. static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。
3. static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
4. 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
5. 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

## 1.4 静态全局变量的特点
1. 静态变量都在全局数据区分配内存；
2. 未经初始化的静态全局变量会被程序自动初始化为0(在函数体内声明的变量的自动初始化值是随机的，在函数体外被声明的自动变量也会被初始化为0)；
3. 静态全局变量在声明它的整个文件里都是可见的，在此文件外是不可见的。(在其他文件中可以定义相同名字的变量，不会发生冲突)。

## 1.5 静态局部变量的特点
1. 该变量在全局数据区分配内存；
2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；
4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

## 1.6 全局变量和静态全局变量的区别
1. 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
2. 全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

# 2. C++中static的使用
## 2.1 静态数据成员
1. 静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。
2. 静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。
3. 静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0。
4. 静态数据成员既可以通过对象名引用，也可以通过类名引用。

## 2.2 静态函数成员
1. 静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
2. 非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
3. 静态成员函数主要用来访问静态数据成员而不能访问非静态成员。

# 3. const关键字
## 3.1 const关键字的作用
1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针和指针常量；<br>
指针本身是一个对象，它又可以指向另一个对象。因此const修饰指针时，指针本身是不是常量和指针指向的对象是不是常量是两个独立的问题。<br>
**对于一般的变量来说，用const修饰时没有顶层和底层之分，只有指针这种复合类型的基本变量，才有这种区别。**<br>
**顶层const表示指针本身是一个常量，底层const表示指针指向的对象是一个常量。**<br>
顶层const，指针常量，表示指针本身是一个不可修改的常量。<br>
底层const, 常量指针，表示指针所指向的值为一个常量。<br>
出现在**\***右边的const表示顶层const，出现在**\***左边的const表示底层const。<br>
3. 常量引用，经常用于形参类型，既避免了拷贝，又避免了函数对参数值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

## 3.2 用const来修饰成员函数的目的是什么？
1. 类的成员函数后面加const，表明这个函数不会对类对象的非静态数据成员做任何修改。在设计类时，一个原则就是对于不改变数据成员的成员函数后面都要加const，而对于改变数据成员的成员函数不能用const修饰；
2. 常量对象可以调用被const修饰的成员函数，而不能调用非const修饰的成员函数。

## 3.3 

# 4. C++中指针和引用的区别
**是否可以为空和是否可以被重新赋值**
## 4.1 非空区别
在任何情况下都不能使用指向空值的引用，但指针可以不指向任何对象。不存在指向空值的引用意味着使用引用的代码效率要比使用指针的高。
## 4.2 合法性区别
在使用引用之前不需要测试它的合法性，相反，指针总应该被测试，以防止其为空。
## 4.3 可修改区别
指针可以被重新赋值以指向另一个不同的对象，单引用总是指向在初始化时被指定的对象，以后不能改变，但是引用指向对象的内容可以改变。
## 4.4 应用区别
考虑到存在不指向任何对象的可能性或者能够在不同时刻指向不同对象时应该使用指针。总是指向一个对象而且只能指向一个对象时应该使用引用。

# 5. 数组和指针的区别
1. 数组用来保存数据，指针用来保存数据的地址；
2. 数组中的数据可以直接访问，指针所指向的数据需要间接访问，即首先取得指针的内容，把它作为地址，然后再从这个地址中提取数据；
3. 数组通常用于存储固定数目且数据类型相同的元素，指针通常用于动态数据结构；
4. 数组通常隐式分配与删除，指针相关的函数为malloc()和free();
5. 数组自身即为数据名， 指针通常指向匿名数据。

### 对于一个数组**char a[10]**而言，如果访问a[i]，步骤是：
1. 将a的地址读入寄存器，由于a其实就是一个别名，所以a的地址本身就是a[0]的地址；
2. 根据类型计算并添加偏移，得到目标地址；
3. 访问内存得到a[i]。

### 而如果声明是**char \*a**，访问a[i]，其步骤是：
1. 将a的地址读入寄存器，a是一个指针，指向a[0]的地址；
2. 访问内存读取a的值，得到a[0]的地址；
3. 根据类型计算并添加偏移量，得到目标地址；
4. 访问内存得到a[i]。

# 6. C++中的野指针
**野指针即指向不可用内存区域的指针。**<br>
野指针不是NULL指针，是指向“垃圾”内存的指针，如果对野指针进行操作，将会使程序发生不可预知的错误，甚至可能直接引起程序崩溃。
1. 指针变量没有初始化；<br>
指针变量在创建时应当被初始化，要么将其设置为NULL，要么让它指向合法的内存。
2. 指针指向的内存被释放了，但是指针本身没有被置NULL；<br>
对于堆内存操作，我们分配了一些空间（使用malloc函数、calloc函数或new操作符），使用完后释放（使用free函数或delete操作符），在指针指向的内存被释放后，应该将指针置为NULL。
3. 指针超过了变量的作用范围。<br>
即在变量的作用范围之外使用了指向变量地址的指针。这一般发生在将调用函数中的局部变量的地址传出来。这点容易被忽略，虽然代码是很可能可以执行无误，然而却是极其危险的。局部变量的作用范围虽然已经结束，内存已经被释放，然而地址值仍是可用的，不过随时都可能被内存管理分配给其他变量。

# 7. C++中的智能指针

# 8. this指针
1. this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用还成员函数的那个对象；
2. 当对一个对象调用成员函数时，编译程序现将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用this指针；
3. this 指针被隐含地声明为： ClassName \*const this, 这意味着this指针为常量指针，不能改变其内容，即不能给this指针赋值，在ClassName类的const成员函数中，this指针类型为：const ClassName\* const,这说明此时this指针所指的对象不可修改（即不能对这种对象的数据成员进行赋值操作）；
4. this并不是一个常规变量，而是个右值，所以不能取得this的地址；
5. 在下列场景中，经常需要显式引用this指针：<br>
	1. 实现对对象的链式引用；
	2. 为避免对同一对象进行赋值操作；
	3. 在实现一些数据结构时。

# 9. inline 内联函数
## 9.1 内联函数的特征
1. 相当于把内联函数里面的内容写在了调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，但内联比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

## 9.2 编译器对 inline 函数的处理步骤
1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

## 9.3 inline 内联函数的优缺点
### 9.3.1 优点：
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

### 9.3.2 缺点
1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。