# 1. 若干关键字
## 1.1 static关键字
**static被用来控制变量的存储方式和可见性。**

### 1.1.1 引入缘由
在函数内部定义的变量、当程序执行到定义处时，编译器为变量在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉。为了让变量的值保存至下一次调用时，最容易想到的方法是将其定义为全局变量，但是定义为全局变量破坏了此变量的访问范围**使得在此函数中定义的变量，不仅仅只受此函数控制**, **static**关键字可以很好地解决这个问题。
另外，在C++中，需要一个数据对象为**整个类而非某个对象**服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。

### 1.1.2 静态数据的存储
全局(静态)存储区分为DATA段和BSS段。DATA段(全局初始化区)存放初始化的全局变量和静态变量，BSS段(全局未初始化区)存放未初始化的全局变量和静态变量，程序运行结束时自动释放。<br>其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
在**C++中static的内部实现机制**：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。<br>这样，它的空间分配有三个可能的地方:

1. 是作为类的外部接口的头文件，那里有类声明；
2. 是类定义的内部实现，那里有类的成员函数定义；
3. 是应用程序的main()函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义(只能声明数据成员)。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。<br>
优势：可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

### 1.1.3 在C/C++中static关键字的作用
1. 在修饰变量的时候，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
2. static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。
3. static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存，初始化的时候自动初始化为0。
4. 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
5. 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

### 1.1.4 静态全局变量的特点
1. 静态变量都在全局数据区分配内存；
2. 未经初始化的静态全局变量会被程序自动初始化为0(在函数体内声明的变量的自动初始化值是随机的，在函数体外被声明的变量也会被自动初始化为0)；
3. 静态全局变量在声明它的整个文件里都是可见的，在此文件外是不可见的。(在其他文件中可以定义相同名字的变量，不会发生冲突)。

### 1.1.5 静态局部变量的特点
1. 该变量在全局数据区分配内存；
2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；
4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

### 1.1.6 全局变量和静态全局变量的区别
1. 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
2. 全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

### 1.1.7 静态数据成员
1. 静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。
2. 静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。
3. 静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0。
4. 静态数据成员既可以通过对象名引用，也可以通过类名引用。

### 1.1.8 静态函数成员
1. 静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
2. 非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
3. 静态成员函数主要用来访问静态数据成员而不能访问非静态成员。

### 1.1.9 关键字static的作用是什么？
1. 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值。
2. 在模块内的static全局变量可以被模块内的所有函数访问，但不能被模块外其他函数访问。
3. 在模块内的static函数只可以被这一模块的其他函数调用，这个函数的适用范围被限制在声明它的模块内。
4. 在类中的static成员变量属于整个类所有，对类的所有对象只有一份复制。
5. 在类中的static成员函数属于整个类所有，这个函数不接受this指针，因而只能访问类的static成员变量。

### 1.1.10 为什么静态成员不能在类内初始化？
**静态成员属于类作用域，但不属于类对象，它的生命周期和普通的静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放，所以不能在类的构造函数中进行初始化。**
因为静态成员属于整个类，而不是属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。所以在类内只有静态成员的声明，在类外定义和初始化是保证static成员变量只被定义一次的方法。


  
## 1.2 explicit关键字
1. explicit关键字只需用于类内的**单参数构造函数**前面，防止类构造函数的隐式自动转换；
2. 对于无参数的构造函数和多参数的构造函数总是显式调用，这种情况在构造函数前加explicit没有意义。

## 1.2 volatile关键字
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

## 1.3 const关键字

### 1.3.1 const关键字的作用

#### 1.3.1.1 修饰普通变量
说明该变量的值不可以被改变

#### 1.3.1.2 修饰指针
分为指向常量的指针和指针常量；<br>
指针本身是一个对象，它又可以指向另一个对象。因此const修饰指针时，指针本身是不是常量和指针指向的对象是不是常量是两个**独立**的问题。<br>
**对于一般的变量来说，用const修饰时没有顶层和底层之分，只有指针这种复合类型的基本变量，才有这种区别。**<br>
**顶层const表示指针本身是一个常量，底层const表示指针指向的对象是一个常量。**<br>
顶层const，指针常量，表示指针本身是一个不可修改的常量。<br>
底层const, 常量指针，表示指针所指向的值为一个常量。<br>
出现在**\***右边的const表示顶层const，出现在**\***左边的const表示底层const。<br>

#### 1.3.1.3 修饰函数参数
const修饰参数的值表示在函数体中不能修改此参数的值(包括参数本身的值或者参数本身的值)。<br>
1. void function(const int Var);     //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用)。
2. void function(const char* Var);   //参数指针所指内容为常量不可变。
3. void function(char* const Var);   //参数指针本身为常量不可变(无意义，var本身也是通过传值的形式赋值的)。
4. void function(const Class& Var);  //引用参数在函数内不可以改变。
参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不必用const修饰。

#### 1.3.1.4 修饰类对象/对象指针/对象引用
1. const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改，对于对象指针和对象引用也是一样。
2. const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。

#### 1.3.1.5 修饰数据成员
1. const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const数据成员的值是什么。
2. const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，可以用类中的枚举常量来实现。

#### 1.3.1.6 修饰成员函数
一般把const写在成员函数的最后表示const修饰类的成员函数，用const修饰的成员函数不能改变对象的成员变量。
说明该成员函数内不能修改成员变量。

#### 1.3.1.7 修饰成员函数的返回值
１. 一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回const对象，或返回const对象的引用，则返回值具有const属性，返回实例只能访问类中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。 
2. 如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针所指的内容）不能被修改，该返回值只能被赋给加const 修饰的同类型指针。
3. 函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。

### 1.3.2 用const来修饰成员函数的目的是什么？
1. 类的成员函数后面加const，表明这个函数不会对类对象的非静态数据成员做任何修改。在设计类时，一个原则就是对于不改变数据成员的成员函数后面都要加const，而对于改变数据成员的成员函数不能用const修饰；
2. 常量对象可以调用被const修饰的成员函数，而不能调用非const修饰的成员函数。

### 1.3.3 const常量和define宏定义有什么区别？
1. 编译器处理方式不同： define宏是在预处理阶段展开，const常量是编译运行阶段使用。
2. 类型和安全检查不同： define宏没有类型，不做任何类型检查，仅仅是展开，const常量有具体的类型，在编译阶段会执行类型检查。
3. 存储方式不同： define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存，const常量会在内存中分配(可以是堆中也可以是栈中)。

### 1.3.4 不同类型的类数据成员的声明、定义、初始化


## 1.4 goto关键字
goto语句允许把控制无条件转移到同一函数内的被标记的语句。<br>
goto 语句一个很好的作用是**退出深嵌套程序**。

## 1.5 sizeof关键字
由于C++每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用sizeof运算符获得该数据类型占用的字节数。

### 1.5.1 数据对齐(Data Alignment)
1. CPU的优化规则大致原则是：对于n字节的元素(n=2,4,8,...)，它的首地址能被n整除，才能获得最好的性能。
2. 数据对齐是指数据所在的内存地址必须是该数据长度的整数倍。
3. 结构体的数据对齐：在默认情况下，为了方便对结构体内元素的访问和管理，当结构体内的元素的长度都小于处理器位数的时候，便以结构体里面最长的数据元素为对齐单位，也就是说，结构体的长度一定是最长的数据元素的整数倍。如果结构体内存在长度大于处理器位数的元素，那么就以处理器的位数为对齐单位。但是结构体内类型相同的连续元素和数组一样，将在连续的空间内。

### 1.5.2 sizeof和strlen之间的区别
1. sizeof操作符的结果是size_t，它在头文件中的typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。
2. sizeof是运算符，strlen是函数。
3. sizeof可以用类型/函数做参数，strlen只能用char\*做参数，且必须是以“\0”结尾的。
4. 数组做sizeof参数时不退化，传递给strlen就退化为指针。
5. 大部分编译程序在编译的时候就把sizeof计算过了，是类型或是变量的长度。这就是sizeof可以用来定义数组维度的原因。
6. strlen的结果要在运行时才能计算出来，用来计算字符串的长度，而不是类型所占内存的大小。
7. sizeof后如果是类型必须加括号，如果是变量名可以不加括号，这是因为sizeof是个操作符而不是函数。
8. 当使用了一个结构类型或者变量时，sizeof返回实际的大小。当使用一静态的空间数组时，sizeof返回全部数组的尺寸。sizeof操作符不能返回被动态分配的数组或者外部数组的尺寸。
9. 数组作为参数传递给函数时传递的是指针而不是数组，传递的是数组的首地址。在C++里传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小。
10. 计算结构变量的大小就必须讨论数据对齐问题。
11. sizeof操作符不能用于函数类型、不完全类型或者位字段。不完全类型是指具有位置存储数据大小的数据类型，如未知存储大小的数组类型、未知内容的结构或者联合类型、void类型。

### 1.5.3 sizeof的使用场合
1. sizeof操作符的一个主要用途是与存储分配和I/O系统那样的例程进行通信。
2. 获取某种类型的对象在内存中所占的单元字节。
3. 在动态分配一对象时，sizeof可以让系统知道要分配多少内存。
4. 便于一些类型的扩充，在Windows中有很多结构类型就有一个专用的字段用来存放该类型的字节大小。
5. 由于操作数的字节数在实现时可能出现变化，建议在涉及操作数字节大小时用sizeof代替常量计算。
6. 如果操作数是函数中的数组形参或者函数类型的形参，sizeof给出其指针的大小。

## 1.6 register关键字
在一般情况下，变量(包括静态存储方式和动态存储方式)的值是放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到CPU中的运算器。经过运算器进行运算，如果需要存数，再从运算器将数据送到CPU存放。<br>
如果有一些变量使用频繁（例如执行上千次的循环，每一次循环都是需要引用某一个局部变量），则存取变量的值需要花费很多的时间。为了提高效率，C++允许将局部变量的值存放在cpu中的寄存器中，需要用的时直接从寄存器取出参加运算，不必再到内存中去取值。由于对寄存器的存取速度远远高于对内存的存取速度，因此这样做可以提高执行效率。这种变量就叫做**寄存器变量**，用关键字register作声明。

### 1.6.1 寄存器变量注意事项
1. 首先，register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
2. 其次，因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
3. 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。
4. 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。

## 1.7 asm关键字
允许在 C++ 程序中嵌入汇编代码。

## 1.8 enum关键字
枚举类型

## 1.9 try...throw...catch关键字
**C++异常处理**<br>
异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。<br>
1. throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。
2. catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。
3. try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。

## 1.10 typedef关键字
类型定义 **typedef 类型 定义名**<br>
类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。
## 1.11 union关键字
union(联合)，类似于enum。不同的是enum实质上是int类型的，而union可以用于所有类型，并且其占用空间是随着实际类型大小变化的。

## 1.12 this关键字
对象的存储空间是数据成员所占的空间，成员函数的代码存储在对象的空间之外。不同的对象调用同一函数的代码段。在每个成员函数中都有一个名字为this的指向本类对象的指针。this指针是当前被调函数所在对象的起始地址，通过这个地址可以访问该对象的数据成员和成员函数。在类中写成员的地方，都可以写成this->(成员名)。

## 1.13 typeid关键字
如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作数返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。

## 1.14 mutable关键字
mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能由于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。

## 1.15 

# 2. C++中指针和引用的区别
**是否可以为空和是否可以被重新赋值**
## 2.1 非空区别
在任何情况下都不能使用指向空值的引用，但指针可以不指向任何对象。不存在指向空值的引用意味着使用引用的代码效率要比使用指针的高。
## 2.2 合法性区别
在使用引用之前不需要测试它的合法性，相反，指针总应该被测试，以防止其为空。
## 2.3 可修改区别
指针可以被重新赋值以指向另一个不同的对象，单引用总是指向在初始化时被指定的对象，以后不能改变，但是引用指向对象的内容可以改变。
## 2.4 应用区别
考虑到存在不指向任何对象的可能性或者能够在不同时刻指向不同对象时应该使用指针。总是指向一个对象而且只能指向一个对象时应该使用引用。

# 3. 数组和指针的区别
1. 数组用来保存数据，指针用来保存数据的地址；
2. 数组中的数据可以直接访问，指针所指向的数据需要间接访问，即首先取得指针的内容，把它作为地址，然后再从这个地址中提取数据；
3. 数组通常用于存储固定数目且数据类型相同的元素，指针通常用于动态数据结构；
4. 数组通常隐式分配与删除，指针相关的函数为malloc()和free();
5. 数组自身即为数据名，指针通常指向匿名数据。

### 对于一个数组**char a[10]**而言，如果访问a[i]，步骤是：
1. 将a的地址读入寄存器，由于a其实就是一个别名，所以a的地址本身就是a[0]的地址；
2. 根据类型计算并添加偏移，得到目标地址；
3. 访问内存得到a[i]。

### 而如果声明是**char \*a**，访问a[i]，其步骤是：
1. 将a的地址读入寄存器，a是一个指针，指向a[0]的地址；
2. 访问内存读取a的值，得到a[0]的地址；
3. 根据类型计算并添加偏移量，得到目标地址；
4. 访问内存得到a[i]。

# 4. C++中的野指针
**野指针即指向不可用内存区域的指针。**野指针不是nullptr指针，是指向“垃圾”内存的指针，如果对野指针进行操作，将会使程序发生不可预知的错误，甚至可能直接引起程序崩溃。
1. **指针变量没有初始化** 指针变量在创建时应当被初始化，要么将其设置为nullptr，要么让它指向合法的内存。
2. **指针指向的内存被释放了，但是指针本身没有被置nullptr** 对于堆内存操作，我们分配了一些空间（使用malloc函数、calloc函数或new操作符），使用完后释放（使用free函数或delete操作符），在指针指向的内存被释放后，应该将指针置为nullptr。
3. **指针超过了变量的作用范围。** 即在变量的作用范围之外使用了指向变量地址的指针。这一般发生在将调用函数中的局部变量的地址传出来。这点容易被忽略，虽然代码是很可能可以执行无误，然而却是极其危险的。局部变量的作用范围虽然已经结束，内存已经被释放，然而地址值仍是可用的，不过随时都可能被内存管理分配给其他变量。

# 5. C++中的智能指针
## 5.1 直接内存管理、内存泄漏
1. 对象的生命周期
2. 直接内存管理 new/delete new[]/delete[]
3. new一个内置类型，未赋初值情况下其值未定义。
4. new一个类类型，未赋初值会调用其默认构造函数。
5. 值初始化，用()来初始化。 对于类对象来说，是否是值初始化没有区别，都是调用类的构造函数。对于整型对象来说，new int()初始化为0， new int初始化为未定义。 new一个对象时，尽量进行值初始化。
6. new 与 auto 配合使用。
```cpp
string *stringName0 = new string(3, 'A');
auto stringName1 = new auto(stringName1); //stringName1的类型为string** 指向指针的指针。
// stringName0 与 stringName1指向同一strings对象。
```
7. const对象的动态分配。
8. new与delete
	1. new与delete成对使用，delete的作用是回收用new分配的内存(释放内存)，不是new出来的内存，不能用delete来释放。
	2. 一个动态对象只能delete一次。
	3. 同一段内存的动态对象只能delete一个。
9. 注意事项总结：
	1. new创建的动态对象一定要delete，否则会引起内存泄漏。
	2. delete后的内存不能继续使用。
	3. delete后的指针应该赋nullptr。
	4. 同一内存释放多次会产生异常。

## 5.2 new与delete
### 5.2.1 new与delete
1. 是关键字/运算符，不是函数。
2. new/delete与malloc/free
	1. new一个类对象是，会调用其构造函数，delete一个类对象时，对调用其析构函数。
	2. new/delete具备对堆上所分配内存进行初始化/释放的能力，而malloc/free不具备这种能力。

### 5.2.2 operator new() 与 operator delete()
1. operator new() 与 operator delete()是函数。
2. new操作符先分配内存(通过调用 operator new())，然后调用构造函数来初始化内存。
3. delete操作符先调用析构函数，然后释放内存(通过调用 operator delete())。

### 5.2.3 基本new如何记录分配的内存大小供delete使用
1. 不同编译器内部有不同的new实现方式。
	1. new内部有对其所分配内存大小的记录机制，记录了分配出去多少内存。

### 5.2.4 申请和释放一个数组
1. 为什么动态给类类型分配内存对象**数组**时会多出来4个字节，而给内置类型(比如int)动态分配内存内存对象**数组**时没有多出来4个字节？
	1. 动态分配类类型对象数组时，需要额外的4字节来存储分配对象的数目，以供delete[]释放内存时确定需要执行析构函数的次数。而对内置类型没有这个必要。
	2. 内置类型不需要调用析构函数，所以没有额外的记录机制。
	3. 如果一个对象使用new[]来分配内存，却可以用单独的delete(而不是delete[])来释放内存。这个对象需要满足的条件时：要么是内置类型，要么是无自定义析构函数的类类型。

2. 对于动态分配的有自定义析构函数的类对象数组，为什么使用delete来释放内存就会产生异常？
	1. 单独的delete会先调用一次类的析构函数。
	2. 调用operator delete()，真正释放内存，因为记录机制的存在，会导致析构函数无法找到正确的待析构类对象的内存地址，最终导致内存异常。

### 5.2.5 new/delete、new[]/delete[]要配对使用

### 5.2.6 智能指针概述
1. 智能指针是对裸指针的包装，智能指针能自动释放所指向对象的内存。

### 5.2.7 shared_ptr基础
1. **共享所有权** 动态对象不是被一个shared_ptr拥有，而是被多个shared_ptr的相互协作中被使用。 shared_ptr有额外开销。
2. 工作原理：**引用计数**，每个shared_ptr的拷贝都指向相同的内存，所以，只有最后一个指向动态对象的shared_ptr指针不需要指向该对象时，那么这个shared_ptr才会去析构所指向的类对象。
3. **格式** shared_ptr<type> ptrName(new type(...)); 不可以进行隐式类型转换，必须是直接初始化形式。
4. 智能指针和裸指针不要交叉使用。

#### 5.2.7.1 最后一个指向内存对象的shared_ptr在什么情况下会释放该对象？
1. 此shared_ptr被析构的时候。
2. 此shared_ptr改为指向其他对象。

#### 5.2.7.2  make_shared()函数
1. 标准库的函数模板，可以安全、高效地分配和使用shared_ptr，能够在动态内存中分配并初始化一个对象，然后返回指向此对象的shared_ptr。
	1. shared_ptr<type> ptrName = make_shared<type>(...);

#### 5.2.7.3 shared_ptr引用计数的增加和减少
1. 引用计数的增加
	1. 每个shared_ptr的拷贝都指向相同的内存，所以，只有最后一个指向动态对象的shared_ptr指针不需要指向该对象时，那么这个share_ptr才会去析构所指向的类对象。
	2. 每个shared_ptr都会记录有多少个其他的shared_ptr指向相同对象。
	3. 在如下情况下，所有指向这个对象的shared_ptr的引用计数都会增加1：
		1. 用一个shared_ptr初始化另一个shared_ptr
		2. 把智能指针当做实参往参数(值传递)里面传递(这种情况为临时增加)，引用传值不会增加。
		3. shared_ptr作为函数的返回值。(需要将函数返回对象传递给一个shared_ptr，否则就是临时增加(临时的shared_ptr生命周期结束))
2. 引用计数的减少
	1. 给shared_ptr赋予新值，使该shared_ptr指向一个新对象。
	2. 局部shared_ptr离开其作用域。
	3. 当一个shared_ptr的引用计数从1变成0，则它会自动释放自己所管理的对象的内存。

#### 5.2.7.4 shared_ptr的常用操作
1. use_count()  返回指向某个对象的智能指针数目。

2. unique()  是否该shared_ptr(不能为空)独占其指向的对象(true/false)。

3. reset() 重置
	1. reset()不带参数，ptrName.reset();
		1. 如果ptrName独占其所指向的对象，则释放其所指向的对象，并将ptrName置空。
		2. 如果ptrName没有独占其所指向的对象，则指向该对象的引用计数会减一，并将ptrName置空。

	2. reset()带参数时，(参数一般为一个new出来的新指针) ptrName.reset();
		1. 如果ptrName独占其所指向的对象，则释放其所指向的对象，并让ptrName指向新对象。
		2. 如果ptrName没有独占其所指向的对象，则指向该对象的引用计数会减一，并让ptrName指向新对象。
	3. 空指针也可以通过reset()重新初始化。
4. \*解引用 获得ptrName指向的对象

5. get() 返回ptrName中保存的指针(裸指针)(有些函数需要的参数是一个内置的裸指针而不是智能指针)

6. swap() 交换两个智能指针指向的对象

7. =nullptr ptrName = nullptr;
	1. 将所指向对象的引用计数减一，如果引用计数变为0，则释放智能指针所指向的对象。
	2. 将智能指针置空。

8. 智能指针名字作为判断条件

9. 指定删除器以及数组问题
	1. **指定删除器** 智能指针在一定时机帮助删除其所指向的对象，将delete运算符作为默认的资源析构方式。那就可以指定自定义的删除器代替系统提供的默认删除器，当智能指针需要删除其所指向的对象时，编译器就会调用自定义的删除器。
		1. 在参数中添加具体的删除器函数名 shared_ptr<type> ptrName(new type(...), Delete);

	2. **需要自定义删除器的情况** shared_ptr管理动态数组。
		1. 在自定义删除器中使用delete[];
		2. shared_ptr<A> ptrA(new A[10], std:default<A[]>());
		3. shared_ptr<A[]> ptrA(new A[10]); // 不需要自己定义删除器

	3. 一个函数模板来封装shared_ptr数组
```cpp
template<typename T>
shared_ptr<T> make_shared_array(size_t size){
	return shared_ptr<T> (new T[size], std::default_delete<T[]>());
}
```
	4. 就算两个shared_ptr指定了不同的删除器，只要它们所指向的对象类型相同，那么这两个shared_ptr也属于同一个类型(可以被放进同一个容器中)。
	5. make_shared()不能指定删除器。

## 5.3 weak_ptr
### 5.3.1 weak_ptr概述
1. weak_ptr用来辅助shared_ptr进行工作。
2. 类模板，智能指针，指向一个由shared_ptr管理的对，但是weak_ptr指针不控制其所指向对象的生命周期，也就是将weak_ptr绑定到shared_ptr上并不会改变shared_ptr的引用计数，weak_ptr的构造和析构不会增加或者减少其指向对象的引用计数。
3. 当shared_ptr需要释放所指向对象的时候照常释放，不管是否有weak_ptr指向该对象。
4. weak_ptr(弱共享/弱引用)被用来监视shared_ptr(强引用)的生命周期，是一种对shared_ptr的扩充。weak_ptr不是一种独立的指针，不能用来操作所指向的资源，但是能监视shared_ptr所指向的对象是否存在。
5. 只有强引用计数才能决定对象的生存期。

#### 5.3.1.1 weak_ptr的创建
1. 拷贝构造，用std::shared_ptr初始化。
2. 创建weak_ptr的时候，一般用shared_ptr来初始化 std::weak_ptr<type> ptrName(std::shared_ptr);


### 5.3.2 weak_ptr的常用操作
1. use_count() 获取与该weak_ptr共享对象的其他shared_ptr的数量，或者当前所监视资源的强引用计数值。

2. expired() 该weak_ptr是否过期，及其use_count()是否为0，所监视资源是否被释放。

3. reset() 将该weak_ptr置空。不影响指向该对象的强引用数量，但是指向该对象的弱引用数量会减少1。

4. lock() 检查weak_ptr所指向的对象是否存在，如果存在，则返回一个指向该对象的shared_ptr对象(指向对象的强引用加1)。如果对象不存在，则返回一个空的shared_ptr。

### 5.2.3 尺寸问题
1. weak_ptr的尺寸和shared_ptr的尺寸一样大，是裸指针的2倍。
2. weak_ptr和shared_ptr的内容都可分为两部分(两个裸指针)，其一指向其所管理对象，其二指向控制块(引用计数、弱引用计数和其他数据)。

## 5.4 shared_ptr的使用场景、陷阱、性能分析
### 5.4.1 shared_ptr使用场景

### 5.4.2 shared_ptr使用陷阱分析
1. 慎用裸指针
	1. 不允许从裸指针到shared_ptr的隐式类型转换。
	2. 如果一个函数的形参是shared_ptr，在调用此函数时使用的形参是用裸指针初始化的临时shared_ptr对象，那么函数的实参中强引用值为1，当函数运行结束，实参作为临时变量要被销毁，那么此shared_ptr所管理的对象(裸指针所指向的对象)也会被释放，裸指针会失效，不能再使用。如果再使用此裸指针会出现不可预料的结果。
	3. 把一个普通裸指针绑定到shared_ptr上之后，内存管理的责任就交给了shared_ptr。这个时候就不应该再使用裸指针来访问shared_ptr所指向的对象。
	4. 不能用裸指针初始化多个shared_ptr。
	5. 指向同一对象的shared_ptr共用一个控制块。

```cpp
int *P = new int(100); //裸指针
shared_ptr<int> p1(P); //
shared_ptr<int> p2(P); //p1、p2中的引用计数都为1，两个智能指针相互独立，所以如果依次释放p1和p2，那么裸指针P会被delete两次，产生异常。
```

2. 慎用get()返回的指针
	1. 返回智能指针所指向对象对应的裸指针。
	2. 引入get()的原因是有些函数参数类型为裸指针。
	3. get()返回的指针不能随意delete，否则原智能指针无法正常管理对象。
	4. 不能将其他智能指针绑定到get()返回的裸指针上。(类似于一个裸指针被绑定到两个shared_ptr上)

3. 不要把类对象指针(this)作为shared_ptr返回，改用enable_shared_from_this
	1. 

```cpp
class TEST
{
public:
	shared_ptr<TEST> getself(){
		return shared_ptr<TEST>(this); //类似于用裸指针初始化多个shared_ptr。
		//获得的多个shared_ptr指向同一个对象，但并不共用一个控制块，这样会导致一个对象被析构多次。
	}
}

class TEST ： public enable_shared_from_this<TEST>
{
public:
	shared_ptr<TEST> getself(){
		return shared_from_this(); //应该通过此方法返回智能指针。
		//原理是weak_ptr的lock()方法。
	}
}

int main(){
	shared_ptr<TEST> ptr0(new TEST);
	shared_ptr<TEST> ptr1(ptr0);

	//如果
	shared_ptr<TEST> ptr1 = ptr0->getself();
}
```

4. 避免循环引用
	1. shared_ptr的循环引用会导致内存泄漏。

```cpp
class TESTa{
public:
	shared_ptr<TESTb> ptra;
	~TESTa(){
		...
	}
}

class TESTb{
public:
	shared_ptr<TESTa> ptrb;
	~TESTb(){
		...
	}
}

int main(){
	shared_ptr<TESTa> pca(new TESTa);
	shared_ptr<TESTb> pcb(new TESTb);

	pca->ptra = pcb; //等价于指向TESTb对象的有两个强引用。
	pcb->ptrb = pca; //等价于指向TESTa对象的有两个强引用。
	// 此时pca和pcb的强引用计数都为2。
	// 程序结束时局部变量pca和pcb声明周期结束，其指向对象的强引用计数减一，变成1，但因为强引用计数不为0，故TESTa和TESTb对象都没有被释放。
}
```

```cpp
// 如何防止shared_ptr循环引用造成的内存泄漏？
// 将可能循环引用的两个shared_ptr其中之一用weak_ptr替换。
// 
class TESTa{
public:
	shared_ptr<TESTb> ptra;
	~TESTa(){
		...
	}
}

class TESTb{
public:
	weak_ptr<TESTa> ptrb;
	~TESTb(){
		...
	}
}

int main(){
	shared_ptr<TESTa> pca(new TESTa);
	shared_ptr<TESTb> pcb(new TESTb);

	pca->ptra = pcb; //指向TESTb的对象有两个强引用。
	pcb->ptrb = pca; //因为ptr_b是weak_ptr，所以这里指向TESTa的对象的强引用计数还是1。
	/*
	程序结束时局部变量pca和pcb声明周期结束，其指向对象的强引用计数减一，此时TESTb的强引用计数变为1，TESTa的强引用计数变为0，TESTa对象被释放，TESTa的析构函数被执行，ptr_a的声明周期结束，TESTb的强引用计数再减一变为0。这样TESTa和TESTb对象都能被正确释放。
	TESTa先析构，TESTb后析构。
	*/
}
```

### 5.4.3 shared_ptr性能说明
1. 尺寸问题
	1. shared_ptr的尺寸是裸指针的两倍。
	2. shared_ptr中包含两个裸指针，其一是指向type对象的指针，其二是指向控制块的指针。其中控制块中存储着该对象的强引用计数、弱引用计数和其它数据。
	3. 控制块是由第一个指向某个指定对象的shared_ptr创建的，后来指向此对象的shared_ptr指向此控制块。
	4. 控制块创建时机：
		1. make_shared()分配并初始化一个对象，返回指向此对象的shared_ptr，所以make_shared()总能创建一个控制块。
		2. 用裸指针来初始化一个shared_ptr对象时。
	5. 自定义删除器不会影响shared_ptr的大小
2. 移动语义
	1. 用std::move(ptrName1)来初始化另外一个ptrName2。移动构造一个新的智能指针对象，ptrName1被置空，被指向对象的强引用计数仍然为1。

## 5.5 unique_ptr
### 5.5.1 unique_ptr概述
1. 常规初始化
	1. 独占式智能指针，专属所有权。同一时刻只能有一个unique_ptr指针指向这个对象，当unique_ptr被销毁时，它所指的对象也被销毁。
	2. unique_ptr<type> ptrName(new type(...));

2. make_unique()函数 C++14
	1. 不支持指定删除器，如果不使用删除器，应该优先使用make_unique()，这样有更好的性能。
	2. unique_ptr<type> ptrName = make_unique<type>(...);

 
### 5.5.2 unique_ptr常用操作
1. unique_ptr不支持的操作
	1. 不支持拷贝操作。
	2. 不支持赋值操作。
2. 移动语义
	1. 

```cpp
// unique_ptr的移动
unique_ptr<type> ptr_0(new type(...));
unique_ptr<type> ptr_1(std::move(ptr_0)); //ptr_0为空，ptr_1指向ptr_0原来所指的对象。
```

3. release()
	1. 放弃对指针的控制权(切断了智能指针和其指向对象之间的联系)，返回裸指针，并将智能指针置空。返回的裸指针可以手动delete，也可以用来初始化另外一个智能指针，或者给另外一个智能指针赋值。

4. reset()
	1. 不带参数的情况，释放智能指针所指向的对象，并将智能指针置空。
	2. 带参数(裸指针)的情况，释放智能指针所指向的对象，并让该智能指针指向新对象(参数)。

5.  = nullptr
	1. 释放智能指针所指向的对象，并将智能指针置空。

6. 指向一个数组
	1. 指向数组的unique_ptr，可以正确释放内存，不会产生内存泄漏。

```cpp
//如果type有自己的析构函数，则一定要加上[]，否则会产生内存泄漏。
unique_ptr<int[]> ptrarray(new int[10]); //指向数组的unique_ptr
ptrarray[0] = 237; //可使用下标访问
```

7. get()
	1. 返回智能指针中的裸指针。(考虑到有些函数的参数需要传入内置的裸指针)(不要对返回结果使用delete)

8. \*解引用
	1. 获取该智能指针指向的对象，与裸指针的解引用类似。

9. swap() 交换两个智能指针指向的对象

10. 智能指针名字作为判断条件 (ptrName == nullptr)

11. 转换成shared_ptr类型
	1. 如果一个unique_ptr为右值，就可以将其赋值给shared_ptr。(shared_ptr包含一个显示构造函数，可用于将右值unique_ptr转换为shared_ptr，shared_ptr将接管原归unique_ptr所管理的对象。)
	2. std::move(unique_ptr) 可以将unque_ptr转换为右值。

### 5.5.3 返回unique_ptr
1. 从函数返回一个局部的unique_ptr对象，此时的unqiue_ptr可以被拷贝，因为它即将被销毁。
2. 对于调用函数返回的unique_ptr对象，如果没有用同类型的unique_ptr对象来接，则临时对象会被释放，同时会释放掉所指向的对象。

### 5.5.4 unique_ptr指定删除器
1. 默认删除器为delete
2. 指定删除器 unique_ptr<type, 删除器的类型> ptrName(...);
3. unqiue_ptr删除器要先在类型模板中传递进去参数名，然后在参数中再给具体的删除器函数名。

```cpp
void mydeleter(string* pdel){
	delete pedl;
	pdel = nullptr;
}
//typedef
typedef void(*fp1)(string*); //定义一个函数指针类型，类型名为fp。
unique_ptr<string, fp1> ptrName(new string("TEST!!!"), mydeleter);

//using
using fp2 = void(*)(string *); //用using定义一个函数指针类型。
unique_ptr<string, fp2> ptrName(new string("TEST!!!"), mydeleter);

//typedef + decltype
typedef decltype(mydeleter)* fp3; //decltype返回的是函数类型void(string*)，加*之后就成为函数指针类型 void* (string*)。
unique_ptr<string, fp3> ptrName(new string("TEST!!!"), mydeleter);

//lambda表达式，lambda表达式可以理解成带有operator()类类型对象。
auto mydeleter = [](string *pdel){
	delete pdel;
	pdel = nullptr;
	......
}

unique_ptr<string, decltype(mydeleter)> ptrName(new string("TEST!!!"), mydeleter);
```

4. 与shared_ptr指针不一样的是，删除器类型不用的unique_ptr，即使它们指向对象一样，也不属于同一类型unique_ptr，也就不能放到同一容器里。

### 5.5.5 尺寸问题
1. 通常情况下unique_ptr智能指针与裸指针大小一致。
2. 如果在unique_ptr中自定义删除器，其尺寸有可能变化(其他类型删除器)，也有可能不变化(lambda)。

## 5.6 智能指针总结
### 5.6.1 智能指针背后的设计思想
1. **主要目的：** 帮助程序员释放内存，以防止忘记释放内存时造成的内存泄漏。

### 5.6.2 auto_ptr为什么被放弃
1. C++98时代的智能指针，具有unique_ptr的一部分特性。
2. 不能在容器中保存。
3. 不能从函数中返回auto_ptr。
4. auto_ptr支持同类型之间的赋值操作，不过赋值操作符右边的auto_ptr在操作后会被置空，这可能为以后的不正确操作留下隐患。
5. 缺少对引用数和数组的支持。

### 5.6.3 智能指针的选择
1. 如果程序要使用多个指向同一对象的指针，应该首选shared_ptr。
2. 如果程序不需要多个指向同一对象的指针，应该首选unique_ptr。

## 5.7 智能指针的其它问题
### 5.7.1 智能指针有什么缺陷？
1. 一般情况下，shared_ptr和weak_ptr的大小都是裸指针的两倍，因为它们之中除了保存原裸指针，还保存了一个指向控制块的指针。这样多少带来了内存上的消耗。
2. shared_ptr的循环引用依然会造成内存泄漏，且不易察觉。



### 5.7.2 weak_ptr指向的对象不存在会怎样？

### 5.7.3 智能指针的具体原理是什么？智能指针内部如何完成内存回收机制？
#### 5.7.3.1 shared_ptr

```cpp
#include <iostream>
#include <memory>
#include <string>
 
template <typename Object>
class SmartPointer
{
public:
    SmartPointer(Object * p = nullptr)
        : m_ptr(p),
        m_pRefCnt(new size_t{})
    {
        if(p)
            *m_pRefCnt = 1;
        else
            *m_pRefCnt = 0;
    }
 
    ~SmartPointer()
    {
        releaseCount();
    }
    // copy constructor
    SmartPointer(const SmartPointer & rhs)
    {
        if(this != &rhs) {
            m_ptr = rhs.m_ptr;
            m_pRefCnt = rhs.m_pRefCnt;
            (*m_pRefCnt)++;
        }
    }
 
    // move constructor
    SmartPointer(SmartPointer && rhs)
        :m_ptr{std::move(rhs.m_ptr)},
        m_pRefCnt(rhs.m_pRefCnt)
    {
        rhs.m_ptr = nullptr;
        rhs.m_pRefCnt = nullptr;
    }
 
    // assignment operator for copy
    SmartPointer & operator = (const SmartPointer& rhs)
    {
        if(this != &rhs) {
            releaseCount(); // release the current pointer.
            m_ptr = rhs.m_ptr;
            m_pRefCnt = rhs.m_pRefCnt;
            (*m_pRefCnt)++;
        }
        return *this;
    }
 
    // assignment operator for move
    SmartPointer & operator = (SmartPointer && rhs)
    {
        std::swap(m_ptr, rhs.m_ptr);
        std::swap(m_pRefCnt, rhs.m_pRefCnt);
        return *this;
    }
 
    Object & operator *() const
    {
        return *m_ptr;
    }
 
    Object * operator ->() const
    {
        return &this->operator*();
    }
private:
     void releaseCount()
    {
        if (m_pRefCnt)
        {
            (*m_pRefCnt)--;
            std::cout << "Descrease release count. Current Count " << (*m_pRefCnt) << std::endl;
            if (*m_pRefCnt == 0)
            {
                delete m_ptr;
                delete m_pRefCnt;
                std::cout << "Free heap resource. Release count = 0" << std::endl;
            }                  
        }            
    }
 
 
    //
private:
    Object *m_ptr;
    size_t *m_pRefCnt;
};
 
int main(int argc, char **argv)
{
    SmartPointer<int> i{new int{10}};
    SmartPointer<int> j{new int{15}};
    i = std::move(j);
    std::cout << *i << std::endl;
    std::cout << *j << std::endl;
    return 0;
}
```
#### 5.7.3.2 weak_ptr

#### 5.7.3.3 unique_ptr

### 5.7.4 如果出现智能指针循环引用，不用weak_ptr怎么样能避免内存泄漏？

### 5.7.5 

# 6. this指针
1. this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用还成员函数的那个对象；
2. 当对一个对象调用成员函数时，编译程序现将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用this指针；
3. this 指针被隐含地声明为： ClassName \*const this, 这意味着this指针为常量指针，不能改变其内容，即不能给this指针赋值，在ClassName类的const成员函数中，this指针类型为：const ClassName\* const,这说明此时this指针所指的对象不可修改（即不能对这种对象的数据成员进行赋值操作）；
4. this并不是一个常规变量，而是个右值，所以不能取得this的地址；
5. 在下列场景中，经常需要显式引用this指针：<br>
	1. 实现对对象的链式引用；
	2. 为避免对同一对象进行赋值操作；
	3. 在实现一些数据结构时。

# 7. inline 内联函数
## 7.1 内联函数的特征
1. 相当于把内联函数里面的内容写在了调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，但内联比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

## 7.2 编译器对 inline 函数的处理步骤
1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

## 7.3 inline 内联函数的优缺点
### 7.3.1 优点：
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

### 7.3.2 缺点
1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

# 8. 程序所用到的内存段
## 8.1 bss(Block Started by Symbol)段
通常是指用来存放程序中**未初始化的全局变量**的一块内存区域，属于静态内存分配。
## 8.2 data段
通常是指用来存放程序中**已初始化的全局变量**的一块内存区域，属于静态内存分配。
## 8.3 text段(code/text segment)
通常是指用来存放程序**执行代码**的一块内存区域。
## 8.4 堆(heap)
1. 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
2. 当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)。
3. 当利用free等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减)。
4. 堆是向高地址扩展的数据结构，是不连续的内存区域。
5. 堆容易产生内存泄漏，大量的new/delete操作会造成内存空间的不连续。

## 8.5 栈(stack)
1. 栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。
2. 在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。
3. 由于栈的先进后出(FILO)特点，所以栈特别方便用来保存/恢复调用现场。
4. 从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。
5. 栈是向低地址扩展的数据结构，是一块连续的内存区域。

# 9. C++11 的新基础特性


# 10. C/C++ 程序编译流程
## 10.1 预处理
**预处理相当于根据预处理指令组装新的C/C++程序。经过预处理、会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义与原本文件无异，只是内容上有所不同。**
### 10.1.1 读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理
1. 将所有的“#define”删除，并且展开所有的宏定义。<br>
2. 处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。 <br>
3. 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。<br>

### 10.1.2 删除所有注释

### 10.1.3 添加行号和文件名标识
以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告是能够显示行号。

### 10.1.4 保留所有的#pragma编译器指令

## 10.2 编译
将预处理完的文件进行一系列词法分析、语法分析、语义检查和中间代码生成、代码优化和目标代码生成，产生相应的汇编代码文件。

## 10.3 汇编
**将编译完成的代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。**<br>
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。

## 10.4 链接
**通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。**
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。<br>
例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。<br>
链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。<br>


# 11. C++内存管理
## 11.1 C++ 内存管理详解
### 11.1.1 内存分配方式
#### 11.1.1.1 分配方式简介
在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。<br>
1. **栈**，在执行函数时，**函数内局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
2. **堆**，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
3. **自由存储区**，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
4. **全局/静态存储区**，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
5. **常量存储区**，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

#### 11.1.1.2 明确区分堆与栈

#### 11.1.1.3 堆和栈的区别
1. 管理方式<br>
对于栈来讲，其是由编译器自动管理，无需手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄漏。
2. 空间大小<br>

3. 能否产生碎片<br>
对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。
4. 生长方向<br>
对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
5. 分配方式<br>
堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
6. 分配效率<br>
栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。


# 12. C++中的虚函数(表)实现机制
C++对象的内存布局
## 12.1 只有数据成员的类对象
成员变量是按照定义的顺序来保存的，最先声明在低地址，然后依次保存。类对象的大小是所有成员变量大小之和。(是否有字节对齐？)

```cpp
class Base1
{
public:
	int base1_1;
	int base1_2;
};
```
sizeof(Base1)|8
-|-
offsetof(Base1, base1_1)|0
offsetof(Base1, base1_1)|0

## 12.2 没有虚函数的类对象
如果一个函数不是虚函数，那么就不可能发生动态绑定，也就不会对类对象的布局造成任何影响。<br>
当调用一个非虚函数时，那么调用的一定就是当前指针类型拥有的那个成员函数，这种调用机制在**编译**时期就确定下来了。

```cpp
class Base1
{
public:
	int base1_1;
	int base1_2;

	void foo(){}
};
```
sizeof(Base1)|8
-|-
offsetof(Base1, base1_1)|0
offsetof(Base1, base1_1)|0

## 12.3 仅拥有一个虚函数的类对象
相对于没有虚函数的类对象，仅拥有一个虚函数的类对象的内存分布开始时会多一个类型为void\*\*的指针(\_\_vfptr, 虚函数表(vtable)指针)，所占内存大小为一个指针大小。

```cpp
class Base1
{
public:
    int base1_1;
    int base1_2;

    virtual void base1_fun1() {}
};
```

sizeof(Base1)|12
-|-
offsetof(__vfptr)|0
offsetof(Base1, base1_1)|4
offsetof(Base1, base1_1)|8

### 12.3.1 为什么\_\_vfptr被定义成一个指向指针数组的指针，而不是直接定义成一个指针数组？
如果仅是一个指针的话，就无法轻易修改那个数组里面的内容，因为虚函数表并不属于类对象的一部分，属于类对象的，仅是一个指向虚函数表的指针\_\_vfptr而已。

## 12.4 拥有多个虚函数的类对象
1. \_\_vfptr只是一个指针，指向一个函数指针数组(虚函数表)。
2. 增加一个虚函数，只是简单地向该类对应的虚函数表中增加一项而已，并不会影响到类对象的大小和布局情况。
3. 同一个类的不同实例共用一份虚函数表，它们通过各自的虚函数表指针\_\_vfptr(void\*\*类型)指向该虚函数表。
4. 虚函数表是编译器在编译时期创建的。
5. 定义类对象时，编译器自动将类对象的\_\_vfptr指向该类的虚函数表。

```cpp
class Base1
{
public:
    int base1_1;
    int base1_2;

    virtual void base1_fun1() {}
    virtual void base1_fun2() {}
};
```

sizeof(Base1)|12
-|-
offsetof(__vfptr)|0
offsetof(Base1, base1_1)|4
offsetof(Base1, base1_1)|8

## 12.5 单继承且本身不存在虚函数的继承类的内存布局
基类的内存布局+自身独有的成员数据布局。<br>

```cpp
class Base1
{
public:
    int base1_1;
    int base1_2;

    virtual void base1_fun1() {}
    virtual void base1_fun2() {}
};

class Derive1 : public Base1
{
public:
    int derive1_1;
    int derive1_2;
};
```



## 12.6 本身没有定义新的虚函数但存在基类虚函数覆盖的单继承类的内存布局   
基类中在派生类里被覆盖掉的虚函数，其对应的派生类虚函数表的中的函数指针也会被相应地覆盖。

```cpp
class Base1
{
public:
    int base1_1;
    int base1_2;

    virtual void base1_fun1() {}
    virtual void base1_fun2() {}
};

class Derive1 : public Base1
{
public:
    int derive1_1;
    int derive1_2;

    // 覆盖基类函数
    virtual void base1_fun1() {}
};
```


## 12.7 定义了基类没有的虚函数的单继承的类对象布局
1. 派生类的虚函数表被加在基类的虚函数表后面。
2. 派生类新加的虚函数指针对基类的虚函数表不会有影响。  

```cpp
class Base1
{
public:
    int base1_1;
    int base1_2;

    virtual void base1_fun1() {}
    virtual void base1_fun2() {}
};

class Derive1 : public Base1
{
public:
    int derive1_1;
    int derive1_2;

    virtual void derive1_fun1() {}
};
```

## 12.8 多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局
1. 按照基类的声明顺序, 基类的成员依次分布在继承中。
2. 在派生类中被覆盖的虚函数在基类虚函数表中的指针会被相应地覆盖。
3. 派生类的虚函数表保存在第一个拥有虚函数表的基类的虚函数表后面。

```cpp
class Base1
{
public:
    int base1_1;
    int base1_2;

    virtual void base1_fun1() {}
    virtual void base1_fun2() {}
};

class Base2
{
public:
    int base2_1;
    int base2_2;

    virtual void base2_fun1() {}
    virtual void base2_fun2() {}
};

// 多继承
class Derive1 : public Base1, public Base2
{
public:
    int derive1_1;
    int derive1_2;

    // 基类虚函数覆盖
    virtual void base1_fun1() {}
    virtual void base2_fun2() {}

    // 自身定义的虚函数
    virtual void derive1_fun1() {}
    virtual void derive1_fun2() {}
};
```

## 12.9 如果第一个直接基类没有虚函数(表)
1. 有虚函数表的基类会放在对象内存的前面。

## 12.10 多(2)继承的两个基类都没有虚函数(表)
1. 对象内存分布中会先创建虚函数表，在依次分布基类的成员和派生类的成员。

## 12.11 多(3)继承的三个基类的虚函数(表)分别是有、没有、有
1. 对象内存分布中会按顺序分布拥有虚函数表的基类、其他基类、派生类。

# 13. lambda表达式 
## 13.1 lambda表达式用法简介
1. C++11新特性。
2. 可调用对象，定义了一个匿名函数，并且能捕获一定范围内的变量。
3. [capture list](paramslist) mutable exception -> return type { function body };
	1. capture list：捕获外部变量列表，[]不能省略
    2. paramslist：形参列表 ()可以省略
    3. mutable指示符：用来说用是否可以修改捕获的变量
    4. exception：异常设定
    5. return type：返回类型
    6. function body：函数体 {}不能省略
4. 匿名函数、可调用的代码单元、未命名的inline函数。
5. lambda表达式可以在函数内部定义，这是常规函数做不到的。
6. 将lambda表达式赋值给一个auto变量，相当于创建了一个函数，此函数与普通函数调用方式相同。

## 13.2 捕获列表
1. lambda表达式通过捕获列表来捕获一定范围内的变量。
2. lambda表达式默认不捕获任何变量，但是可以直接使用局部静态变量。(局部静态变量不需要捕获)
3. [&]捕获外部作用域中所有变量，并作为引用在函数体中使用。(引用传递)
4. [=]捕获外部作用域中所有变量，并按值在函数体中使用。(值传递，不能在函数体内对捕获的变量赋值)
5. [this]用于类中，捕获当前类中的this指针，让lambda表达式有和当前类成员函数同样的访问权限。
6. 如果[]中已经使用了&或者=，那么默认就使用了this。
7. [变量名]按值捕获变量名代表的变量。
8. [&变量名]按引用捕获变量名代表的变量。
9. [=, &变量名1, &变量名2......]按值捕获外部作用域中所有变量，但是按引用捕获变量名所代表的变量，=必须写在开头位置。
10. [&, =变量名1, =变量名2......]按引用捕获外部作用域中所有变量，但是按值捕获变量名所代表的变量，&必须写在开头位置。

## 13.3 lambda表达式延迟调用易出错细节分析
1. lambda表达式的延迟调用

```cpp
int x = 5;
auto f = [=](){  //当遇到lambda表达式起始这一行，labmda表达式就完成了需要按值捕获变量的捕获工作。
				 //也就是说，凡是按值捕获的外部变量，在lambda表达式定义的这个时刻，这部分外部变量就被复制了一份存储在了lambda表达式中。
	return x;
};

x = 10;

cout<<f()<<endl;  //输出为5
```

2. 如果希望在lambda表达式调用时获取当前实时的外部变量的值，应该在捕获变量时使用按引用捕获。

## 13.4 lambda表达式中的mutable
1. 被mutable修饰的lambda表达式可以在函数体中修改即使是按值捕获的外部变量。

## 13.5 lambda表达式的类型及存储
1. C++11中lambda表达式被称为闭包类型(closure)。
2. 闭包：函数内的函数，是一种可调用对象，本质上是lambda表达式创建的运行时期的送对象。
3. lambda表达式是一种比较特殊的，匿名的，类类型(闭包类)的对象(定义了一个类类型，又生成了一个该类型的匿名对象)。

```cpp
std::function<int(int)> fc1 = [](int tv) {return tv};

std::function<int(int)> fc2 = std::bind(
	[](int tv){
		return tv;
	}
	16;
	);

//不捕获任何变量的lambda表达式(也就是捕获列表为空)，可以转换成一个普通的函数指针。
using functype = int(*)(int); //定义一个函数指针类型。
functype fp = [](int tv){return tv;}; //用函数指针来接lambda表达式。
```
### 13.5.1 语法糖概念
1. 语法糖是一种便捷写法的意思。
2. 语法糖是指基于语言现有特性，构造出一个使用起来很方便的东西，但是没有增加语言的原有功能。
3. lambda表达式可以看成是定义仿函数闭包的语法糖。

## 13.6 lambda表达式的优点总结
### 13.6.1 for_each
1. #include <algorithm>
2. 函数模板

### 13.6.2 find_if
1. #include <algorithm>  
2. 函数模板
3. 查找

## 13.7 lambda表达式捕获模式的陷阱分析
### 13.7.1 捕获列表中的&
1. 捕获外部作用域中的所有变量，并作为引用在lambda表达式中使用。
2. 按照这种捕获方式，会导致lambda表达式包含绑定到局部变量的引用。

```cpp
#include <ctime>
using namespace std;

std::vector<std::function<bool(int)>> funcList; //全局变量，每个元素都是function(形参类型为int，返回类型为bool)

void rand5(){
	srand((unsigned)time(NULL));
	int tempValue = rand() % 6; //产生一个0-5的随机数。

	funcList.push_back(
		[&](int tv){
			if(tv % tempValue == 0) return true;
			else return false;
		}
	);
}

int main(){
	rand5();
	cout << funcList[0](10) << endl; //此时调用funcList[0]
	// funcList[0]的实质lambda表达式中对外部变量的捕获是按引用捕获的，而外部变量在rand5()执行结束之后已经失效。
	// 故funcList[0]此时捕获到的是无效变量，这样会导致程序崩溃。
	// 按值捕获可以解决上述问题。(引用捕获超出范围的问题，引用悬空)
}
```

### 13.7.2 形参列表可以使用auto C++14

### 13.7.3 成员变量的捕获问题
1. lambda表达式的捕获，只针对在创建lambda表达式作用域内可见的非静态局部变量。因此类的成员变量并不能被捕获到，要想在lambda表达式中使用类中的成员变量，只能捕获this指针，然后通过this指针调用类的成员变量。
2. 可以通过在lambda表达式中创建捕获变量的副本来避免捕获变量失效的问题。

### 13.7.4 广义lambda捕获 C++14

### 13.7.5 静态局部变量

# 14. 类型转换
## 14.1 隐式类型转换
C++定义了一组内置类型对象之间的标准转换，在必要时它们被编译器隐式地应用到对象上。隐式类型转换发生在以下这些典型情况下：<br>
1. 在混合类型的算数表达式中： 目标转换类型是最宽的数据类型。(算数转换，Arithmetic Conversion)
2. 用一种类型的表达式赋值给另一种类型的对象： 目标转换类型是被赋值对象的类型。
3. 把一个表达式传递给一个函数，调用表达式的类型与形式参数的类型不相同： 目标转换类型是形式参数的类型。
4. 从一个函数返回一个表达式的类型与返回类型不相同： 目标转换类型是返回类型。

### 14.1.1 算数转换
算数转换保证了二元操作符，如加法或乘法的两个操作数被提升为相同的类型，然后再用它表示结果的类型。<br>

#### 14.1.1.1 算数转换的通用指导原则
1. 为了防止精度损失，如果有必要的话，类型总是被提升为较宽的类型。
2. 所有含有小于整型的有序类型的算数表达式在计算之前其类型都会被转换成整型。

## 14.2 显示类型转换/强制类型转换
### 14.2.1 static_cast


### 14.2.2 dynamic_cast

### 14.2.3 const_cast

### 14.2.4 reinterpret_cast

# 15. C++常用库函数

## 15.1 数学函数
0. 头文件 #include <math> 或者 #include <math.h>
1. int abs(int x)	        求整数x的绝对值	绝对值
2. double acos(double x)	计算arcos(x)的值	计算结果
3. double asin(double x)	计算arsin(x)的值	计算结果
4. double atan(double x)	计算arctan(x)的值	计算结果
5. double cos(double x)	    计算cos(x)的值	计算结果
6. double cosh(double x)	计算x的双曲余弦cosh(x)的值	计算结果
7. double exp(double x)	    求的值	计算结果
8. double fabs(double x)	求实数x的绝对值	绝对值
9. double fmod(double x)	求x/y的余数	余数的双精度数
10. long labs(long x)	    求长整型数的绝对值	绝对值
11. double log(double x)	计算In(x)的值	计算结果
12. double log10(double x)	计算的值	计算结果
13. double modf(double x, double \*y)	取x的整数部分送到y所指向的单元格中	x的小数部分
14. double pow(double x, double y)	    求x的y次幂的值	计算结果
15. double sin(double x)	            计算sin(x)的值	计算结果
16. double sqrt(double x)	            求的值	计算结果
17. double tan(double x)	            计算tan(x)的值	计算结果
18. fcvt	将浮点型数转化为字符串	  

## 15.2 字符串处理函数
0. 头文件 #include <string> 或者 #include <string.h>
1. void \*memcpy(void \*p1, const void \*p2 size_t n) 
存储器拷贝，将p2所指向的共n个字节拷贝到p1所指向的存储区中，目的存储区的起始地址（实现任意数据类型之间的拷贝）
2. void \*memset(void \*p int v, size_t n)
将v的值作为p所指向的区域的值，n是p所指向区域的大小，该区域的起始地址
3. char \*strcpy(char \*p1, const char \*p2) 
将p2所指向的字符串拷贝到p1所指向的存储区中，目的存储区的起始地址
4. char \*strcat(char \*p1, const char \*p2)	
将p2所指向的字符串连接到p1所指向的字符串后面，目的存储区的起始地址
5. int strcmp(const char \*p1, const char \*p2)	
比较p1,p2所指向的两个字符串的大小，两个字符串相同，返回0；若p1所指向的字符串小于p2所指的字符串，返回负值；否则，返回正值
6. int strlen(const char \*p)	
求p所指向的字符串的长度，字符串所包含的字符个数（不包括字符串结束标志’\n’）
7. char \*strncpy(char \*p1, const char \*p2, size_t n)	
将p2所指向的字符串（至多n个字符）拷贝到p1所指向的存储区中，目的存储区的起始地址(与strcpy()类似)
8. char \*strncat(char \*p1, const char \*p2, size_t n)
将p2所指向的字符串（至多n个字符）连接到p1所指向的字符串的后面	，目的存储区的起始地址(与strcat()类似)
9. char \*strncmp(const char \*p1, const char \*p2, size_t n)	
比较p1,p2所指向的两个字符串的大小，至多比较n个字符；两个字符串相同，返回0；若p1所指向的字符串小于p2所指的字符串，返回负值；否则，返回正值(与strcmp()类似)
10. char \*strstr(const char \*p1, const char \*p2)
判断p2所指向的字符串是否是p1所指向的字符串的子串，若是子串，返回开始位置的地址；否则返回0。

## 15.3 实现键盘和文件输入/输出的成员函数
0. 头文件#include <iostream> 或者 #include <iostream.h>
1. cin >> v	                                                                输入值送给变量	 
2. cout << exp	                                                            输出表达式exp的值	 
3. istream & istream::get(char &c)	                                        输入字符送给变量c	 
4. istream & istream::get(char \*, int , char = ‘\n’)	                    输入一行字符串	 
5. istream & istream::getline(char \*, int , char = ‘\n’)	                输入一行字符串	 
6. void ifstream::open(const char\*,int=ios::in, int = filebuf::openprot)	打开输入文件	 
7. void ofstream::open(const char\*,int=ios::out, int = filebuf::openprot)	打开输出文件	 
8. void fsream::open(const char\*, int, int = filebuf::openprot)	        打开输入/输出文件	 
9. ifstream::ifstream(const char\*,int = ios::in, int = filebuf::openprot)	构造函数打开输入文件	 
10. ofstream::ofstream(const char\*,int=ios::out, int = filebuf::openprot)	构造函数打开输出函数	 
11. fstream::fstream(const char\*, int, int = filebuf::openprot)	        构造函数打开输入/输出文件	 
12. void istream::close()	                                                关闭输入文件	 
13. void ofsream::close()	                                                关闭输出文件	 
14. void fsream::close()	                                                关闭输入/输出文件	 
15. istream & istream::read(char\*, int)	                                从文件中读取数据	 
16. ostream & istream::write(const char\*,int)	                            将数据写入文件中	 
17. int ios::eof()	                                                        判断是否到达打开文件的尾部	  1为到达2为没有
18. istream & istream::seekg(streampos)	                                    移动输入文件的指针	 
19. istream & istream::seekg(streamoff,ios::seek_dir)	                    移动输入文件的指针	 
20. streampos istream::tellg()	                                            取输入文件的指针	 
21. ostream & ostream::seekp(streampos)	                                    移动输出文件的指针	 
22. ostream & ostream::seekp(streamoff,ios::seek_dir)	                    移动输出文件的指针	 
23. streampos ostream::tellp()	                                            取输出文件的指针

## 15.4 其他常用函数
0. 头文件#include <stdlib> 或者 #include <stdlib.h>
1. void abort(void)	终止程序执行	 	不能结束工作
2. void exit(int)	终止程序执行	 	做结束工作
3. double atof(const char \*s)	将s所指向的字符串转换成实数	实数值	 
4. int atoi(const char \*s)	    将s所指向的字符串转换成整数	整数值	 
5. long atol(const char \*s)	将s所指的字符串转换成长整数	长整数值	 
6. int rand(void)	            产生一个随机整数	随机整数	 
7. void srand(unsigned int)	    初始化随机数产生器	 	 
8. int system(const char \*s)	将s所指向的字符串作为一个可执行文件，并加以执行	 	 
9. max(a, b)	求两个数中的大数	大数	参数为任意类型
10. min(a,b)	求两个数中的小数	小数	参数为任意类型	 


# 16. C++未定义
**未定义行为：语言标准没有规定，编译器自行决定的行为，在不同的编译器上有时会有不同的结果。**

## 16.1 位运算
位运算的运算对象是整数类型的，并且把位运算对象看成一个二进制位的集合。运算对象可以是带符号也可以是无符号。如果是带符号且值为负，那么位运算如何处理运算对象的符号位依赖于机器。而且此时左移操作可能会改变符号位的值，因此会产生未定义的行为。

关于符号位如何处理C++标准中没有明确的规定，所以强烈建议将位运算用于处理无符号类型。因此，在位运算的过程中，应该尽量将对象声明为无符号的，如unsigned int, unsigned char等。

## 16.2 求值顺序、运算符执行顺序、表达式
对于没有指定执行顺序的运算符，如果表达式指向并修改了同一对象，会引发错误并产生未定义的行为。

比如 int i = f1()\*f2(); 该表达式的乘法运算符没有指定运算的顺序，所以这里是f1()先执行还是f2()先执行是未定义的、未知的。f1()和f2()谁先执行取决于编译器如何处理。

## 16.3 类型转换、赋值
当赋值给带符号类型一个超过它表示范围的值时，结果是未定义的，程序可能继续工作，可能崩溃也可能产生数据垃圾。

## 16.4 函数的参数列表
实参与形参存在一一对应关系，但是没有规定实参的求值顺序，编译器可以任意可行的顺序对参数求值。这个与连乘的性质有些类似，连乘也没有规定求值的顺序，因此在使用过程中，需要注意求值顺序是否对结果有影响，不要想当然的认为参数列表是从左到右或者从右到左对表达式进行求值。

## 16.5 函数返回值
当函数具有非空的返回值时，如果函数的每一条执行路径中，有一条或多条路径可能没有相应的return语句，则可能会产生未定义的行为。当然，这种情况有可能编译器可以检测到并且给出相应的提示。但是如果编译器未检测到，则该函数在运行时的行为是未定义的。

## 16.6 返回局部对象的引用或指针
函数执行完之后，它所占用的存储空间也被释放掉。所以，函数终止意味着局部变量的引用将指向不再有效的内存区域。

## 16.7 避免无法预知和依赖于实现环境的行为
无法预知的行为源于编译器无法检测的错误，即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。

# 17. C++作用域
**C++ 程序中出现的每个名字，只在某些可能不连续的源码部分中有效，这些部分被称为其作用域。在作用域内，能用无限定名字查找将名字与其声明关联起来。**

## 17.1 块作用域
1. 块（复合语句）中的声明所引入的变量的潜在作用域，开始于其声明点并终止于该块末尾。实际作用域与潜在作用域相同，除非有内嵌块带有引入了相同名字的**声明**（这种情况下，从外层声明的作用域中排除掉嵌套声明的整个潜在作用域）。
2. 声明于异常处理块中的名字的潜在作用域开始于其声明点，并在该异常处理块结束时结束(一个catch语句为一个异常处理块)，而且在其他异常处理块或外围块中不在作用域中。
3. 在 for 循环的初始化语句中，在 for 循环的条件中，在范围 for 循环的范围声明中，在 if 语句或 switch 语句的初始化语句中， (C++17 起)在 if 语句、while 循环或 switch 语句的条件中，声明的名字的潜在作用域，开始于其声明点，并结束于控制语句的末尾。

## 17.2 函数形参作用域
函数形参（包括 lambda 表达式的形参）或函数局部预定义变量的潜在作用域开始于其声明点。<br>
1. 若最内层的外围函数声明符不是函数定义的声明符，则其潜在作用域终止于该函数声明符的结尾。
2. 否则，其潜在作用域终止于函数 try 块的最后异常处理块的末尾，或若不使用函数 try 块则为函数体的末尾。

## 17.3 函数作用域
声明于函数内的标号（且只有标号），在该函数和其所有内嵌代码块的任何位置都在作用域中，无论在其自身声明的前后。

## 17.4 命名空间作用域
1. 命名空间中声明的任何实体的潜在作用域均开始于其声明，并由其后的同一命名空间名的所有命名空间定义拼合起来，再加上对于将这个名字或其整个命名空间引入到其他作用域的每个 using 指令来说，包括这个作用域的剩余部分。

2. 翻译单元(编译单元)的顶层作用域（“文件作用域”或“全局作用域”）亦为命名空间，而被正式称作“全局命名空间作用域”。任何声明于全局命名空间作用域的实体的潜在作用域均开始于其声明，并持续到翻译单元的结尾。

3. 声明于无名命名空间或内联命名空间的实体的作用域包括外围命名空间。

## 17.5 类作用域
1. 类中声明的名字的潜在作用域开始于其声明点，并包含类体的剩余部分和所有函数体（无论是否定义于类定义外或在该名字的声明之前）、默认实参、异常规定、类内花括号或等号初始化器、契约条件 (C++20 起)，还（递归地）包括嵌套类中的所有这些内容。
2. 若在声明某个名字之前就在类体中使用，而有该名字的另一声明在作用域中，则程序非良构，不要求诊断。
3. 任何类成员名只能用于四种语境中：
	1. 在其自身的类作用域或在派生类的类作用域之中；
	2. 在对其类或其派生类的类型的表达式运用 . 运算符之后；
	3. 在对其类或其派生的类的指针类型的表达式运用 -> 运算符之后；
	4. 在对其类或其派生类的名字运用 :: 运算符之后。

## 17.6 枚举作用域
有作用域枚举中引入的枚举项的名字的作用域开始于其声明点，并终止于 enum 说明符的末尾（与之相反，无作用域枚举项的作用域在 enum 说明符的结尾后仍在作用域中）。

## 17.7 模板形参作用域
1. 模板形参名的潜在作用域直接开始于其声明点，并持续到于其中引入了它的最小模板声明的末尾。具体而言，模板形参能用于其后的模板形参的声明，及基类的指定，但不能用于其前的模板形参的声明。
2. 模板模板形参的形参名的潜在作用域，是该名字出现于其中的最小模板形参列表。
3. 与其他嵌套作用域类似，模板形参名在其自身的持续期间隐藏来自外层作用域的相同名字。

## 17.8 声明点
作用域始于声明点，它定位如下：
1. 对于简单声明所引入的变量和其他名字，声明点紧随该名字的声明符之后，且在其初始化器之前（若其存在）。
2. 类或模板的声明点，紧随其类头中所出现的命名类名的标识符（或指名模板特化的 template-id（模板标识））之后，并且在基类列表中已处于作用域中。
3. 枚举的声明点，紧随 enum 说明符或笼统枚举声明（取决于何者为先）中所出现的命名它的标识符之后。
4. 类型别名或别名模板的声明点紧随该别名所代表的类型标识（type-id）之后。
5. 枚举项的声明点紧随其定义之后（而非在初始化器之前，这点不同于变量）。
6. injected-class-name（注入类名）的声明点紧随其类（或类模板）定义的开花括号之后。

# 18 左值与右值

## 18.1 左值与右值
1. **左值**： 能用在赋值语句等号左侧的对象，能够代表一个地址。
2. **右值**： 不能作为左值的对象就是右值，右值不能出现在赋值对象左侧。
3. C++中一条表达式不是左值就是右值，左值有时候可以被当做右值使用。
```cpp
int i = 0;
i = i + 1;
//i是个左值，不是右值，虽然它也出现在了等号右边。
//i出现在等号右侧时，此时使用i具体的值，它就具有一种右值属性。
//i出现在等号左边时，此时使用i的内存地址，它就具有一种左值属性。
//一个左值可能同时具有左值属性和右值属性。
```
4. 用到左值的运算符：
	1. **=**，赋值运算符
	2. **&**，取地址运算符
	3. vector、string等容器做下标运算时
	4. 容器的迭代器的递增、递减运算符
	5. 类似的不能对字面值进行操作的运算符。
5. 左值表达式就是左值，右值表达式就是右值。
6. 左值代表一个地址，所以左值表达式的求值结果就需要是一个对象，就得有地址。 求值结果为对象的表达式不一定是左值。
7. 临时变量被系统当做右值，其他变量应该被看成左值。
8. 任何函数的形参都是左值。

## 18.2 引用分类
1. 引用是变量的别名。
2. 左值引用(type &)、右值引用(type &&)、常量引用(const type& 也是左值引用)。

## 18.3 左值引用
1. 引用左值，绑定到左值上。
2. 引用不能为空(定义时需要初始化，不能引用空值)。
3. 左值引用必须绑定到左值上，不能绑定到右值上。(常量引用可以绑定到右值上)

## 18.4 右值引用
1. 引用右值，必须绑定到右值上。
2. 希望用右值引用绑定一些即将销毁的或者一些临时的对象上。
3. 可以将右值引用理解成一个对象的名字。
4. 能绑定到左值引用上的左值对象，一般不能绑定到右值引用；能绑定到右值引用上的对象，一般不能绑定到左值引用。
5. 返回左值引用的函数、赋值、下标、解引用、前置递增递减运算符都是返回左值表达式的例子，可以将左值引用绑定到这类表达式上。
6. 返回非引用类型的函数、算数运算、关系运算、位运算以及后置递增递减运算符，都生成右值，不能讲一个左值引用绑定到这类表达式上，但可以用一个const左值引用或者一个右值引用绑定到这类表达式上。
7. 右值引用本身是左值。
8. **右值引用引入的目的**(01:11:00)
	1. 右值引用(&&)是C++11引入的新概念。
	2. 右值引用的引入的目的是提高程序运行效率，把拷贝对象变成移动对象来提高程序运行效率。
	3. 定义一个对象并用同类型对象初始化，系统会调用拷贝构造函数；当用另外一个对象给对象赋值，系统会调用拷贝赋值运算符。(参数类型为左值引用)
	3. **移动对象何时发生** 移动拷贝构造函数和移动赋值运算符(参数类型为右值引用)。

## 18.5 std::move()
1. C++11引用的新函数。
2. 把一个左值强制转化为右值。

## 18.6 左值引用与右值引用的区别
1. 右值引用就是必须绑定到右值的引用，通过&&获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。
2. 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。
3. 返回左值的表达式包括返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符，返回右值的包括返回非引用类型的函数及算术、关系、位和后置递增/递减运算符。可以看到，左值的特点是有持久的状态，而右值是短暂的。


# 19. C++与其他语言

## 19.1 C、C++的联系和区别

### 19.1.1 C语言是C++的子集吗？C++是在C语言的基础上扩展而来并包含所有C语言的内容吗？
1. 从实用角度讲，C++属于C语言的一个超集，基本上兼容ANSI C。
2. 从编译角度上讲，C语言的有些特性在C++中并不支持。相反，ANSI C继承了C++的几个特性，包括原型和常量。因此，这两种语言并不是另一个的超集或子集；而且它们在一些通用构造的定义上也不同。尽管有这些不同，许多C程序在C++环境中仍能编译，而且许多最新的编译器同时提供C和C++的编译模式。但是，不能把C代码完全当做C++代码来编译，否则在遇到不兼容问题时会给程序带来错误。

### 19.1.2 C、C++在语言层面有什么区别？
1. C语言是一种结构化语言，重点在于算法和数据结构。C语言的设计首先考虑的是通过一个过程，对输入(或环境条件)进行运算处理得到输出(或实现过程(事务)控制)。而对于C++，首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程(事务)控制。
2. C++对数组定义进行了限制。在C语言中，初始化数组时不作数组溢出判断，这样就容易使数组没有足够大的空间存放数据而产生错误。C++对此作了一些改进，像char str[3]="Jim"这样的表达式就被认为是一个错误，但是它在C语言中是合法的。
3. 在C++中，声明语句可以穿插于语句之间。大家知道，在C语言中，一个语句块中的所有声明必须都放在所有语句的前面，而C++去掉了这个限制，使声明语句可以穿插于语句之间。
4. 在C++中，用户代码不能够调用主函数main()函数，但是在C语言中这是可以的（但是极少出现这种情况）。
5. C++中对函数原型的声明是严格的，要求必须完整，而在C语言中却没有这么严格。
6. 在C++中，由typedef定义的类型的名字不能与已有的结构名称冲突，但在C语言中却是允许的。
7. C++规定了更严格的类型处理，例如，当void\*指针赋值给另一个类型的指针时，C++要求必须进行强制类型转换，而在C语言中则无需这么做。
8. C++对C语言的关键字进行了扩充，增加了至少十几个。这些关键字在C语言中可以作为标识符使用，但是如果这样的C语言代码使用C++编译器进行编译，就会产生错误信息。
9. 在C++中，内层作用域的结构名称将会隐藏外层空间中相同的对象名，在C语言中则不会这样。
10. 在C++中，注释可以使用"//"注释符，而在C语言中则不能使用。

## 19.2 C++和Java的区别
Java和C++都是面向对象语言。也就是说，它们都能够实现面向对象思想（封装，继乘，多态）。而由于C++为了照顾大量的C语言使用者，而兼容了C，使得自身仅仅成为了带类的C语言，多多少少影响了其面向对象的彻底性！Java则是完全的面向对象语言，它句法更清晰，规模更小，更易学。它是在对多种程序设计语言进行了深入细致研究的基础上，据弃了其他语言的不足之处，从根本上解决了C++的固有缺陷。<br>

1. **指针**<br>
Java语言让编程者无法找到指针来直接访问内存无指针，并且增添了自动的内存管理功能，从而有效地防止了C/C++语言中指针操作失误，如野指针所造成的系统崩溃。但也不是说JAVA没有指针，虚拟机内部还是使用了指针，只是外人不得使用而已。这有利于Java程序的安全。
2. **多重继承**<br>
C++支持多重继承，这是C++的一个特征，它允许多父类派生一个类。尽管多重继承功能很强，但使用复杂，而且会引起许多麻烦，编译程序实现它也很不容易。Java不支持多重继承，但允许一个类继承多个接口(extends+implement)，实现了c++多重继承的功能，又避免了c++中的多重继承实现方式带来的诸多不便。
3. **数据类型及类**<br>
Java是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而c++允许将函数和变量定义为全局的。此外，Java中取消了C/C++中的结构和联合，消除了不必要的麻烦。
4. **自动内存管理**<br>Java程序中所有的对象都是用new操作符建立在内存堆栈上，这个操作符类似于c++的new操作符。下面的语句由一个建立了一个类Read的对象，然后调用该对象的work方法：<br>
```JAVA
Read r＝new Read()；
r.work()；
```
语句Read r＝new Read()；在堆栈结构上建立了一个Read的实例。Java自动进行无用内存回收操作，不需要程序员进行删除。而c++中必须由程序员释放内存资源，增加了程序设计者的负担。Java中当一个对象不被再用到时，无用内存回收器将给它加上标签以示删除。Java里无用内存回收程序是以线程方式在后台运行的，利用空闲时间工作。
5. **操作符重载**<br>
Java不支持操作符重载。操作符重载被认为是C++的突出特征，在Java中虽然类大体上可以实现这样的功能，但操作符重载的方便性仍然丢失了不少。Java语言不支持操作符重载是为了保持Java语言尽可能简单。
6. **预处理功能**<br>
Java不支持预处理功能。C/C++在编译过程中都有一个预编泽阶段，即众所周知的预处理器。预处理器为开发人员提供了方便，但增加了编译的复杂性。JAVA虚拟机没有预处理器，但它提供的引入语句(import)与C++预处理器的功能类似。
7. **Java不支持缺省函数参数，而C++支持**<br>
在C中，代码组织在函数中，函数可以访问程序的全局变量。C++增加了类，提供了类算法，该算法是与类相连的函数，C++类方法与Java类方法十分相似，然而，由于C++仍然支持C，所以不能阻止C++开发人员使用函数，结果函数和方法混合使用使得程序比较混乱。
Java没有函数，作为一个比C++更纯的面向对象的语言，Java强迫开发人员把所有例行程序包括在类中，事实上，用方法实现例行程序可激励开发人员更好地组织编码。
8. **字符串**<br>
C和C++不支持字符串变量，在C和C++程序中使用Null终止符代表字符串的结束，在Java中字符串是用类对象(string和stringBuffer)来实现的，这些类对象是Java语言的核心，用类对象实现字符串有以下几个优点：
	1. 在整个系统中建立字符串和访问字符串元素的方法是一致的；
	2. Java字符串类是作为Java语言的一部分定义的，而不是作为外加的延伸部分；
	3. Java字符串执行运行时检查，可帮助排除一些运行时发生的错误；
	4. 可对字符串用“+”进行连接操作。
9. **goto语句**<br>
“可怕”的goto语句是C和C++的“遗物”，它是该语言技术上的合法部分，引用goto语句引起了程序结构的混乱，不易理解，goto语句子要用于无条件转移子程序和多结构分支技术。鉴于以上理由，Java不提供goto语句，它虽然指定goto作为关键字，但不支持它的使用，使程序简洁易读。
10. **类型转换**<br>
在C和C++中有时出现数据类型的隐含转换，这就涉及了自动强制类型转换问题。例如，在C++中可将一浮点值赋予整型变量，并去掉其尾数。Java不支持C++中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。
11. **异常**<br>
Java中的异常机制用于捕获例外事件，增强系统容错能力<br>
```JAVA
try{
   //可能产生意外的代码
}catch(exceptionType name){
    //处理
}
```
其中exceptionType表示异常类型，而C++则没有如此方便的机制。