# 1. 若干关键字
## 1.1 static关键字
**static被用来控制变量的存储方式和可见性。**

### 1.1.1 引入缘由
在函数内部定义的变量、当程序执行到定义处时，编译器为变量在**栈**上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉。为了让变量的值保存至下一次调用时，最容易想到的方法是将其定义为全局变量，但是定义为全局变量破坏了此变量的访问范围**使得在此函数中定义的变量，不仅仅只受此函数控制**, **static**关键字可以很好地解决这个问题。
另外，在C++中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。

### 1.1.2 静态数据的存储
全局(静态)存储区分为DATA段和BSS段。DATA段(全局初始化区)存放初始化的全局变量和静态变量，BSS段(全局未初始化区)存放未初始化的全局变量和静态变量，程序运行结束时自动释放。<br>其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
在C++中static的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。<br>这样，它的空间分配有三个可能的地方:

1. 是作为类的外部接口的头文件，那里有类声明；
2. 是类定义的内部实现，那里有类的成员函数定义；
3. 是应用程序的main()函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义(只能声明数据成员)。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。<br>
优势：可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

### 1.1.3 在C/C++中static关键字的作用
1. 在修饰变量的时候，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
2. static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。
3. static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
4. 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
5. 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

### 1.1.4 静态全局变量的特点
1. 静态变量都在全局数据区分配内存；
2. 未经初始化的静态全局变量会被程序自动初始化为0(在函数体内声明的变量的自动初始化值是随机的，在函数体外被声明的自动变量也会被初始化为0)；
3. 静态全局变量在声明它的整个文件里都是可见的，在此文件外是不可见的。(在其他文件中可以定义相同名字的变量，不会发生冲突)。

### 1.1.5 静态局部变量的特点
1. 该变量在全局数据区分配内存；
2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；
4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

### 1.1.6 全局变量和静态全局变量的区别
1. 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
2. 全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

### 1.1.7 静态数据成员
1. 静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。
2. 静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。
3. 静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0。
4. 静态数据成员既可以通过对象名引用，也可以通过类名引用。

### 1.1.8 静态函数成员
1. 静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
2. 非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
3. 静态成员函数主要用来访问静态数据成员而不能访问非静态成员。

## 1.2 explicit关键字
1. explicit关键字只需用于类内的单参数构造函数前面，防止类构造函数的隐式自动转换；
2. 对于无参数的构造函数和多参数的构造函数总是显式调用，这种情况在构造函数前加explicit没有意义。

## 1.3 const关键字
### 1.3.1 const关键字的作用
1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针和指针常量；<br>
指针本身是一个对象，它又可以指向另一个对象。因此const修饰指针时，指针本身是不是常量和指针指向的对象是不是常量是两个独立的问题。<br>
**对于一般的变量来说，用const修饰时没有顶层和底层之分，只有指针这种复合类型的基本变量，才有这种区别。**<br>
**顶层const表示指针本身是一个常量，底层const表示指针指向的对象是一个常量。**<br>
顶层const，指针常量，表示指针本身是一个不可修改的常量。<br>
底层const, 常量指针，表示指针所指向的值为一个常量。<br>
出现在**\***右边的const表示顶层const，出现在**\***左边的const表示底层const。<br>
3. 常量引用，经常用于形参类型，既避免了拷贝，又避免了函数对参数值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

### 1.3.2 用const来修饰成员函数的目的是什么？
1. 类的成员函数后面加const，表明这个函数不会对类对象的非静态数据成员做任何修改。在设计类时，一个原则就是对于不改变数据成员的成员函数后面都要加const，而对于改变数据成员的成员函数不能用const修饰；
2. 常量对象可以调用被const修饰的成员函数，而不能调用非const修饰的成员函数。

### 1.3.3 

# 2. C++中指针和引用的区别
**是否可以为空和是否可以被重新赋值**
## 2.1 非空区别
在任何情况下都不能使用指向空值的引用，但指针可以不指向任何对象。不存在指向空值的引用意味着使用引用的代码效率要比使用指针的高。
## 2.2 合法性区别
在使用引用之前不需要测试它的合法性，相反，指针总应该被测试，以防止其为空。
## 2.3 可修改区别
指针可以被重新赋值以指向另一个不同的对象，单引用总是指向在初始化时被指定的对象，以后不能改变，但是引用指向对象的内容可以改变。
## 2.4 应用区别
考虑到存在不指向任何对象的可能性或者能够在不同时刻指向不同对象时应该使用指针。总是指向一个对象而且只能指向一个对象时应该使用引用。

# 3. 数组和指针的区别
1. 数组用来保存数据，指针用来保存数据的地址；
2. 数组中的数据可以直接访问，指针所指向的数据需要间接访问，即首先取得指针的内容，把它作为地址，然后再从这个地址中提取数据；
3. 数组通常用于存储固定数目且数据类型相同的元素，指针通常用于动态数据结构；
4. 数组通常隐式分配与删除，指针相关的函数为malloc()和free();
5. 数组自身即为数据名， 指针通常指向匿名数据。

### 对于一个数组**char a[10]**而言，如果访问a[i]，步骤是：
1. 将a的地址读入寄存器，由于a其实就是一个别名，所以a的地址本身就是a[0]的地址；
2. 根据类型计算并添加偏移，得到目标地址；
3. 访问内存得到a[i]。

### 而如果声明是**char \*a**，访问a[i]，其步骤是：
1. 将a的地址读入寄存器，a是一个指针，指向a[0]的地址；
2. 访问内存读取a的值，得到a[0]的地址；
3. 根据类型计算并添加偏移量，得到目标地址；
4. 访问内存得到a[i]。

# 4. C++中的野指针
**野指针即指向不可用内存区域的指针。**<br>
野指针不是NULL指针，是指向“垃圾”内存的指针，如果对野指针进行操作，将会使程序发生不可预知的错误，甚至可能直接引起程序崩溃。
1. 指针变量没有初始化；<br>
指针变量在创建时应当被初始化，要么将其设置为NULL，要么让它指向合法的内存。
2. 指针指向的内存被释放了，但是指针本身没有被置NULL；<br>
对于堆内存操作，我们分配了一些空间（使用malloc函数、calloc函数或new操作符），使用完后释放（使用free函数或delete操作符），在指针指向的内存被释放后，应该将指针置为NULL。
3. 指针超过了变量的作用范围。<br>
即在变量的作用范围之外使用了指向变量地址的指针。这一般发生在将调用函数中的局部变量的地址传出来。这点容易被忽略，虽然代码是很可能可以执行无误，然而却是极其危险的。局部变量的作用范围虽然已经结束，内存已经被释放，然而地址值仍是可用的，不过随时都可能被内存管理分配给其他变量。

# 5. C++中的智能指针
## 5.1 

# 6. this指针
1. this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用还成员函数的那个对象；
2. 当对一个对象调用成员函数时，编译程序现将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用this指针；
3. this 指针被隐含地声明为： ClassName \*const this, 这意味着this指针为常量指针，不能改变其内容，即不能给this指针赋值，在ClassName类的const成员函数中，this指针类型为：const ClassName\* const,这说明此时this指针所指的对象不可修改（即不能对这种对象的数据成员进行赋值操作）；
4. this并不是一个常规变量，而是个右值，所以不能取得this的地址；
5. 在下列场景中，经常需要显式引用this指针：<br>
	1. 实现对对象的链式引用；
	2. 为避免对同一对象进行赋值操作；
	3. 在实现一些数据结构时。

# 7. inline 内联函数
## 7.1 内联函数的特征
1. 相当于把内联函数里面的内容写在了调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，但内联比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

## 7.2 编译器对 inline 函数的处理步骤
1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

## 7.3 inline 内联函数的优缺点
### 7.3.1 优点：
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

### 7.3.2 缺点
1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

# 8. 程序所用到的内存段
## 8.1 bss(Block Started by Symbol)段
通常是指用来存放程序中**未初始化的全局变量**的一块内存区域，属于静态内存分配。
## 8.2 data段
通常是指用来存放程序中**已初始化的全局变量**的一块内存区域，属于静态内存分配。
## 8.3 text段(code/text segment)
通常是指用来存放程序**执行代码**的一块内存区域。
## 8.4 堆(heap)
堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。<br>
当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张)；<br>
当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。 <br>
## 8.5 栈(stack)
栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。<br>
除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。<br>
由于栈的先进后出(FILO)特点，所以栈特别方便用来保存/恢复调用现场。<br>
从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。<br>

# 9. C++11 的新基础特性
## 9.1 预定义宏
**使用这些宏，可以检查机器环境对C标准和C库的支持情况。**<br>
1. \_\_STDC\_HOSTED\_\_ 如果编译器的目标系统环境中包含完整的标准C库，那么这个宏就定义为1，否则宏的值为0。
2. \_\_STDC\_\_ C编译器通常用这个宏的值来表示编译器的实现是否与C标准一致，C++11标准中这个宏是否定义以及定成什么值由编译器决定。
3. \_\_STDC\_VERSION\_\_ C编译器通常用这个宏来表示所支持的C标准的版本，比如1999mmL。C++11标准中这个宏是否定义以及定成什么值将由编译器决定。
4. \_\_STDC\_ISO\_10646\_\_ 这个宏通常定义为一个yyyymmL格式的整数常量，例如199712L，用来表示C++编译环境复合某个版本的ISO/IEC10646标准。

## 9.2 \_\_func\_\_ 用于获取当前函数名字字符串的宏

## 9.3 \_Pragma 操作符
预处理指令#pragma 的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。<br>
\_Pragma预处理操作符与#pragma功能相同，**\_Pragma 可以在宏中展开**。

## 9.4 变长参数的宏定义以及 \_\_VA\_ARGS\_\_
变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义__VA_ARGS__ 则可以在宏定义的实现部分替换省略号所代表的字符串。<br>

## 9.5 宽窄字符串的连接
在C++11标准中，在将窄字符串(char:ANSI)和宽字符串(wchar_t:UNICODE)进行连接时，支持C++11标准的编译器会将窄字符串转换成宽字符串，然后再与宽字符串进行连接。

## 9.6 long long 整型
在C++11中，标准要求long long 整型可以在不同平台上有不同的长度，但至少有64位。

## 9.7 宏 \_\_cplusplus 

## 9.8 静态断言
断言帮助开发者快速定位问题违反程序前提条件的错误，不过断言只在程序运行时执行，这在某些情况下，是不可接受的，特别是对于模板实例化时出现的错误，应该在编译器就确定。在C++11中引入了static_assert断言来解决问题，它支持两个参数输入，一个是返回bool型的表达式，另一个是警告信息。

## 9.9 noexcept修饰符和noexcept操作符

## 9.10 快速初始化成员变量

## 9.11 非静态成员的sizeof

## 9.12 扩展的friend语法

## 9.13 final/override控制

## 9.14 模板函数的默认模板参数

## 9.15 外部模板

## 9.16 局部和匿名类型作模板实参


# 10. C/C++ 程序编译流程
## 10.1 预处理
**预处理相当于根据预处理指令组装新的C/C++程序。经过预处理、会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义与原本文件无异，只是内容上有所不同。**
### 10.1.1 读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理
1. 将所有的“#define”删除，并且展开所有的宏定义。<br>
2. 处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。 <br>
3. 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。<br>

### 10.1.2 删除所有注释

### 10.1.3 添加行号和文件名标识
以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告是能够显示行号。

### 10.1.4 保留所有的#pragma编译器指令

## 10.2 编译
将预处理完的文件进行一系列词法分析、语法分析、语义检查和中间代码生成、代码优化和目标代码生成，产生相应的汇编代码文件。
## 10.3 汇编
**将编译完成的代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。**<br>
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。

## 10.4 链接
**通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。**
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。<br>
例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。<br>
链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。<br>