# 1. 若干关键字
## 1.1 static关键字
**static被用来控制变量的存储方式和可见性。**

### 1.1.1 引入缘由
在函数内部定义的变量、当程序执行到定义处时，编译器为变量在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉。为了让变量的值保存至下一次调用时，最容易想到的方法是将其定义为全局变量，但是定义为全局变量破坏了此变量的访问范围**使得在此函数中定义的变量，不仅仅只受此函数控制**, **static**关键字可以很好地解决这个问题。
另外，在C++中，需要一个数据对象为**整个类而非某个对象**服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。

### 1.1.2 静态数据的存储
全局(静态)存储区分为DATA段和BSS段。DATA段(全局初始化区)存放初始化的全局变量和静态变量，BSS段(全局未初始化区)存放未初始化的全局变量和静态变量，程序运行结束时自动释放。<br>其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
在**C++中static的内部实现机制**：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。<br>这样，它的空间分配有三个可能的地方:

1. 是作为类的外部接口的头文件，那里有类声明；
2. 是类定义的内部实现，那里有类的成员函数定义；
3. 是应用程序的main()函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义(只能声明数据成员)。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。<br>
优势：可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

### 1.1.3 在C/C++中static关键字的作用
1. 在修饰变量的时候，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
2. static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。
3. static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为0。
4. 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
5. 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

### 1.1.4 静态全局变量的特点
1. 静态变量都在全局数据区分配内存；
2. 未经初始化的静态全局变量会被程序自动初始化为0(在函数体内声明的变量的自动初始化值是随机的，在函数体外被声明的自动变量也会被初始化为0)；
3. 静态全局变量在声明它的整个文件里都是可见的，在此文件外是不可见的。(在其他文件中可以定义相同名字的变量，不会发生冲突)。

### 1.1.5 静态局部变量的特点
1. 该变量在全局数据区分配内存；
2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；
4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

### 1.1.6 全局变量和静态全局变量的区别
1. 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
2. 全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

### 1.1.7 静态数据成员
1. 静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。
2. 静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。
3. 静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0。
4. 静态数据成员既可以通过对象名引用，也可以通过类名引用。

### 1.1.8 静态函数成员
1. 静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
2. 非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
3. 静态成员函数主要用来访问静态数据成员而不能访问非静态成员。

### 1.1.9 关键字static的作用是什么？
1. 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值。
2. 在模块内的static全局变量可以被模块内的所有函数访问，但不能被模块外其他函数访问。
3. 在模块内的static函数只可以被这一模块的其他函数调用，这个函数的适用范围被限制在声明它的模块内。
4. 在类中的static成员变量属于整个类所有，对类的所有对象只有一份复制。
5. 在类中的static成员函数属于整个类所有，这个函数不接受this指针，因而只能访问类的static成员变量。

### 1.1.10 为什么静态成员不能在类内初始化？
**静态成员属于类作用域，但不属于类对象，它的生命周期和普通的静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放，所以不能在类的构造函数中进行初始化。**
因为静态成员属于整个类，而不是属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。<br>
所以在类内只有静态成员的声明，在类外定义和初始化是保证static成员变量只被定义一次的方法。


  
## 1.2 explicit关键字
1. explicit关键字只需用于类内的单参数构造函数前面，防止类构造函数的隐式自动转换；
2. 对于无参数的构造函数和多参数的构造函数总是显式调用，这种情况在构造函数前加explicit没有意义。

## 1.2 volatile关键字

## 1.3 const关键字

### 1.3.1 const关键字的作用

#### 1.3.1.1 修饰普通变量
说明该变量的值不可以被改变

#### 1.3.1.2 修饰指针
分为指向常量的指针和指针常量；<br>
指针本身是一个对象，它又可以指向另一个对象。因此const修饰指针时，指针本身是不是常量和指针指向的对象是不是常量是两个**独立**的问题。<br>
**对于一般的变量来说，用const修饰时没有顶层和底层之分，只有指针这种复合类型的基本变量，才有这种区别。**<br>
**顶层const表示指针本身是一个常量，底层const表示指针指向的对象是一个常量。**<br>
顶层const，指针常量，表示指针本身是一个不可修改的常量。<br>
底层const, 常量指针，表示指针所指向的值为一个常量。<br>
出现在**\***右边的const表示顶层const，出现在**\***左边的const表示底层const。<br>

#### 1.3.1.3 修饰函数参数
const修饰参数的值表示在函数体中不能修改此参数的值(包括参数本身的值或者参数本身的值)。<br>
1. void function(const int Var);     //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用)。
2. void function(const char* Var);   //参数指针所指内容为常量不可变。
3. void function(char* const Var);   //参数指针本身为常量不可变(无意义，var本身也是通过传值的形式赋值的)。
4. void function(const Class& Var);  //引用参数在函数内不可以改变。
参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不必用const修饰。

#### 1.3.1.4 修饰类对象/对象指针/对象引用
1. const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改，对于对象指针和对象引用也是一样。
2. const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。

#### 1.3.1.5 修饰数据成员
1. const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const数据成员的值是什么。
2. const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，可以用类中的枚举常量来实现。

#### 1.3.1.6 修饰成员函数
一般把const写在成员函数的最后表示const修饰类的成员函数，用const修饰的成员函数不能改变对象的成员变量。
说明该成员函数内不能修改成员变量。

#### 1.3.1.7 修饰成员函数的返回值
１. 一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回const对象，或返回const对象的引用，则返回值具有const属性，返回实例只能访问类中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。 
2. 如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针所指的内容）不能被修改，该返回值只能被赋给加const 修饰的同类型指针。
3. 函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。

### 1.3.2 用const来修饰成员函数的目的是什么？
1. 类的成员函数后面加const，表明这个函数不会对类对象的非静态数据成员做任何修改。在设计类时，一个原则就是对于不改变数据成员的成员函数后面都要加const，而对于改变数据成员的成员函数不能用const修饰；
2. 常量对象可以调用被const修饰的成员函数，而不能调用非const修饰的成员函数。

### 1.3.3 const常量和define宏定义的区别
1. 编译器处理方式不同： define宏是在预处理阶段展开，const常量是编译运行阶段使用。
2. 类型和安全检查不同： define宏没有类型，不做任何类型检查，仅仅是展开，const常量有具体的类型，在编译阶段会执行类型检查。
3. 存储方式不同： define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存，const常量会在内存中分配(可以是堆中也可以是栈中)。

### 1.3.4 不同类型的类数据成员的声明、定义、初始化


## 1.4 goto关键字
goto语句允许把控制无条件转移到同一函数内的被标记的语句。<br>
goto 语句一个很好的作用是**退出深嵌套例程**。

## 1.5 sizeof关键字
由于C++每种类型的大小都是有编译器自行决定的，为了增加可移植性，可以用sizeof运算符获得该数据类型占用的字节数。

### 1.5.1 数据对齐(Data Alignment)
1. CPU的优化规则大致原则是：对于n字节的元素(n=2,4,8,...)，它的首地址能被n整除，才能获得最好的性能。
2. 数据对齐是指数据所在的内存地址必须是该数据长度的整数倍。
3. 结构体的数据对齐：在默认情况下，为了方便对结构体内元素的访问和管理，当结构体内的元素的长度都小于处理器位数的时候，便以结构体里面最长的数据元素为对齐单位，也就是说，结构体的长度一定是最长的数据元素的整数倍。如果结构体内存在长度大于处理器位数的元素，那么就以处理器的位数为对齐单位。但是结构体内类型相同的连续元素和数组一样，将在连续的空间内。

### 1.5.2 sizeof和strlen之间的区别
1. sizeof操作符的结果是size_t，它在头文件中的typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。
2. sizeof是运算符，strlen是函数。
3. sizeof可以用类型/函数做参数，strlen只能用char\*做参数，且必须是以“\0”结尾的。
4. 数组做sizeof参数时不退化，传递给strlen就退化为指针。
5. 大部分编译程序在编译的时候就把sizeof计算过了，是类型或是变量的长度。这就是sizeof可以用来定义数组维度的原因。
6. strlen的结果要在运行时才能计算出来，用来计算字符串的长度，而不是类型所占内存的大小。
7. sizeof后如果是类型必须加括号，如果是变量名可以不加括号，这是因为sizeof是个操作符而不是函数。
8. 当使用了一个结构类型或者变量时，sizeof返回实际的大小。当使用一静态的空间数组时，sizeof返回全部数组的尺寸。sizeof操作符不能返回被动态分配的数组或者外部数组的尺寸。
9. 数组作为参数传递给函数时传递的是指针而不是数组，传递的是数组的首地址。在C++里传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小。
10. 计算结构变量的大小就必须讨论数据对齐问题。
11. sizeof操作符不能用于函数类型、不完全类型或者位字段。不完全类型是指具有位置存储数据大小的数据类型，如未知存储大小的数组类型、未知内容的结构或者联合类型、void类型。

### 1.5.3 sizeof的使用场合
1. sizeof操作符的一个主要用途是与存储分配和I/O系统那样的例程进行通信。
2. 获取某种类型的对象在内存中所占的单元字节。
3. 在动态分配一对象时，sizeof可以让系统知道要分配多少内存。
4. 便于一些类型的扩充，在Windows中有很多结构类型就有一个专用的字段用来存放该类型的字节大小。
5. 由于操作数的字节数在实现时可能出现变化，建议在涉及操作数字节大小时用sizeof代替常量计算。
6. 如果操作数是函数中的数组形参或者函数类型的形参，sizeof给出其指针的大小。

## 1.6 register关键字
在一般情况下，变量(包括静态存储方式和动态存储方式)的值是放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到CPU中的运算器。经过运算器进行运算，如果需要存数，再从运算器将数据送到CPU存放。<br>
如果有一些变量使用频繁（例如执行上千次的循环，每一次循环都是需要引用某一个局部变量），则存取变量的值需要花费很多的时间。为了提高效率，C++允许将局部变量的值存放在cpu中的寄存器中，需要用的时直接从寄存器取出参加运算，不必再到内存中去取值。由于对寄存器的存取速度远远高于对内存的存取速度，因此这样做可以提高执行效率。这种变量就叫做**寄存器变量**，用关键字register作声明。

### 1.6.1 寄存器变量注意事项
1. 首先，register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
2. 其次，因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
3. 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。
4. 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。

## 1.7 asm关键字
允许在 C++ 程序中嵌入汇编代码。

## 1.8 enum关键字
枚举类型

## 1.9 try...throw...catch关键字
**C++异常处理**<br>
异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。<br>
1. throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。
2. catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。
3. try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。

## 1.10 typedef关键字
类型定义 **typedef 类型 定义名**<br>
类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。
## 1.11 union关键字
union(联合)，类似于enum。不同的是enum实质上是int类型的，而union可以用于所有类型，并且其占用空间是随着实际类型大小变化的。

## 1.12 this关键字
对象的存储空间是数据成员所占的空间，成员函数的代码存储在对象的空间之外。不同的对象调用同一函数的代码段。在每个成员函数中都有一个名字为this的指向本类对象的指针。this指针是当前被调函数所在对象的起始地址，通过这个地址可以访问该对象的数据成员和成员函数。在类中写成员的地方，都可以写成this->(成员名)。

## 1.13 typeid关键字
如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作数返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。

## 1.14 mutable关键字
mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能由于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。

## 1.15 

# 2. C++中指针和引用的区别
**是否可以为空和是否可以被重新赋值**
## 2.1 非空区别
在任何情况下都不能使用指向空值的引用，但指针可以不指向任何对象。不存在指向空值的引用意味着使用引用的代码效率要比使用指针的高。
## 2.2 合法性区别
在使用引用之前不需要测试它的合法性，相反，指针总应该被测试，以防止其为空。
## 2.3 可修改区别
指针可以被重新赋值以指向另一个不同的对象，单引用总是指向在初始化时被指定的对象，以后不能改变，但是引用指向对象的内容可以改变。
## 2.4 应用区别
考虑到存在不指向任何对象的可能性或者能够在不同时刻指向不同对象时应该使用指针。总是指向一个对象而且只能指向一个对象时应该使用引用。

# 3. 数组和指针的区别
1. 数组用来保存数据，指针用来保存数据的地址；
2. 数组中的数据可以直接访问，指针所指向的数据需要间接访问，即首先取得指针的内容，把它作为地址，然后再从这个地址中提取数据；
3. 数组通常用于存储固定数目且数据类型相同的元素，指针通常用于动态数据结构；
4. 数组通常隐式分配与删除，指针相关的函数为malloc()和free();
5. 数组自身即为数据名，指针通常指向匿名数据。

### 对于一个数组**char a[10]**而言，如果访问a[i]，步骤是：
1. 将a的地址读入寄存器，由于a其实就是一个别名，所以a的地址本身就是a[0]的地址；
2. 根据类型计算并添加偏移，得到目标地址；
3. 访问内存得到a[i]。

### 而如果声明是**char \*a**，访问a[i]，其步骤是：
1. 将a的地址读入寄存器，a是一个指针，指向a[0]的地址；
2. 访问内存读取a的值，得到a[0]的地址；
3. 根据类型计算并添加偏移量，得到目标地址；
4. 访问内存得到a[i]。


# 4. C++中的野指针
**野指针即指向不可用内存区域的指针。**<br>
野指针不是NULL指针，是指向“垃圾”内存的指针，如果对野指针进行操作，将会使程序发生不可预知的错误，甚至可能直接引起程序崩溃。
1. 指针变量没有初始化；<br>
指针变量在创建时应当被初始化，要么将其设置为NULL，要么让它指向合法的内存。
2. 指针指向的内存被释放了，但是指针本身没有被置NULL；<br>
对于堆内存操作，我们分配了一些空间（使用malloc函数、calloc函数或new操作符），使用完后释放（使用free函数或delete操作符），在指针指向的内存被释放后，应该将指针置为NULL。
3. 指针超过了变量的作用范围。<br>
即在变量的作用范围之外使用了指向变量地址的指针。这一般发生在将调用函数中的局部变量的地址传出来。这点容易被忽略，虽然代码是很可能可以执行无误，然而却是极其危险的。局部变量的作用范围虽然已经结束，内存已经被释放，然而地址值仍是可用的，不过随时都可能被内存管理分配给其他变量。

# 5. C++中的智能指针
## 5.1 

# 6. this指针
1. this 指针是一个隐含于每一个非静态成员函数中的特殊指针，它指向调用还成员函数的那个对象；
2. 当对一个对象调用成员函数时，编译程序现将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用this指针；
3. this 指针被隐含地声明为： ClassName \*const this, 这意味着this指针为常量指针，不能改变其内容，即不能给this指针赋值，在ClassName类的const成员函数中，this指针类型为：const ClassName\* const,这说明此时this指针所指的对象不可修改（即不能对这种对象的数据成员进行赋值操作）；
4. this并不是一个常规变量，而是个右值，所以不能取得this的地址；
5. 在下列场景中，经常需要显式引用this指针：<br>
	1. 实现对对象的链式引用；
	2. 为避免对同一对象进行赋值操作；
	3. 在实现一些数据结构时。

# 7. inline 内联函数
## 7.1 内联函数的特征
1. 相当于把内联函数里面的内容写在了调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，但内联比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

## 7.2 编译器对 inline 函数的处理步骤
1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

## 7.3 inline 内联函数的优缺点
### 7.3.1 优点：
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

### 7.3.2 缺点
1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

# 8. 程序所用到的内存段
## 8.1 bss(Block Started by Symbol)段
通常是指用来存放程序中**未初始化的全局变量**的一块内存区域，属于静态内存分配。
## 8.2 data段
通常是指用来存放程序中**已初始化的全局变量**的一块内存区域，属于静态内存分配。
## 8.3 text段(code/text segment)
通常是指用来存放程序**执行代码**的一块内存区域。
## 8.4 堆(heap)
1. 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
2. 当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)。
3. 当利用free等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减)。
4. 堆是向高地址扩展的数据结构，是不连续的内存区域。
5. 堆容易产生内存泄漏，大量的new/delete操作会造成内存空间的不连续。

## 8.5 栈(stack)
1. 栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。
2. 在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。
3. 由于栈的先进后出(FILO)特点，所以栈特别方便用来保存/恢复调用现场。
4. 从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。
5. 栈是向低地址扩展的数据结构，是一块连续的内存区域。

# 9. C++11 的新基础特性
## 9.1 预定义宏
**使用这些宏，可以检查机器环境对C标准和C库的支持情况。**<br>
1. \_\_STDC\_HOSTED\_\_ 如果编译器的目标系统环境中包含完整的标准C库，那么这个宏就定义为1，否则宏的值为0。
2. \_\_STDC\_\_ C编译器通常用这个宏的值来表示编译器的实现是否与C标准一致，C++11标准中这个宏是否定义以及定成什么值由编译器决定。
3. \_\_STDC\_VERSION\_\_ C编译器通常用这个宏来表示所支持的C标准的版本，比如1999mmL。C++11标准中这个宏是否定义以及定成什么值将由编译器决定。
4. \_\_STDC\_ISO\_10646\_\_ 这个宏通常定义为一个yyyymmL格式的整数常量，例如199712L，用来表示C++编译环境复合某个版本的ISO/IEC10646标准。

## 9.2 \_\_func\_\_ 用于获取当前函数名字字符串的宏

## 9.3 \_Pragma 操作符
预处理指令#pragma 的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。<br>
\_Pragma预处理操作符与#pragma功能相同，**\_Pragma 可以在宏中展开**。

## 9.4 变长参数的宏定义以及 \_\_VA\_ARGS\_\_
变长参数的宏定义是指在宏定义中参数列表的最后一个参数为省略号，而预定义__VA_ARGS__ 则可以在宏定义的实现部分替换省略号所代表的字符串。<br>

## 9.5 宽窄字符串的连接
在C++11标准中，在将窄字符串(char:ANSI)和宽字符串(wchar_t:UNICODE)进行连接时，支持C++11标准的编译器会将窄字符串转换成宽字符串，然后再与宽字符串进行连接。

## 9.6 long long 整型
在C++11中，标准要求long long 整型可以在不同平台上有不同的长度，但至少有64位。

## 9.7 宏 \_\_cplusplus 

## 9.8 静态断言
断言帮助开发者快速定位问题违反程序前提条件的错误，不过断言只在程序运行时执行，这在某些情况下，是不可接受的，特别是对于模板实例化时出现的错误，应该在编译器就确定。在C++11中引入了static_assert断言来解决问题，它支持两个参数输入，一个是返回bool型的表达式，另一个是警告信息。

## 9.9 noexcept修饰符和noexcept操作符

## 9.10 快速初始化成员变量

## 9.11 非静态成员的sizeof

## 9.12 扩展的friend语法

## 9.13 final/override控制

## 9.14 模板函数的默认模板参数

## 9.15 外部模板

## 9.16 局部和匿名类型作模板实参


# 10. C/C++ 程序编译流程
## 10.1 预处理
**预处理相当于根据预处理指令组装新的C/C++程序。经过预处理、会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义与原本文件无异，只是内容上有所不同。**
### 10.1.1 读取C/C++源程序，对其中的伪指令（以#开头的指令）进行处理
1. 将所有的“#define”删除，并且展开所有的宏定义。<br>
2. 处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。 <br>
3. 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。<br>

### 10.1.2 删除所有注释

### 10.1.3 添加行号和文件名标识
以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告是能够显示行号。

### 10.1.4 保留所有的#pragma编译器指令

## 10.2 编译
将预处理完的文件进行一系列词法分析、语法分析、语义检查和中间代码生成、代码优化和目标代码生成，产生相应的汇编代码文件。

## 10.3 汇编
**将编译完成的代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。**<br>
汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。

## 10.4 链接
**通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。**
由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。<br>
例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。<br>
链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。<br>


# 11. C++内存管理
## 11.1 C++ 内存管理详解
### 11.1.1 内存分配方式
#### 11.1.1.1 分配方式简介
在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。<br>
1. **栈**，在执行函数时，**函数内局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
2. **堆**，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
3. **自由存储区**，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
4. **全局/静态存储区**，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
5. **常量存储区**，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

#### 11.1.1.2 明确区分堆与栈

#### 11.1.1.3 堆和栈的区别
1. 管理方式<br>
对于栈来讲，其是由编译器自动管理，无需手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄漏。
2. 空间大小<br>

3. 能否产生碎片<br>
对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。
4. 生长方向<br>
对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
5. 分配方式<br>
堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
6. 分配效率<br>
栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。


# 12. C++中的虚函数(表)实现机制
## 12.1 只有数据成员的类对象
成员变量是按照定义的顺序来保存的，最先声明在低地址，然后依次保存。类对象的大小是所有成员变量大小之和。(是否有字节对齐？)

## 12.2 没有虚函数的类对象
如果一个函数不是虚函数，那么就可能发生动态绑定，也就不会对类对象的布局造成任何影响。<br>
当调用一个非虚函数时，那么调用的一定就是当前指针类型拥有的那个成员函数，这种调用机制在编译时期就确定下来了。

## 12.3 仅拥有一个虚函数的类对象
相对于没有虚函数的类对象，仅拥有一个虚函数的类对象的内存分布开始时会多一个类型为void\*\*的指针(\_\_vfptr, 虚函数表(vtable)指针)，所占内存大小为一个指针大小。
### 12.3.1 为什么\_\_vfptr被定义成一个指向指针数组的指针，而不是直接定义成一个指针数组？
如果仅是一个指针的话，就无法轻易修改那个数组里面的内容，因为虚函数表并不属于类对象的一部分，属于类对象的，仅是一个指向虚函数表的指针\_\_vfptr而已。
## 12.4 拥有多个虚函数的类对象
1. \_\_vfptr只是一个指针，指向一个函数指针数组(虚函数表)。
2. 增加一个虚函数，只是简单地向该类对应的虚函数表中增加一项而已，并不会影响到类对象的大小和布局情况。
3. 同一个类的不同实例共用一份虚函数表，它们通过各自的虚函数表指针\_\_vfptr(void\*\*类型)指向该虚函数表。
4. 虚函数表是编译器在编译时期创建的。
5. 定义类对象时，编译器自动将类对象的\_\_vfptr指向该类的虚函数表。

## 12.5 单继承且本身不存在虚函数的继承类的内存布局
基类的内存布局+自身独有的成员数据布局。<br>

## 12.6 本身没有定义新的虚函数但存在基类虚函数覆盖的单继承类的内存布局   
基类中在派生类里被覆盖掉的虚函数，其对应的派生类虚函数表的中的函数指针也会被相应地覆盖。

## 12.7 定义了基类没有的虚函数的单继承的类对象布局
1. 派生类的虚函数表被加在基类的虚函数表后面。
2. 派生类新加的虚函数指针对基类的虚函数表不会有影响。  

## 12.8 多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局
1. 按照基类的声明顺序, 基类的成员依次分布在继承中。
2. 在派生类中被覆盖的虚函数在基类虚函数表中的指针会被相应地覆盖。
3. 派生类的虚函数表保存在第一个拥有虚函数表的基类的虚函数表后面。

## 12.9 如果第一个直接基类没有虚函数(表)
1. 有虚函数表的基类会放在对象内存的前面。

## 12.10 多(2)继承的两个基类都没有虚函数(表)
1. 对象内存分布中会先创建虚函数表，在依次分布基类的成员和派生类的成员。

## 12.11 多(3)继承的三个基类的虚函数(表)分别是有、没有、有
1. 对象内存分布中会按顺序分布拥有虚函数表的基类、其他基类、派生类。

# 13. 四种强制类型转换操作符
**cast-name<type>(expression)**

## 13.1 static_cast
主要用于非多态类型之间的转换，不提供运行时的检查来确保转换的安全性。主要在以下几种场合中使用：<br>
1. 用于类层次结构中，基类和子类之间指针和引用的转换；<br>
当进行上行转换，也就是把子类的指针或引用转换成父类表示，这种转换是安全的；<br>
当进行下行转换，也就是把父类的指针或引用转换成子类表示，这种转换是不安全的，也需要程序员来保证；<br>
2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum等等，这种转换的安全性需要程序员来保证；
3. 把void指针转换成目标类型的指针，是极其不安全的；

## 13.2 dynamic_cast
### 13.2.1 转换方式
1. dynamic_cast<type*>(e) type必须是一个类类型且必须是一个有效的指针
2. dynamic_cast<type&>(e) type必须是一个类类型且必须是一个左值
3. dynamic_cast<type&&>(e) type必须是一个类类型且必须是一个右值<br>

e的类型必须符合以下三个条件中的任何一个：<br>
1. e的类型是目标类型type的公有派生类
2. e的类型是目标类型type的公有基类
3. e的类型就是目标type的类型

其他要点:<br>
1. 如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。
2. 如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常(该异常定义在typeinfo标准库头文件中)。
3. e也可以是一个空指针，结果是所需类型的空指针。
4. dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换(cross cast)。
5. 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。
6. 在类层次间进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。 
7. dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。

### 13.2.2 


## 13.3 const_cast


## 13.4 reinterpret_cast


# 14. 隐式类型转换
C++定义了一组内置类型对象之间的标准转换，在必要时它们被编译器隐式地应用到对象上。隐式类型转换发生在以下这些典型情况下：<br>
1. 在混合类型的算数表达式中： 目标转换类型是最宽的数据类型。(算数转换，Arithmetic Conversion)
2. 用一种类型的表达式赋值给另一种类型的对象： 目标转换类型是被赋值对象的类型。
3. 把一个表达式传递给一个函数，调用表达式的类型与形式参数的类型不相同： 目标转换类型是形式参数的类型。
4. 从一个函数返回一个表达式的类型与返回类型不相同： 目标转换类型是返回类型。

## 14.1 算数转换
算数转换保证了二元操作符，如加法或乘法的两个操作数被提升为相同的类型，然后再用它表示结果的类型。<br>

### 14.1.1 算数转换的通用指导原则
1. 为了防止精度损失，如果有必要的话，类型总是被提升为较宽的类型。
2. 所有含有小于整型的有序类型的算数表达式在计算之前其类型都会被转换成整型。

### 14.1.2 整值提升


# 15. C++常用库函数

## 15.1 数学函数
0. 头文件 #include <math> 或者 #include <math.h>
1. int abs(int x)	        求整数x的绝对值	绝对值
2. double acos(double x)	计算arcos(x)的值	计算结果
3. double asin(double x)	计算arsin(x)的值	计算结果
4. double atan(double x)	计算arctan(x)的值	计算结果
5. double cos(double x)	    计算cos(x)的值	计算结果
6. double cosh(double x)	计算x的双曲余弦cosh(x)的值	计算结果
7. double exp(double x)	    求的值	计算结果
8. double fabs(double x)	求实数x的绝对值	绝对值
9. double fmod(double x)	求x/y的余数	余数的双精度数
10. long labs(long x)	    求长整型数的绝对值	绝对值
11. double log(double x)	计算In(x)的值	计算结果
12. double log10(double x)	计算的值	计算结果
13. double modf(double x, double \*y)	取x的整数部分送到y所指向的单元格中	x的小数部分
14. double pow(double x, double y)	    求x的y次幂的值	计算结果
15. double sin(double x)	            计算sin(x)的值	计算结果
16. double sqrt(double x)	            求的值	计算结果
17. double tan(double x)	            计算tan(x)的值	计算结果
18. fcvt	将浮点型数转化为字符串	  

## 15.2 字符串处理函数
0. 头文件 #include <string> 或者 #include <string.h>
1. void \*memcpy(void \*p1, const void \*p2 size_t n) 
存储器拷贝，将p2所指向的共n个字节拷贝到p1所指向的存储区中，目的存储区的起始地址（实现任意数据类型之间的拷贝）
2. void \*memset(void \*p int v, size_t n)
将v的值作为p所指向的区域的值，n是p所指向区域的大小，该区域的起始地址
3. char \*strcpy(char \*p1, const char \*p2) 
将p2所指向的字符串拷贝到p1所指向的存储区中，目的存储区的起始地址
4. char \*strcat(char \*p1, const char \*p2)	
将p2所指向的字符串连接到p1所指向的字符串后面，目的存储区的起始地址
5. int strcmp(const char \*p1, const char \*p2)	
比较p1,p2所指向的两个字符串的大小，两个字符串相同，返回0；若p1所指向的字符串小于p2所指的字符串，返回负值；否则，返回正值
6. int strlen(const char \*p)	
求p所指向的字符串的长度，字符串所包含的字符个数（不包括字符串结束标志’\n’）
7. char \*strncpy(char \*p1, const char \*p2, size_t n)	
将p2所指向的字符串（至多n个字符）拷贝到p1所指向的存储区中，目的存储区的起始地址(与strcpy()类似)
8. char \*strncat(char \*p1, const char \*p2, size_t n)
将p2所指向的字符串（至多n个字符）连接到p1所指向的字符串的后面	，目的存储区的起始地址(与strcat()类似)
9. char \*strncmp(const char \*p1, const char \*p2, size_t n)	
比较p1,p2所指向的两个字符串的大小，至多比较n个字符；两个字符串相同，返回0；若p1所指向的字符串小于p2所指的字符串，返回负值；否则，返回正值(与strcmp()类似)
10. char \*strstr(const char \*p1, const char \*p2)
判断p2所指向的字符串是否是p1所指向的字符串的子串，若是子串，返回开始位置的地址；否则返回0。

## 15.3 实现键盘和文件输入/输出的成员函数
0. 头文件#include <iostream> 或者 #include <iostream.h>
1. cin >> v	                                                                输入值送给变量	 
2. cout << exp	                                                            输出表达式exp的值	 
3. istream & istream::get(char &c)	                                        输入字符送给变量c	 
4. istream & istream::get(char \*, int , char = ‘\n’)	                    输入一行字符串	 
5. istream & istream::getline(char \*, int , char = ‘\n’)	                输入一行字符串	 
6. void ifstream::open(const char\*,int=ios::in, int = filebuf::openprot)	打开输入文件	 
7. void ofstream::open(const char\*,int=ios::out, int = filebuf::openprot)	打开输出文件	 
8. void fsream::open(const char\*, int, int = filebuf::openprot)	        打开输入/输出文件	 
9. ifstream::ifstream(const char\*,int = ios::in, int = filebuf::openprot)	构造函数打开输入文件	 
10. ofstream::ofstream(const char\*,int=ios::out, int = filebuf::openprot)	构造函数打开输出函数	 
11. fstream::fstream(const char\*, int, int = filebuf::openprot)	        构造函数打开输入/输出文件	 
12. void istream::close()	                                                关闭输入文件	 
13. void ofsream::close()	                                                关闭输出文件	 
14. void fsream::close()	                                                关闭输入/输出文件	 
15. istream & istream::read(char\*, int)	                                从文件中读取数据	 
16. ostream & istream::write(const char\*,int)	                            将数据写入文件中	 
17. int ios::eof()	                                                        判断是否到达打开文件的尾部	  1为到达2为没有
18. istream & istream::seekg(streampos)	                                    移动输入文件的指针	 
19. istream & istream::seekg(streamoff,ios::seek_dir)	                    移动输入文件的指针	 
20. streampos istream::tellg()	                                            取输入文件的指针	 
21. ostream & ostream::seekp(streampos)	                                    移动输出文件的指针	 
22. ostream & ostream::seekp(streamoff,ios::seek_dir)	                    移动输出文件的指针	 
23. streampos ostream::tellp()	                                            取输出文件的指针

## 15.4 其他常用函数
0. 头文件#include <stdlib> 或者 #include <stdlib.h>
1. void abort(void)	终止程序执行	 	不能结束工作
2. void exit(int)	终止程序执行	 	做结束工作
3. double atof(const char \*s)	将s所指向的字符串转换成实数	实数值	 
4. int atoi(const char \*s)	    将s所指向的字符串转换成整数	整数值	 
5. long atol(const char \*s)	将s所指的字符串转换成长整数	长整数值	 
6. int rand(void)	            产生一个随机整数	随机整数	 
7. void srand(unsigned int)	    初始化随机数产生器	 	 
8. int system(const char \*s)	将s所指向的字符串作为一个可执行文件，并加以执行	 	 
9. max(a, b)	求两个数中的大数	大数	参数为任意类型
10. min(a,b)	求两个数中的小数	小数	参数为任意类型	 


# 16. C++未定义
**未定义行为：语言标准没有规定，编译器自行决定的行为，在不同的编译器上有时会有不同的结果。**

## 16.1 位运算
位运算的运算对象是整数类型的，并且把位运算对象看成一个二进制位的集合。运算对象可以是带符号也可以是无符号。如果是带符号且值为负，那么位运算如何处理运算对象的符号位依赖于机器。而且此时左移操作可能会改变符号位的值，因此会产生未定义的行为。

关于符号位如何处理C++标准中没有明确的规定，所以强烈建议将位运算用于处理无符号类型。因此，在位运算的过程中，应该尽量将对象声明为无符号的，如unsigned int, unsigned char等。

## 16.2 求值顺序、运算符执行顺序、表达式
对于没有指定执行顺序的运算符，如果表达式指向并修改了同一对象，会引发错误并产生未定义的行为。

比如 int i = f1()\*f2(); 该表达式的乘法运算符没有指定运算的顺序，所以这里是f1()先执行还是f2()先执行是未定义的、未知的。f1()和f2()谁先执行取决于编译器如何处理。

## 16.3 类型转换、赋值
当赋值给带符号类型一个超过它表示范围的值时，结果是未定义的，程序可能继续工作，可能崩溃也可能产生数据垃圾。

## 16.4 函数的参数列表
实参与形参存在一一对应关系，但是没有规定实参的求值顺序，编译器可以任意可行的顺序对参数求值。这个与连乘的性质有些类似，连乘也没有规定求值的顺序，因此在使用过程中，需要注意求值顺序是否对结果有影响，不要想当然的认为参数列表是从左到右或者从右到左对表达式进行求值。

## 16.5 函数返回值
当函数具有非空的返回值时，如果函数的每一条执行路径中，有一条或多条路径可能没有相应的return语句，则可能会产生未定义的行为。当然，这种情况有可能编译器可以检测到并且给出相应的提示。但是如果编译器未检测到，则该函数在运行时的行为是未定义的。

## 16.6 返回局部对象的引用或指针
函数执行完之后，它所占用的存储空间也被释放掉。所以，函数终止意味着局部变量的引用将指向不再有效的内存区域。

## 16.7 避免无法预知和依赖于实现环境的行为
无法预知的行为源于编译器无法检测的错误，即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。

# 17. C++作用域
**C++ 程序中出现的每个名字，只在某些可能不连续的源码部分中有效，这些部分被称为其作用域。在作用域内，能用无限定名字查找将名字与其声明关联起来。**

## 17.1 块作用域
1. 块（复合语句）中的声明所引入的变量的潜在作用域，开始于其声明点并终止于该块末尾。实际作用域与潜在作用域相同，除非有内嵌块带有引入了相同名字的**声明**（这种情况下，从外层声明的作用域中排除掉嵌套声明的整个潜在作用域）。
2. 声明于异常处理块中的名字的潜在作用域开始于其声明点，并在该异常处理块结束时结束(一个catch语句为一个异常处理块)，而且在其他异常处理块或外围块中不在作用域中。
3. 在 for 循环的初始化语句中，在 for 循环的条件中，在范围 for 循环的范围声明中，在 if 语句或 switch 语句的初始化语句中， (C++17 起)在 if 语句、while 循环或 switch 语句的条件中，声明的名字的潜在作用域，开始于其声明点，并结束于控制语句的末尾。

## 17.2 函数形参作用域
函数形参（包括 lambda 表达式的形参）或函数局部预定义变量的潜在作用域开始于其声明点。<br>
1. 若最内层的外围函数声明符不是函数定义的声明符，则其潜在作用域终止于该函数声明符的结尾。
2. 否则，其潜在作用域终止于函数 try 块的最后异常处理块的末尾，或若不使用函数 try 块则为函数体的末尾。

## 17.3 函数作用域
声明于函数内的标号（且只有标号），在该函数和其所有内嵌代码块的任何位置都在作用域中，无论在其自身声明的前后。

## 17.4 命名空间作用域
1. 命名空间中声明的任何实体的潜在作用域均开始于其声明，并由其后的同一命名空间名的所有命名空间定义拼合起来，再加上对于将这个名字或其整个命名空间引入到其他作用域的每个 using 指令来说，包括这个作用域的剩余部分。

2. 翻译单元(编译单元)的顶层作用域（“文件作用域”或“全局作用域”）亦为命名空间，而被正式称作“全局命名空间作用域”。任何声明于全局命名空间作用域的实体的潜在作用域均开始于其声明，并持续到翻译单元的结尾。

3. 声明于无名命名空间或内联命名空间的实体的作用域包括外围命名空间。

## 17.5 类作用域
1. 类中声明的名字的潜在作用域开始于其声明点，并包含类体的剩余部分和所有函数体（无论是否定义于类定义外或在该名字的声明之前）、默认实参、异常规定、类内花括号或等号初始化器、契约条件 (C++20 起)，还（递归地）包括嵌套类中的所有这些内容。
2. 若在声明某个名字之前就在类体中使用，而有该名字的另一声明在作用域中，则程序非良构，不要求诊断。
3. 任何类成员名只能用于四种语境中：
	1. 在其自身的类作用域或在派生类的类作用域之中；
	2. 在对其类或其派生类的类型的表达式运用 . 运算符之后；
	3. 在对其类或其派生的类的指针类型的表达式运用 -> 运算符之后；
	4. 在对其类或其派生类的名字运用 :: 运算符之后。

## 17.6 枚举作用域
有作用域枚举中引入的枚举项的名字的作用域开始于其声明点，并终止于 enum 说明符的末尾（与之相反，无作用域枚举项的作用域在 enum 说明符的结尾后仍在作用域中）。

## 17.7 模板形参作用域
1. 模板形参名的潜在作用域直接开始于其声明点，并持续到于其中引入了它的最小模板声明的末尾。具体而言，模板形参能用于其后的模板形参的声明，及基类的指定，但不能用于其前的模板形参的声明。
2. 模板模板形参的形参名的潜在作用域，是该名字出现于其中的最小模板形参列表。
3. 与其他嵌套作用域类似，模板形参名在其自身的持续期间隐藏来自外层作用域的相同名字。

## 17.8 声明点
作用域始于声明点，它定位如下：
1. 对于简单声明所引入的变量和其他名字，声明点紧随该名字的声明符之后，且在其初始化器之前（若其存在）。
2. 类或模板的声明点，紧随其类头中所出现的命名类名的标识符（或指名模板特化的 template-id（模板标识））之后，并且在基类列表中已处于作用域中。
3. 枚举的声明点，紧随 enum 说明符或笼统枚举声明（取决于何者为先）中所出现的命名它的标识符之后。
4. 类型别名或别名模板的声明点紧随该别名所代表的类型标识（type-id）之后。
5. 枚举项的声明点紧随其定义之后（而非在初始化器之前，这点不同于变量）。
6. injected-class-name（注入类名）的声明点紧随其类（或类模板）定义的开花括号之后。

# 18 左值与右值

## 18.1 左值与右值
一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象，但它们是右值而非左值。可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的位置)。<br>
不同的运算符对运算对象的要求也各不相同有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到左值结果，有的得到右值结果。一个重要的原则是：在需要右值的地方可以用左值的代替，但是不能把右值当做左值(也就是位置)使用。当一个左值被当做右值使用时，实际使用的是它的内容(值)。下面常用的运算符是要用的左值的：
1. 赋值运算符需要一个(非常量)左值作为其左侧运算符，得到的结果也仍然是一个左值。
2. 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
3. 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
4. 内置类型和迭代器的递增递减运算符作用于左值。
5.
6. 


## 18.2 左值引用与右值引用的区别
1. 右值引用就是必须绑定到右值的引用，通过&&获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。
2. 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。
3. 返回左值的表达式包括返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符，返回右值的包括返回非引用类型的函数及算术、关系、位和后置递增/递减运算符。可以看到，左值的特点是有持久的状态，而右值是短暂的。


# 19. C++与其他语言

## 19.1 C、C++的联系和区别

### 19.1.1 C语言是C++的子集吗？C++是在C语言的基础上扩展而来并包含所有C语言的内容吗？
1. 从实用角度讲，C++属于C语言的一个超集，基本上兼容ANSI C。
2. 从编译角度上讲，C语言的有些特性在C++中并不支持。相反，ANSI C继承了C++的几个特性，包括原型和常量。因此，这两种语言并不是另一个的超集或子集；而且它们在一些通用构造的定义上也不同。尽管有这些不同，许多C程序在C++环境中仍能编译，而且许多最新的编译器同时提供C和C++的编译模式。但是，不能把C代码完全当做C++代码来编译，否则在遇到不兼容问题时会给程序带来错误。

### 19.1.2 C、C++在语言层面有什么区别？
1. C语言是一种结构化语言，重点在于算法和数据结构。C语言的设计首先考虑的是通过一个过程，对输入(或环境条件)进行运算处理得到输出(或实现过程(事务)控制)。而对于C++，首先考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程(事务)控制。
2. C++对数组定义进行了限制。在C语言中，初始化数组时不作数组溢出判断，这样就容易使数组没有足够大的空间存放数据而产生错误。C++对此作了一些改进，像char str[3]="Jim"这样的表达式就被认为是一个错误，但是它在C语言中是合法的。
3. 在C++中，声明语句可以穿插于语句之间。大家知道，在C语言中，一个语句块中的所有声明必须都放在所有语句的前面，而C++去掉了这个限制，使声明语句可以穿插于语句之间。
4. 在C++中，用户代码不能够调用主函数main()函数，但是在C语言中这是可以的（但是极少出现这种情况）。
5. C++中对函数原型的声明是严格的，要求必须完整，而在C语言中却没有这么严格。
6. 在C++中，由typedef定义的类型的名字不能与已有的结构名称冲突，但在C语言中却是允许的。
7. C++规定了更严格的类型处理，例如，当void\*指针赋值给另一个类型的指针时，C++要求必须进行强制类型转换，而在C语言中则无需这么做。
8. C++对C语言的关键字进行了扩充，增加了至少十几个。这些关键字在C语言中可以作为标识符使用，但是如果这样的C语言代码使用C++编译器进行编译，就会产生错误信息。
9. 在C++中，内层作用域的结构名称将会隐藏外层空间中相同的对象名，在C语言中则不会这样。
10. 在C++中，注释可以使用"//"注释符，而在C语言中则不能使用。

## 19.2 C++和Java的区别
Java和C++都是面向对象语言。也就是说，它们都能够实现面向对象思想（封装，继乘，多态）。而由于C++为了照顾大量的C语言使用者，而兼容了C，使得自身仅仅成为了带类的C语言，多多少少影响了其面向对象的彻底性！Java则是完全的面向对象语言，它句法更清晰，规模更小，更易学。它是在对多种程序设计语言进行了深入细致研究的基础上，据弃了其他语言的不足之处，从根本上解决了C++的固有缺陷。<br>

1. **指针**<br>
Java语言让编程者无法找到指针来直接访问内存无指针，并且增添了自动的内存管理功能，从而有效地防止了c/c++语言中指针操作失误，如野指针所造成的系统崩溃。但也不是说JAVA没有指针，虚拟机内部还是使用了指针，只是外人不得使用而已。这有利于Java程序的安全。
2. **多重继承**<br>
C++支持多重继承，这是C++的一个特征，它允许多父类派生一个类。尽管多重继承功能很强，但使用复杂，而且会引起许多麻烦，编译程序实现它也很不容易。Java不支持多重继承，但允许一个类继承多个接口(extends+implement)，实现了c++多重继承的功能，又避免了c++中的多重继承实现方式带来的诸多不便。
3. **数据类型及类**<br>
Java是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而c++允许将函数和变量定义为全局的。此外，Java中取消了C/C++中的结构和联合，消除了不必要的麻烦。
4. **自动内存管理**<br>Java程序中所有的对象都是用new操作符建立在内存堆栈上，这个操作符类似于c++的new操作符。下面的语句由一个建立了一个类Read的对象，然后调用该对象的work方法：<br>
```JAVA
Read r＝new Read()；
r.work()；
```
语句Read r＝new Read()；在堆栈结构上建立了一个Read的实例。Java自动进行无用内存回收操作，不需要程序员进行删除。而c++中必须由程序员释放内存资源，增加了程序设计者的负担。Java中当一个对象不被再用到时，无用内存回收器将给它加上标签以示删除。Java里无用内存回收程序是以线程方式在后台运行的，利用空闲时间工作。
5. **操作符重载**<br>
Java不支持操作符重载。操作符重载被认为是C++的突出特征，在Java中虽然类大体上可以实现这样的功能，但操作符重载的方便性仍然丢失了不少。Java语言不支持操作符重载是为了保持Java语言尽可能简单。
6. **预处理功能**<br>
Java不支持预处理功能。C/C++在编译过程中都有一个预编泽阶段，即众所周知的预处理器。预处理器为开发人员提供了方便，但增加了编译的复杂性。JAVA虚拟机没有预处理器，但它提供的引入语句(import)与C++预处理器的功能类似。
7. **Java不支持缺省函数参数，而C++支持**<br>
在C中，代码组织在函数中，函数可以访问程序的全局变量。C++增加了类，提供了类算法，该算法是与类相连的函数，C++类方法与Java类方法十分相似，然而，由于C++仍然支持C，所以不能阻止C++开发人员使用函数，结果函数和方法混合使用使得程序比较混乱。
Java没有函数，作为一个比C++更纯的面向对象的语言，Java强迫开发人员把所有例行程序包括在类中，事实上，用方法实现例行程序可激励开发人员更好地组织编码。
8. **字符串**<br>
C和C++不支持字符串变量，在C和C++程序中使用Null终止符代表字符串的结束，在Java中字符串是用类对象(string和stringBuffer)来实现的，这些类对象是Java语言的核心，用类对象实现字符串有以下几个优点：
	1. 在整个系统中建立字符串和访问字符串元素的方法是一致的；
	2. Java字符串类是作为Java语言的一部分定义的，而不是作为外加的延伸部分；
	3. Java字符串执行运行时检查，可帮助排除一些运行时发生的错误；
	4. 可对字符串用“+”进行连接操作。
9. **goto语句**<br>
“可怕”的goto语句是c和c++的“遗物”，它是该语言技术上的合法部分，引用goto语句引起了程序结构的混乱，不易理解，goto语句子要用于无条件转移子程序和多结构分支技术。鉴于以上理由，Java不提供goto语句，它虽然指定goto作为关键字，但不支持它的使用，使程序简洁易读。
10. **类型转换**<br>
在C和C++中有时出现数据类型的隐含转换，这就涉及了自动强制类型转换问题。例如，在C++中可将一浮点值赋予整型变量，并去掉其尾数。Java不支持C++中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。
11. **异常**<br>
Java中的异常机制用于捕获例外事件，增强系统容错能力<br>
```JAVA
try{
   //可能产生意外的代码
}catch(exceptionType name){
    //处理
}
```
其中exceptionType表示异常类型，而C++则没有如此方便的机制。