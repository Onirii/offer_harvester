# 1. static关键字
**static被用来控制变量的存储方式和可见性。**

## 1.1 引入缘由
在函数内部定义的变量、当程序执行到定义处时，编译器为变量在**栈**上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉。为了让变量的值保存至下一次调用时，最容易想到的方法是将其定义为全局变量，但是定义为全局变量破坏了此变量的访问范围**使得在此函数中定义的变量，不仅仅只受此函数控制**, **static**关键字可以很好地解决这个问题。
另外，在C++中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。

## 1.2 静态数据的存储
全局(静态)存储区分为DATA段和BSS段。DATA段(全局初始化区)存放初始化的全局变量和静态变量，BSS段(全局未初始化区)存放未初始化的全局变量和静态变量，程序运行结束时自动释放。<br>其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
在C++中static的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。<br>这样，它的空间分配有三个可能的地方:

1. 是作为类的外部接口的头文件，那里有类声明；
2. 是类定义的内部实现，那里有类的成员函数定义；
3. 是应用程序的main()函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义(只能声明数据成员)。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。<br>
优势：可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

## 1.3 在C/C++中static关键字的作用
1. 在修饰变量的时候，static修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
2. static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。
3. static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
4. 不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
5. 考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

## 1.4 静态全局变量的特点
1. 静态变量都在全局数据区分配内存；
2. 未经初始化的静态全局变量会被程序自动初始化为0(在函数体内声明的变量的自动初始化值是随机的，在函数体外被声明的自动变量也会被初始化为0)；
3. 静态全局变量在声明它的整个文件里都是可见的，在此文件外是不可见的。(在其他文件中可以定义相同名字的变量，不会发生冲突)。

## 1.5 静态局部变量的特点
1. 该变量在全局数据区分配内存；
2. 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
3. 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；
4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

## 1.6 全局变量和静态全局变量的区别
1. 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
2. 全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

# 2. C++中static的使用
## 2.1 静态数据成员
1. 静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。
2. 静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。
3. 静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0。
4. 静态数据成员既可以通过对象名引用，也可以通过类名引用。

## 2.2 静态函数成员
1. 静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。
2. 非静态成员函数有 this 指针，而静态成员函数没有 this 指针。
3. 静态成员函数主要用来访问静态数据成员而不能访问非静态成员。

# 3. C++中指针和引用的区别
**是否可以为空和是否可以被重新赋值**
## 3.1 分空区别
在任何情况下都不能使用指向空值的引用，但指针可以不指向任何对象。不存在指向空值的引用意味着使用引用的代码效率要比使用指针的高。
## 3.2 合法性区别
在使用引用之前不需要测试它的合法性，相反，指针总应该被测试，以防止其为空。
## 3.3 可修改区别
指针可以被重新赋值以指向另一个不同的对象，单引用总是指向在初始化时被指定的对象，以后不能改变，但是引用指向对象的内容可以改变。
## 3.4 应用区别
考虑到存在不指向任何对象的可能性或者能够在不同时刻指向不同对象时应该使用指针。总是指向一个对象而且只能指向一个对象时应该使用引用。

# 4. 数组和指针的区别
1. 数组用来保存数据，指针用来保存数据的地址；
2. 数组中的数据可以直接访问，指针所指向的数据需要间接访问，即首先取得指针的内容，把它作为地址，然后再从这个地址中提取数据；
3. 数组通常用于存储固定数目且数据类型相同的元素，指针通常用于动态数据结构；
4. 数组通常隐式分配与删除，指针相关的函数为malloc()和free();
5. 数组自身即为数据名， 指针通常指向匿名数据。

### 对于一个数组**char a[10]**而言，如果访问a[i]，步骤是：
1. 将a的地址读入寄存器，由于a其实就是一个别名，所以a的地址本身就是a[0]的地址；
2. 根据类型计算并添加偏移，得到目标地址；
3. 访问内存得到a[i]。

### 而如果声明是**char \*a**，访问a[i]，其步骤是：
1. 将a的地址读入寄存器，a是一个指针，指向a[0]的地址；
2. 访问内存读取a的值，得到a[0]的地址；
3. 根据类型计算并添加偏移量，得到目标地址；
4. 访问内存得到a[i]。

# 5. C++中的野指针
**野指针即指向不可用内存区域的指针。**<br>
野指针不是NULL指针，是指向“垃圾”内存的指针，如果对野指针进行操作，将会使程序发生不可预知的错误，甚至可能直接引起程序崩溃。
1. 指针变量没有初始化；<br>
指针变量在创建时应当被初始化，要么将其设置为NULL，要么让它指向合法的内存。
2. 指针指向的内存被释放了，但是指针本身没有被置NULL；<br>
对于堆内存操作，我们分配了一些空间（使用malloc函数、calloc函数或new操作符），使用完后释放（使用free函数或delete操作符），在指针指向的内存被释放后，应该将指针置为NULL。
3. 指针超过了变量的作用范围。<br>
即在变量的作用范围之外使用了指向变量地址的指针。这一般发生在将调用函数中的局部变量的地址传出来。这点容易被忽略，虽然代码是很可能可以执行无误，然而却是极其危险的。局部变量的作用范围虽然已经结束，内存已经被释放，然而地址值仍是可用的，不过随时都可能被内存管理分配给其他变量。
