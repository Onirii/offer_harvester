# 1. 操作系统的基本概念
## 1.1 操作系统的基本特征
### **并发**
并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。<br>
并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。<br>
操作系统通过引入进程和线程，使得程序能够并发运行。 <br>
### **共享**
共享是指系统中的资源可以被多个并发进程共同使用。<br>
存在两种共享方式：互斥共享和同时共享。<br>
互斥共享的资源称为**临界资源**，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制实现对临界资源的访问。
### **虚拟**
虚拟技术把一个物理实体转换为多个逻辑实体。<br>
主要有两种虚拟技术：**时分复用技术**和**空分复用技术**。<br>
多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片段并快速切换。<br>
虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行**页面置换**算法，将该页置换到内存中。<br>
### **异步**
异步是指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

## 1.2 操作系统的基本功能
### 1.2.1 进程管理
进程控制、进程同步、进程通信、死锁处理、处理机调度等。
### 1.2.2 内存管理
内存分配、地址映射、内存保护与共享、虚拟内存等。
### 1.2.3 文件管理
文件存储空间的管理、目录管理、文件读写管理和保护等。
### 1.2.4 设备管理
完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理、虚拟设备等。

## 1.3 系统调用
如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。<br>
Linux 的系统调用主要有：
Task|Commands
-|-
进程控制|fork();exit();wait();
进程通信|pipe();shmget();mmap();
文件操作|open();read();write();
设备操作|ioctl();read();write();
信息维护|getpid();alarm();sleep();
安全|chmod();umask();chown();

## 1.4 大内核与微内核
### 1.4.1 大内核
大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。
### 1.4.2 微内核
由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。<br>
在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。<br>
因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。<br>

## 1.5 中断
### 1.5.1 外中断
在CPU执行指令以外的时间引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
### 1.5.2 异常
由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。
### 1.5.3 陷入
在用户程序中使用系统调用。


# 2. 进程(Process)与线程(Thread)
## 2.1 进程与线程的概念
### 2.1.1 进程与线程
**进程**是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。<br>
程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就是进程。<br>
程序和进程的区别就在于：程序是指令的集合，它是程序运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。<br>
**线程**单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。<br>

## 2.2 为什么有了进程还要线程，它们又有什么区别？
### 2.2.1 为什么有了进程还需要线程？
进程属于在CPU和系统资源等方面提供的抽象，能够有效提高CPU的利用率。
进程的缺陷主要体现在：<br>
1. 进程在一个时间做一件事情；
2. 进程如果在执行过程中发生阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。
线程是在进程这个层次上提供的一层并发的抽象：<br>
1. 线程能够使系统在同一时间做多件事情；
2. 当进程遇到阻塞挂起时，例如等待输入，线程能够使不依赖输入数据的工作继续执行；
3. 线程可以有效利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高。

### 2.2.2 进程和线程有什么区别？
1. **拥有资源** 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属于进程的资源；
2. **调度** 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程的线程切换到另一个进程中的线程时，会引起进程切换；
3. **系统开销** 由于创建或者撤销进程时，系统都要为之分配或者回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或者撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需要保存和设置少量寄存器内容，开销很小。
4. **通信方面** 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC(Inter-Process Communication)。
5. **并发层次** 在计算机体系结构里，流水线提供指令级的并发进程属于在处理器这一层级提供的并发抽象，线程属于在进程这个层次再提供了一层并发的抽象。
6. **不同的操作系统资源管理方式** 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序鲁棒，但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

## 2.3 进程与线程各自是怎么同步的？
### 2.3.1 进程的同步方式
进程同步是指为了完成某种任务而建立的多个进程，这些进程在合作的过程中需要协调工作次序进行**有序的访问**而出现等待所产生的制约关系。<br>
把异步环境下的一组并发进程因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步。<br>
#### 2.3.1.1 信号量
#### 2.3.1.2 管程
#### 2.3.1.3 消息传递

### 2.3.2 线程同步方式
#### 2.3.2.1 临界区(Critical Section)
#### 2.3.2.2 互斥量(Mutex)
#### 2.3.2.3 信号量(Semaphore)
#### 2.3.2.4 时间(Event)
## 2.4 多进程与多线程有什么不同？
## 2.5 进程间如何通信？
## 2.6 僵尸进程是什么？
## 2.7 就绪状态的进程在等待什么？
## 2.8 两个进程访问临界区资源，会不会出现都获得自旋锁的情况？
## 2.9 server端监听端口，但是还没有客户端连接进来，此时进程处于什么状态？
## 2.10 空闲的进程和阻塞的进程状态会不会在唤醒时候误判？
## 2.11 进程状态转换图，动态就绪、静态就绪、动态阻塞、静态阻塞是什么？
## 2.12 多进程和多线程的使用场景
## 2.13 游戏服务器应该为用户开辟一个线程还是一个进程，为什么？
## 2.14 有了进程，为什么还要线程？
## 2.15 单核机器上写多线程程序，是否需要考虑加锁，为什么？
## 2.16 线程需要保存那些上下文，SP、PC、EAX这些寄存器有什么作用？
## 2.17 线程间的同步方式是怎么样的？ 具体的系统调用是怎么样的？
## 2.18 死循环和来连接时新建线程的方法效率有点低，怎么改进？
## 2.19 怎么唤醒被阻塞的socket线程？
## 2.20 怎么确定当前线程是繁忙还是阻塞？
## 2.21 假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？
## 2.22 线程池的概念、有点、调度处理方式和保护任务队列的方式？
## 2.23 线程池对线程的管理方式，包括初始化线程的方法、线程创建后的管理、指派任务的方式
## 2.24 线程池的实现
## 2.25 进程的内存结构
## 2.26 协程相对于进程和线程有什么共同点和区别？
## 2.27 怎么看一个进程占用了哪些端口？
## 2.28 Linux下进程与线程的区别？
## 2.29 如果要计算0~1000000所有的质数，我用单线程和多线程计算有什么区别？